<!doctype html><html lang="en"><head><meta charset="utf-8"><script async src="https://www.googletagmanager.com/gtag/js?id=G-H58NSPXYPF"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-H58NSPXYPF")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?b3392fb5f6d65fb10354f590338d1ee4",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,a,i){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/95vxjpui4h",(i=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,i)}(window,document,"clarity","script")</script><title>C语言计时函数 | holmofy</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="baidu_union_verify" content="b7d27ec946758934fcdf3c5c26386237"><meta description="time()函数与time_t类型头文件：time.h"><meta property="og:type" content="article"><meta property="og:title" content="C语言计时函数"><meta property="og:url" content="https://blog.hufeifei.cn/2017/07/C-C++/C%E8%AF%AD%E8%A8%80%E8%AE%A1%E6%97%B6%E5%87%BD%E6%95%B0/index.html"><meta property="og:site_name" content="holmofy"><link rel="canonical" href="https://blog.hufeifei.cn/2017/07/C-C++/C%E8%AF%AD%E8%A8%80%E8%AE%A1%E6%97%B6%E5%87%BD%E6%95%B0/index.html"><meta property="description" content="time()函数与time_t类型头文件：time.h"><meta name="description" content="time()函数与time_t类型头文件：time.h"><meta property="og:description" content="time()函数与time_t类型头文件：time.h"><meta property="article:published_time" content="2017-07-27T16:00:00.000Z"><meta property="article:modified_time" content="2024-05-03T05:17:06.687Z"><meta property="article:author" content="胡飞飞"><meta property="article:tag" content="C"><meta property="twitter:card" content="summary"><script data-ad-client="ca-pub-7111912103882824" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7111912103882824" crossorigin="anonymous"></script><script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js"></script><script type="text/javascript" src="//cpro.baidustatic.com/cpro/ui/cm.js" async defer></script><link rel="alternate" href="/atom.xml" title="holmofy" type="application/atom+xml"><link rel="icon" href="//www.hufeifei.cn/favicon.jpg"><link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"><link href="//unpkg.com/@waline/client@v3/dist/waline.css" rel="stylesheet" type="text/css"><link href="//at.alicdn.com/t/font_841402_efkj8jo1xld.css" rel="stylesheet" type="text/css"><link rel="stylesheet" href="//cdnjs.loli.net/ajax/libs/font-awesome/5.15.3/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/style.css"><link rel="dns-prefetch" href="//static.zhimg.com"><link rel="dns-prefetch" href="//at.alicdn.com"><link rel="dns-prefetch" href="//cdn.jsdelivr.net"><link rel="dns-prefetch" href="//img-blog.csdn.net"><link rel="dns-prefetch" href="//img-blog.csdnimg.cn"><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><style>
    figure.codeblock {
       margin: 0;
    }
    figure figcaption .tabs {
      display: flex;
      margin: 0;
    }
    figure figcaption .tabs .tab {
      cursor: pointer;
      list-style: none;
      padding: 5px 15px;
    }
    figure figcaption .tabs .tab.active {
      background: #2d2d2d;
      color: white;
    }
  </style></head><body><amp-auto-ads type="adsense" data-ad-client="ca-pub-7111912103882824"></amp-auto-ads><div id="container"><div id="wrap"><header id="header"><div class="outer" id="header-outer"><div class="inner" id="header-inner"><nav id="main-nav"><a class="nav-icon" id="main-nav-toggle"><i class="fas fa-bars"></i></a><a class="main-nav-link" href="//www.hufeifei.cn">主页</a><a class="main-nav-link" href="/">博客</a><a class="main-nav-link" href="/archives">归档</a><a class="main-nav-link" target="_blank" rel="noopener" href="//algo.hufeifei.cn">算法</a><a class="main-nav-link" href="/book">书籍</a><a class="main-nav-link" href="/github">Github</a></nav><nav id="sub-nav"><a class="nav-icon" id="nav-rss-link" href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a><a class="nav-icon" id="nav-search-btn" title="Search"><i class="fas fa-search"></i></a></nav><div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="fas fa-search"></i></button><input type="hidden" name="sitesearch" value="https://blog.hufeifei.cn"></form></div></div></div></header><div class="outer"><section id="main"><article class="article article-type-post" id="post-C-C++/C语言计时函数" itemscope itemprop="blogPost"><div class="article-meta"><a class="article-date" href="/2017/07/C-C++/C%E8%AF%AD%E8%A8%80%E8%AE%A1%E6%97%B6%E5%87%BD%E6%95%B0/"><time datetime="2017-07-27T16:00:00.000Z" itemprop="datePublished">2017-07-28</time></a><div class="article-category"><a class="article-category-link" href="/categories/C-C/">C&C++</a></div><div class="article-views leancloud_visitors" id="/2017/07/C-C++/C%E8%AF%AD%E8%A8%80%E8%AE%A1%E6%97%B6%E5%87%BD%E6%95%B0/" data-flag-title="C语言计时函数" title="Views"><i class="fas fa-eye"></i><span class="waline-pageview-count" data-path="/2017/07/C-C++/C%E8%AF%AD%E8%A8%80%E8%AE%A1%E6%97%B6%E5%87%BD%E6%95%B0/"></span></div></div><div class="article-inner"><header class="article-header" style="text-align:center"><h1 class="article-title" itemprop="name">C语言计时函数</h1></header><div class="article-entry" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2>time()函数与time_t类型</h2><p><strong>头文件</strong>：time.h</p><p><strong>函数签名</strong>：<code>time_t time( time_t *arg )</code></p><p><strong>说明</strong>：返回当前计算机纪元时间，并将其存储在arg指向的time_t类型中。所以可以<code>time_t result = time(NULL)</code>，也可以<code>time(&amp;result)</code>。</p><blockquote><p>计算机纪元时间：C语言和Unix创造并诞生于1970年，所以计算机以1970年1月1日作为纪元开始时间。</p></blockquote><p>C语言标准并没有指定time_t类型的编码方式，但大多数遵循POSIX标准系统的time_t一般是32位有符号整数实现，以秒为最小单位，从1970年1月1日开始计数，所以能表示到2038年。</p><p>VS2017中有如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CRT_NO_TIME_T</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> _USE_32BIT_TIME_T</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">__time32_t</span> <span class="type">time_t</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="type">__time64_t</span> <span class="type">time_t</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _USE_32BIT_TIME_T</span></span><br><span class="line">	...</span><br><span class="line">	    <span class="type">static</span> __inline <span class="type">time_t</span> __CRTDECL <span class="title function_">time</span><span class="params">(</span></span><br><span class="line"><span class="params">        _Out_opt_ <span class="type">time_t</span>* <span class="type">const</span> _Time</span></span><br><span class="line"><span class="params">        )</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> _time32(_Time);</span><br><span class="line">    }</span><br><span class="line">	...</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	...</span><br><span class="line">    <span class="type">static</span> __inline <span class="type">time_t</span> __CRTDECL <span class="title function_">time</span><span class="params">(</span></span><br><span class="line"><span class="params">        _Out_opt_ <span class="type">time_t</span>* <span class="type">const</span> _Time</span></span><br><span class="line"><span class="params">        )</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> _time64(_Time);</span><br><span class="line">    }</span><br><span class="line">	...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>因为time_t类型编码不能确定，所以尽量不要用<code>t1-t2</code>方式计算两个<code>time_t</code>之间的时间间隔，而应该用<code>double difftime( time_t time_end, time_t time_beg );</code>函数计算时间间隔。</p><p><strong>扩展</strong>：<code>time_t</code>表示计算机纪元时间，<code>struct tm</code>表示标准日历时间。</p><p><code>struct tm</code>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">int</span> tm_sec;   <span class="comment">// seconds after the minute - [0, 60] including leap second</span></span><br><span class="line">    <span class="type">int</span> tm_min;   <span class="comment">// minutes after the hour - [0, 59]</span></span><br><span class="line">    <span class="type">int</span> tm_hour;  <span class="comment">// hours since midnight - [0, 23]</span></span><br><span class="line">    <span class="type">int</span> tm_mday;  <span class="comment">// day of the month - [1, 31]</span></span><br><span class="line">    <span class="type">int</span> tm_mon;   <span class="comment">// months since January - [0, 11]</span></span><br><span class="line">    <span class="type">int</span> tm_year;  <span class="comment">// years since 1900</span></span><br><span class="line">    <span class="type">int</span> tm_wday;  <span class="comment">// days since Sunday - [0, 6]</span></span><br><span class="line">    <span class="type">int</span> tm_yday;  <span class="comment">// days since January 1 - [0, 365]</span></span><br><span class="line">    <span class="type">int</span> tm_isdst; <span class="comment">// daylight savings time flag</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure><p><code>time_t</code>可以和<code>struct tm</code>格式的时间进行互相转换：</p><ul><li><code>struct tm *gmtime( const time_t *time )</code>：从<code>time_t</code>转成<code>struct tm</code>，但该函数C11标准中才定义的。</li><li><code>time_t mktime( struct tm *time )</code>：从<code>struct tm</code>转成<code>time_t</code>。</li></ul><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> start, end;</span><br><span class="line">start = time(<span class="literal">NULL</span>);</span><br><span class="line">_sleep(<span class="number">1000</span>);</span><br><span class="line">end = time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"start time: %s\n"</span>, ctime(&amp;start));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"end time: %s\n"</span>, ctime(&amp;end));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"duration: %lf\n"</span>, difftime(end, start));</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start time: Fri Jul 28 09:48:25 2017</span><br><span class="line"></span><br><span class="line">end time: Fri Jul 28 09:48:26 2017</span><br><span class="line"></span><br><span class="line">duration: 1.000000</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：C标准库中的函数，可移植性最好，性能也很稳定，但精度太低，只能精确到秒，对于一般的事件计时还算够用，而对运算时间的计时就明显不够用了。</p><h2>clock()函数与clock_t类型</h2><p><strong>头文件</strong>：time.h</p><p><strong>函数签名</strong>：<code>clock_t clock(void)</code></p><p><strong>说明</strong>：该函数返回值是硬件滴答数（未加工的程序启动时开始经过的处理器时间），只有计算调用两次clock的返回值才有意义，要换算成秒，需要除以CLOCKS_PER_SEC（每秒中的滴答数），VC中定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLOCKS_PER_SEC  ((clock_t)1000)</span></span><br></pre></td></tr></table></figure><p>当CPU被多个进程共享，clock返回值可能慢于真实时钟，而如果一个进程内有多个线程或者多核处理，clock返回值可能快于真实时钟。</p><p><strong>注意</strong>：在32位机器上clock_t为32bit，所以clock_t在<code>2147483648</code>(2147秒或36分)后会回滚(即小于零)。</p><p><strong>示例</strong>：</p><p>示例1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">clock_t</span> start, end;</span><br><span class="line">start = clock();</span><br><span class="line">_sleep(<span class="number">1234</span>);</span><br><span class="line">end = clock();</span><br><span class="line"><span class="type">double</span> duration = ((<span class="type">double</span>)end - start) / CLOCKS_PER_SEC;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f second"</span>, duration);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.234000 second</span><br></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">clock_t</span> start, end;</span><br><span class="line">start = clock();</span><br><span class="line">_sleep(<span class="number">1234</span>);</span><br><span class="line">end = clock();</span><br><span class="line"><span class="type">int</span> duration = end - start;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d millisecond"</span>, duration);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1234 millisecond</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：可以精确到毫秒，适合一般场合的使用。</p><h2>timespec_get()函数与timespec类型</h2><p><strong>头文件</strong>：time.h</p><p><strong>函数签名</strong>：<code>int timespec_get( struct timespec *ts, int base)</code> （since C11）</p><p><strong>说明</strong>：以base为基底，将当前计算机纪元时间填充到ts地址中。</p><p>timespec结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;  <span class="comment">// Seconds - &gt;= 0</span></span><br><span class="line">    <span class="type">long</span>   tv_nsec; <span class="comment">// Nanoseconds - [0, 999999999]</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure><p>timespec精度是纳秒级。</p><p>C11标准中定义<code>TIME_UTC</code>为通用协调时间，并推荐使用TIME_UTC作为base基底。</p><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start</span>, <span class="title">end</span>;</span></span><br><span class="line">timespec_get(&amp;start, TIME_UTC);</span><br><span class="line">_sleep(<span class="number">1234</span>);</span><br><span class="line">timespec_get(&amp;end, TIME_UTC);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">strftime(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">"%Y/%m/%d %T"</span>, gmtime(&amp;start.tv_sec));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"start time: %s.%ld\n"</span>, buffer, start.tv_nsec);</span><br><span class="line">strftime(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">"%Y/%m/%d %T"</span>, gmtime(&amp;end.tv_sec));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"end time: %s.%ld\n"</span>, buffer, end.tv_nsec);</span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> d_sec = end.tv_sec - start.tv_sec;</span><br><span class="line"><span class="type">long</span> d_nsec = end.tv_nsec - start.tv_nsec;</span><br><span class="line"><span class="type">long</span> duration = d_sec*<span class="number">1E9</span> + d_nsec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"duration: %ld nanosecond\n"</span>, duration);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start time: 2017/07/28 04:34:26.577550200</span><br><span class="line">end time: 2017/07/28 04:34:27.811685800</span><br><span class="line">duration: 1234135600 nanosecond</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：C11标准库函数，跨平台特性好，精度能达到纳秒级，但是需要编译器支持C11。</p><hr><p>以上是C语言标准库提供的函数，跨平台特性较好，下面的几个是特定平台的API，所以视情况使用。</p><h2>timeGetTime()函数</h2><p><strong>头文件</strong>：timeapi.h（Windows.h中已经包括该头文件）</p><p><strong>函数签名</strong>：<code>DWORD timeGetTime(void)</code></p><p><strong>库</strong>：Winmm.lib；<strong>Dll</strong>：Winmm.dll</p><p><strong>说明</strong>：返回系统时间，以毫秒为单位。</p><p>timeGetTime函数返回值是一个DWORD(32bit)，会在0到<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:0" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="1.887ex" role="img" focusable="false" viewBox="0 -833.9 1290.1 833.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container>之间循环，大约49.71天。如果使用这个返回值作为控制语句的条件可能会出现问题，所以建议使用这个函数计算两个时间点之间的间隔。</p><p>timeGetTime函数的默认精度可以达到5毫秒或者更多，这个精度依赖于机器。可以使用timeBeginPeriod和timeEndPeriod函数增加timeGetTime的精度。timeGetTime返回的两个连续值之间的最小间隔可以和timeBeginPeriod和timeEndPeriod设置的最小周期一样大。</p><blockquote><p><a target="_blank" rel="noopener" href="https://msdn.microsoft.com/zh-cn/library/windows/desktop/dd757628(v=vs.85).aspx"><strong>timeGetSystemTime</strong></a>与timeGetTime的区别：</p><p>timeGetTime以DWORD存储时间</p><p>timeGetSystemTime以<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/zh-cn/library/windows/desktop/dd757347(v=vs.85).aspx"><strong>MMTIME</strong></a>结构体存储时间</p></blockquote><p><strong>示例</strong>：</p><p>示例一：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">"Winmm.lib"</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	DWORD start, end;</span><br><span class="line">	start = timeGetTime();</span><br><span class="line">	Sleep(<span class="number">1234</span>);</span><br><span class="line">	end = timeGetTime();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, end - start);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1235</span><br></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">"Winmm.lib"</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	DWORD start, end;</span><br><span class="line">	timeBeginPeriod(<span class="number">1</span>);</span><br><span class="line">	start = timeGetTime();</span><br><span class="line">	Sleep(<span class="number">1234</span>);</span><br><span class="line">	end = timeGetTime();</span><br><span class="line">	timeEndPeriod(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, end - start);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1234</span><br></pre></td></tr></table></figure><h2>GetTickCount函数</h2><p><strong>头文件</strong>：Winbase.h（Windows.h中已经包括该头文件）</p><p><strong>函数签名</strong>：DWORD WINAPI GetTickCount(void);</p><p><strong>库</strong>：Kernel32.lib；<strong>Dll</strong>：Kernel32.dll</p><p><strong>说明</strong>：返回系统启动后的时间，单位为毫秒。</p><p>GetTickCount功能只限于系统定时器，精度在10毫秒到16毫秒之间。GetTickCount的精度不受GetSystemTimeAdjustment函数影响。</p><p>该函数以DWORD(32bit)存储时间，如果系统连续运行49.7天，将会循环到0，为避免这个影响，建议使用GetTickCount64函数</p><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	DWORD start, end;</span><br><span class="line">	start = GetTickCount();</span><br><span class="line">	Sleep(<span class="number">1234</span>);</span><br><span class="line">	end = GetTickCount();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, end - start);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1234</span><br></pre></td></tr></table></figure><h2>QueryPerformanceCounter()、QueryPerformanceFrequency()高精度时间</h2><p><strong>头文件</strong>：Winbase.h (Windows.h中已经包括该头文件)</p><p><strong>函数签名</strong>：</p><ul><li><pre><code>BOOL WINAPI QueryPerformanceCounter(
  _Out_ LARGE_INTEGER *lpPerformanceCount
);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  BOOL WINAPI QueryPerformanceFrequency(</span><br><span class="line">    _Out_ LARGE_INTEGER *lpFrequency</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
</code></pre></li></ul><p><strong>库</strong>：Kernel32.lib；<strong>Dll</strong>：Kernel32.dll</p><p><strong>说明</strong>：QueryPerformanceFrequency获取CPU时钟频率；QueryPerformanceCounter获取CPU时钟计数器的当前值。通过这两个函数可以计算两点之间的时间间隔，精度为微妙级别。</p><p>LARGE_INTEGER定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">LARGE_INTEGER</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">        DWORD LowPart;</span><br><span class="line">        LONG HighPart;</span><br><span class="line">    } DUMMYSTRUCTNAME;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">        DWORD LowPart;</span><br><span class="line">        LONG HighPart;</span><br><span class="line">    } u;</span><br><span class="line">    LONGLONG QuadPart;</span><br><span class="line">} LARGE_INTEGER;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD64 <span class="title function_">ObtainCurrentTime</span><span class="params">()</span> {</span><br><span class="line">	LARGE_INTEGER num;</span><br><span class="line">	QueryPerformanceCounter(&amp;num);</span><br><span class="line">	<span class="keyword">return</span> num.QuadPart;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">DOUBLE <span class="title function_">ComputeDuration</span><span class="params">(DWORD64 end, DWORD64 start)</span> {</span><br><span class="line">	LARGE_INTEGER frequency;</span><br><span class="line">	QueryPerformanceFrequency(&amp;frequency);</span><br><span class="line">	<span class="keyword">return</span> (DOUBLE)(end - start) / frequency.QuadPart;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">	DWORD64 start, end;</span><br><span class="line">	start = ObtainCurrentTime();</span><br><span class="line">	Sleep(<span class="number">1234</span>);</span><br><span class="line">	end = ObtainCurrentTime();</span><br><span class="line">	DOUBLE duration = ComputeDuration(end, start);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lf microsecond"</span>, duration);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.234634 microsecond</span><br></pre></td></tr></table></figure><blockquote><p>更多方法可以参考<a target="_blank" rel="noopener" href="http://blog.csdn.net/fz_ywj/article/details/8109368">http://blog.csdn.net/fz_ywj/article/details/8109368</a></p></blockquote><blockquote><p><strong>参考链接：</strong></p><ul><li>C Reference：<a target="_blank" rel="noopener" href="http://en.cppreference.com/w/c/chrono">http://en.cppreference.com/w/c/chrono</a></li><li>MSDN-多媒体定时器：<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd743612(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/dd743612(v=vs.85).aspx</a></li><li>MSDN-高精度定时器：<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644900(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms644900(v=vs.85).aspx</a></li><li>MSDN-Windows时间：<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms725496(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms725496(v=vs.85).aspx</a></li><li>MSDN-时间相关函数：<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms725473(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms725473(v=vs.85).aspx</a></li><li>CSDN-常用计时方法总结：<a target="_blank" rel="noopener" href="http://blog.csdn.net/fz_ywj/article/details/8109368">http://blog.csdn.net/fz_ywj/article/details/8109368</a></li></ul></blockquote></div><div class="article-copyright"><p>本作品采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> 进行许可。</p><p>转载时请注明<a href="https://blog.hufeifei.cn/2017/07/C-C++/C%E8%AF%AD%E8%A8%80%E8%AE%A1%E6%97%B6%E5%87%BD%E6%95%B0/">原文链接</a>：https://blog.hufeifei.cn/2017/07/C-C++/C%E8%AF%AD%E8%A8%80%E8%AE%A1%E6%97%B6%E5%87%BD%E6%95%B0/</p></div><footer class="article-footer"><div class="article-tag"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C</a></li></ul></div></footer></div><div id="article-reward"><i class="iconfont ic-money"></i><div>鼓励一下</div><table><thead><tr><th style="text-align:center">支付宝</th><th style="text-align:center">微信</th></tr></thead><tbody><tr><td style="text-align:center"><img width="150" src="https://www.hufeifei.cn/reward-img/alipay.jpg"></td><td style="text-align:center"><img width="135" src="https://www.hufeifei.cn/reward-img/wechat.jpg"></td></tr></tbody></table></div><nav id="article-nav"><a class="article-nav-link-wrap" href="/2017/07/DataStructure/%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95%E3%80%81%E6%9B%B4%E7%9B%B8%E5%87%8F%E6%8D%9F%E6%B3%95%E3%80%81Stein%E7%AE%97%E6%B3%95/" id="article-nav-newer"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">辗转相除法、更相减损法、Stein算法</div></a><a class="article-nav-link-wrap" href="/2017/07/DataStructure/%E7%B4%A0%E6%95%B0%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95/" id="article-nav-older"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">素数检测算法</div></a></nav></article><div id="waline-comments"></div><script type="module">import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js';init({"el":"#waline-comments","pageview":true,"enable":true,"serverURL":"https://api.waline.blog.hufeifei.cn","avatar":"mp","pageSize":10,"lang":"zh-cn","placeholder":"Just go go","visitor":true,"recordIP":true,"requiredFields":["nick"]});</script></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">关注微信公众号</h3><div class="widget wechat"><img src="//www.hufeifei.cn/wechat-public-account.jpg"></div></div><div class="widget-wrap"><h3 class="widget-title">Categories</h3><div class="widget"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C&C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/J2EE/">J2EE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux%E8%BF%90%E7%BB%B4/">Linux运维</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby/">Ruby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rust/">Rust</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%A3%E7%A0%81%E6%97%A5%E5%B8%B8/">代码日常</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%95%86%E4%B8%9A/">商业</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%8F%E6%B5%8E%E4%B8%8E%E9%87%91%E8%9E%8D/">经济与金融</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/">计算机组成</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Tag Cloud</h3><div class="widget tagcloud"><a href="/tags/AVL/" style="font-size:11.11px">AVL</a> <a href="/tags/Alibaba/" style="font-size:14.44px">Alibaba</a> <a href="/tags/Android/" style="font-size:18.89px">Android</a> <a href="/tags/B-Tree/" style="font-size:12.22px">B-Tree</a> <a href="/tags/BKD-Tree/" style="font-size:10px">BKD-Tree</a> <a href="/tags/BST/" style="font-size:10px">BST</a> <a href="/tags/BigData/" style="font-size:11.11px">BigData</a> <a href="/tags/C/" style="font-size:14.44px">C</a> <a href="/tags/CGlib/" style="font-size:10px">CGlib</a> <a href="/tags/CS/" style="font-size:11.11px">CS</a> <a href="/tags/Canal/" style="font-size:10px">Canal</a> <a href="/tags/ClassLoader/" style="font-size:10px">ClassLoader</a> <a href="/tags/ClickHouse/" style="font-size:10px">ClickHouse</a> <a href="/tags/Config/" style="font-size:10px">Config</a> <a href="/tags/Cryptography/" style="font-size:10px">Cryptography</a> <a href="/tags/DB/" style="font-size:20px">DB</a> <a href="/tags/Dapper/" style="font-size:10px">Dapper</a> <a href="/tags/DataStructure/" style="font-size:14.44px">DataStructure</a> <a href="/tags/Debezium/" style="font-size:10px">Debezium</a> <a href="/tags/Diamond/" style="font-size:10px">Diamond</a> <a href="/tags/Distributed/" style="font-size:13.33px">Distributed</a> <a href="/tags/ElasticSearch/" style="font-size:10px">ElasticSearch</a> <a href="/tags/Encoding/" style="font-size:10px">Encoding</a> <a href="/tags/FastJson/" style="font-size:10px">FastJson</a> <a href="/tags/File/" style="font-size:10px">File</a> <a href="/tags/FlowMarketing/" style="font-size:10px">FlowMarketing</a> <a href="/tags/Grade/" style="font-size:10px">Grade</a> <a href="/tags/Gson/" style="font-size:10px">Gson</a> <a href="/tags/HTTP/" style="font-size:10px">HTTP</a> <a href="/tags/Handler/" style="font-size:10px">Handler</a> <a href="/tags/Hanlder/" style="font-size:10px">Hanlder</a> <a href="/tags/Hessian/" style="font-size:10px">Hessian</a> <a href="/tags/IO-Multiplex/" style="font-size:10px">IO-Multiplex</a> <a href="/tags/JAVA/" style="font-size:18.89px">JAVA</a> <a href="/tags/JVM/" style="font-size:10px">JVM</a> <a href="/tags/KD-Tree/" style="font-size:10px">KD-Tree</a> <a href="/tags/KDB-Tree/" style="font-size:10px">KDB-Tree</a> <a href="/tags/Kafka/" style="font-size:10px">Kafka</a> <a href="/tags/Kubernetes/" style="font-size:10px">Kubernetes</a> <a href="/tags/LSM-Tree/" style="font-size:11.11px">LSM-Tree</a> <a href="/tags/Linux/" style="font-size:17.78px">Linux</a> <a href="/tags/Lock/" style="font-size:11.11px">Lock</a> <a href="/tags/Lucene/" style="font-size:10px">Lucene</a> <a href="/tags/MQ/" style="font-size:10px">MQ</a> <a href="/tags/Macro/" style="font-size:10px">Macro</a> <a href="/tags/Magisk/" style="font-size:10px">Magisk</a> <a href="/tags/MultiDex/" style="font-size:10px">MultiDex</a> <a href="/tags/MySQL/" style="font-size:17.78px">MySQL</a> <a href="/tags/NIO/" style="font-size:10px">NIO</a> <a href="/tags/Nginx/" style="font-size:11.11px">Nginx</a> <a href="/tags/OGNL/" style="font-size:10px">OGNL</a> <a href="/tags/OpenResty/" style="font-size:10px">OpenResty</a> <a href="/tags/OpenTelemetry/" style="font-size:10px">OpenTelemetry</a> <a href="/tags/Oracle/" style="font-size:10px">Oracle</a> <a href="/tags/PostgreSQL/" style="font-size:10px">PostgreSQL</a> <a href="/tags/RB-Tree/" style="font-size:10px">RB-Tree</a> <a href="/tags/Redis/" style="font-size:10px">Redis</a> <a href="/tags/Rust/" style="font-size:10px">Rust</a> <a href="/tags/Sharding/" style="font-size:10px">Sharding</a> <a href="/tags/SpringBoot/" style="font-size:10px">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size:10px">SpringCloud</a> <a href="/tags/SpringCloudConfig/" style="font-size:10px">SpringCloudConfig</a> <a href="/tags/Sqlite/" style="font-size:10px">Sqlite</a> <a href="/tags/SurfaceView/" style="font-size:10px">SurfaceView</a> <a href="/tags/VSCode/" style="font-size:11.11px">VSCode</a> <a href="/tags/WebFlux/" style="font-size:10px">WebFlux</a> <a href="/tags/WebPush/" style="font-size:10px">WebPush</a> <a href="/tags/Web%E6%8C%96%E6%8E%98/" style="font-size:11.11px">Web挖掘</a> <a href="/tags/awk/" style="font-size:10px">awk</a> <a href="/tags/bit-hack/" style="font-size:10px">bit-hack</a> <a href="/tags/cheat-sheet/" style="font-size:10px">cheat sheet</a> <a href="/tags/curl/" style="font-size:10px">curl</a> <a href="/tags/epoll/" style="font-size:10px">epoll</a> <a href="/tags/gRPC/" style="font-size:10px">gRPC</a> <a href="/tags/grep/" style="font-size:10px">grep</a> <a href="/tags/kqueue/" style="font-size:10px">kqueue</a> <a href="/tags/libev/" style="font-size:10px">libev</a> <a href="/tags/libevent/" style="font-size:10px">libevent</a> <a href="/tags/libuv/" style="font-size:10px">libuv</a> <a href="/tags/metaq/" style="font-size:10px">metaq</a> <a href="/tags/poll/" style="font-size:10px">poll</a> <a href="/tags/sed/" style="font-size:10px">sed</a> <a href="/tags/select/" style="font-size:10px">select</a> <a href="/tags/ssh/" style="font-size:10px">ssh</a> <a href="/tags/%E5%8E%86%E5%8F%B2/" style="font-size:10px">历史</a> <a href="/tags/%E5%95%86%E4%B8%9A/" style="font-size:10px">商业</a> <a href="/tags/%E5%BF%83%E7%90%86%E5%AD%A6/" style="font-size:10px">心理学</a> <a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size:11.11px">生活</a> <a href="/tags/%E7%A8%8E%E6%94%B6/" style="font-size:10px">税收</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size:14.44px">算法</a> <a href="/tags/%E7%BB%8F%E6%B5%8E/" style="font-size:15.56px">经济</a> <a href="/tags/%E8%90%A5%E9%94%80/" style="font-size:10px">营销</a> <a href="/tags/%E8%B4%A7%E5%B8%81/" style="font-size:10px">货币</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size:16.67px">随笔</a></div></div><div class="widget-wrap"><h3 class="widget-title">Recent Posts</h3><div class="widget"><ul><li><a href="/2024/04/economic/value-added-tax/">增值税与贫富差距</a></li><li><a href="/2024/01/Net/x-forward-for/">“真”的IP真的是真的吗？</a></li><li><a href="/2024/01/paper/MarkupLM-web-extract/">【译】基于MarkupLM的web数据抽取</a></li><li><a href="/2023/09/economic/tax-reform/">直接税改革——王朝周期律的胜负手</a></li><li><a href="/2023/09/Rust/macro-rules-learning/">Rust中的宏</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">网站运营不易</h3><div class="ads-wrapper"><div class="google_ads"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7111912103882824" data-ad-slot="8429272980" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div></div></aside></div><footer id="footer"><div class="outer"><div class="inner" id="footer-info"><p><a href="https://beian.miit.gov.cn/" target="_blank">赣ICP备17009276号</a><i class="far fa-copyright"></i>2016 ~ 2024 胡飞飞</p><p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a><i class="fas fa-angle-right"></i>Theme by <a target="_blank" rel="noopener" href="https://github.com/holmofy/hexo-theme-paper">paper</a></p></div></div></footer></div><nav id="mobile-nav"><a class="mobile-nav-link" href="//www.hufeifei.cn">主页</a><a class="mobile-nav-link" href="/">博客</a><a class="mobile-nav-link" href="/archives">归档</a><a class="mobile-nav-link" target="_blank" rel="noopener" href="//algo.hufeifei.cn">算法</a><a class="mobile-nav-link" href="/book">书籍</a><a class="mobile-nav-link" href="/github">Github</a></nav><script src="//cdnjs.loli.net/ajax/libs/jquery/3.0.0/jquery.min.js"></script><link rel="stylesheet" href="//cdnjs.loli.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="//cdnjs.loli.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/script.js"></script></div><script>
  $(document).ready(function() {
    $('figure.codeblock').find('.tab').click(function() {
        var $codeblock = $(this).parent().parent().parent();
        var $tab = $(this);
        // remove "active" css class on all tabs
        $tab.siblings().removeClass('active');
        // add "active" css class on the clicked tab
        $tab.addClass('active');
        // hide all tab contents
        $codeblock.find('.highlight').hide();
        // show only the right one
        $codeblock.find('.highlight.' + $tab.text()).show();
    });
  });
  </script><script>(function (w, d, s, id) {
            if (typeof (w.webpushr) !== 'undefined') return; w.webpushr = w.webpushr || function () { (w.webpushr.q = w.webpushr.q || []).push(arguments) }; var js, fjs = d.getElementsByTagName(s)[0]; js = d.createElement(s); js.id = id; js.async = 1; js.src = "https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window, document, 'script', 'webpushr-jssdk'));webpushr('setup', { 'key': 'BPJzNs1QEtbYa3Bn0gMAQHBAzX3Jm71llGUKHTkKEUs3D9xiDYZ0DWJ3S9sfCAAJHxXEoBkUANFyONjeIlgrJUo'' });</script></body></html>