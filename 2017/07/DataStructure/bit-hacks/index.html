<!doctype html><html lang="en"><head><meta charset="utf-8"><script async src="https://www.googletagmanager.com/gtag/js?id=G-H58NSPXYPF"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-H58NSPXYPF")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?b3392fb5f6d65fb10354f590338d1ee4",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,a,i){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/95vxjpui4h",(i=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,i)}(window,document,"clarity","script")</script><title>【译】位运算的奇技淫巧：Bit Twiddling Hacks | holmofy</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="baidu_union_verify" content="b7d27ec946758934fcdf3c5c26386237"><meta description="原文名：Bit Twiddling Hacks 原文地址：http:&amp;#x2F;&amp;#x2F;graphics.stanford.edu&amp;#x2F;~seander&amp;#x2F;bithacks.html 作者：Sean Eron Anderson, seander@cs.stanford.edu  本文所包含的代码片段不受著作权法的限制(除非有特别注明)，任何人可以自由使用。本文的收集整理工作由Sean Eron Anderson在19"><meta property="og:type" content="article"><meta property="og:title" content="【译】位运算的奇技淫巧：Bit Twiddling Hacks"><meta property="og:url" content="https://blog.hufeifei.cn/2017/07/DataStructure/bit-hacks/index.html"><meta property="og:site_name" content="holmofy"><link rel="canonical" href="https://blog.hufeifei.cn/2017/07/DataStructure/bit-hacks/index.html"><meta property="description" content="原文名：Bit Twiddling Hacks 原文地址：http:&amp;#x2F;&amp;#x2F;graphics.stanford.edu&amp;#x2F;~seander&amp;#x2F;bithacks.html 作者：Sean Eron Anderson, seander@cs.stanford.edu  本文所包含的代码片段不受著作权法的限制(除非有特别注明)，任何人可以自由使用。本文的收集整理工作由Sean Eron Anderson在19"><meta name="description" content="原文名：Bit Twiddling Hacks 原文地址：http:&amp;#x2F;&amp;#x2F;graphics.stanford.edu&amp;#x2F;~seander&amp;#x2F;bithacks.html 作者：Sean Eron Anderson, seander@cs.stanford.edu  本文所包含的代码片段不受著作权法的限制(除非有特别注明)，任何人可以自由使用。本文的收集整理工作由Sean Eron Anderson在19"><meta property="og:description" content="原文名：Bit Twiddling Hacks 原文地址：http:&amp;#x2F;&amp;#x2F;graphics.stanford.edu&amp;#x2F;~seander&amp;#x2F;bithacks.html 作者：Sean Eron Anderson, seander@cs.stanford.edu  本文所包含的代码片段不受著作权法的限制(除非有特别注明)，任何人可以自由使用。本文的收集整理工作由Sean Eron Anderson在19"><meta property="article:published_time" content="2017-07-29T16:00:00.000Z"><meta property="article:modified_time" content="2024-05-03T05:17:06.691Z"><meta property="article:author" content="胡飞飞"><meta property="article:tag" content="位运算"><meta property="keywords" content="位运算"><meta property="twitter:card" content="summary"><script data-ad-client="ca-pub-7111912103882824" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7111912103882824" crossorigin="anonymous"></script><script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js"></script><script type="text/javascript" src="//cpro.baidustatic.com/cpro/ui/cm.js" async defer></script><link rel="alternate" href="/atom.xml" title="holmofy" type="application/atom+xml"><link rel="icon" href="//www.hufeifei.cn/favicon.jpg"><link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"><link href="//unpkg.com/@waline/client@v3/dist/waline.css" rel="stylesheet" type="text/css"><link href="//at.alicdn.com/t/font_841402_efkj8jo1xld.css" rel="stylesheet" type="text/css"><link rel="stylesheet" href="//cdnjs.loli.net/ajax/libs/font-awesome/5.15.3/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/style.css"><link rel="dns-prefetch" href="//static.zhimg.com"><link rel="dns-prefetch" href="//at.alicdn.com"><link rel="dns-prefetch" href="//cdn.jsdelivr.net"><link rel="dns-prefetch" href="//img-blog.csdn.net"><link rel="dns-prefetch" href="//img-blog.csdnimg.cn"><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><style>
    figure.codeblock {
       margin: 0;
    }
    figure figcaption .tabs {
      display: flex;
      margin: 0;
    }
    figure figcaption .tabs .tab {
      cursor: pointer;
      list-style: none;
      padding: 5px 15px;
    }
    figure figcaption .tabs .tab.active {
      background: #2d2d2d;
      color: white;
    }
  </style></head><body><amp-auto-ads type="adsense" data-ad-client="ca-pub-7111912103882824"></amp-auto-ads><div id="container"><div id="wrap"><header id="header"><div class="outer" id="header-outer"><div class="inner" id="header-inner"><nav id="main-nav"><a class="nav-icon" id="main-nav-toggle"><i class="fas fa-bars"></i></a><a class="main-nav-link" href="//www.hufeifei.cn">主页</a><a class="main-nav-link" href="/">博客</a><a class="main-nav-link" href="/archives">归档</a><a class="main-nav-link" target="_blank" rel="noopener" href="//algo.hufeifei.cn">算法</a><a class="main-nav-link" href="/book">书籍</a><a class="main-nav-link" href="/github">Github</a></nav><nav id="sub-nav"><a class="nav-icon" id="nav-rss-link" href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a><a class="nav-icon" id="nav-search-btn" title="Search"><i class="fas fa-search"></i></a></nav><div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="fas fa-search"></i></button><input type="hidden" name="sitesearch" value="https://blog.hufeifei.cn"></form></div></div></div></header><div class="outer"><section id="main"><article class="article article-type-post" id="post-DataStructure/bit-hacks" itemscope itemprop="blogPost"><div class="article-meta"><a class="article-date" href="/2017/07/DataStructure/bit-hacks/"><time datetime="2017-07-29T16:00:00.000Z" itemprop="datePublished">2017-07-30</time></a><div class="article-category"><a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></div><div class="article-views leancloud_visitors" id="/2017/07/DataStructure/bit-hacks/" data-flag-title="【译】位运算的奇技淫巧：Bit Twiddling Hacks" title="Views"><i class="fas fa-eye"></i><span class="waline-pageview-count" data-path="/2017/07/DataStructure/bit-hacks/"></span></div></div><div class="article-inner"><header class="article-header" style="text-align:center"><h1 class="article-title" itemprop="name">【译】位运算的奇技淫巧：Bit Twiddling Hacks</h1></header><div class="article-entry" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>原文名：<a target="_blank" rel="noopener" href="http://graphics.stanford.edu/~seander/bithacks.html">Bit Twiddling Hacks</a></p><p>原文地址：<a target="_blank" rel="noopener" href="http://graphics.stanford.edu/~seander/bithacks.html">http://graphics.stanford.edu/~seander/bithacks.html</a></p><p>作者：Sean Eron Anderson, <a href="mailto:&#115;&#x65;&#97;&#110;&#100;&#101;&#x72;&#x40;&#x63;&#115;&#x2e;&#115;&#x74;&#97;&#110;&#102;&#111;&#x72;&#x64;&#x2e;&#101;&#x64;&#x75;">seander@cs.stanford.edu</a></p></blockquote><p>本文所包含的代码片段不受著作权法的限制(除非有特别注明)，任何人可以自由使用。本文的收集整理工作由Sean Eron Anderson在1997-2005年完成。希望这篇文章以及这些代码能帮助到读者，但是在使用这些代码时，发生错误不提供任何担保。截止到2005年5月5日，这些代码也已经被彻底地进行了测试，并且很多人阅读过这些代码。除此之外，卡内基梅隆大学计算机科学学院院长Randal Bryant教授使用他的Uclid代码检验系统亲自为大部分代码进行了测试。对于其他没有被测试覆盖到的部分，我在32位计算机上测试了所有可行的输入。对于第一个在代码中发现一个合理bug的人，我会悬赏10美元（支票或者Paypal）。如果发现者有意将赏金捐献给慈善机构，那么我愿意支付20美元。</p><p>[TOC]</p><h3>关于运算次数的统计方法</h3><p>当讨论到计算某个算法的运算次数时，任何一个C语言的运算符都会被统计为一次运算。中间变量的赋值，即不需要写入到内存中的赋值操作，不会被统计在内。当然，这种统计方法只能得到综合机器指令和CPU时间的一个近似值。影响一段程序在系统中的运行时间的因素非常多，比如缓存大小，内存带宽，不同的指令集等等。所有运算消耗的时间相同在现实中是不成立的，但是CPU技术随着时间的推移，正在往这个方向飞速发展。总的来说，想要判断一种方法比另一种方法更快，最好的方式是直接到你的目标机器上去跑基准测试，测试性能的优异。</p><h3>计算整数的符号</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> v;      <span class="comment">// we want to find the sign of v</span></span><br><span class="line">            <span class="comment">// 我们希望得出v的符号（正负）</span></span><br><span class="line"><span class="type">int</span> sign;   <span class="comment">// the result goes here</span></span><br><span class="line">            <span class="comment">// 结果保存在这个变量里</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CHAR_BIT is the number of bits per byte (normally 8).</span></span><br><span class="line"><span class="comment">// 常量CHAR_BIT指是一个比特里包含多少位（通常情况下是8位）</span></span><br><span class="line">sign = -(v &lt; <span class="number">0</span>);  <span class="comment">// if v &lt; 0 then -1, else 0.</span></span><br><span class="line"><span class="comment">// or, to avoid branching on CPUs with flag registers (IA32):</span></span><br><span class="line"><span class="comment">// 或者，为了防止在有标志寄存器的CPU(Intel32位X86架构)上出现分支指令</span></span><br><span class="line">sign = -(<span class="type">int</span>)((<span class="type">unsigned</span> <span class="type">int</span>)((<span class="type">int</span>)v) &gt;&gt; (<span class="keyword">sizeof</span>(<span class="type">int</span>) * CHAR_BIT - <span class="number">1</span>));</span><br><span class="line"><span class="comment">// or, for one less instruction (but not portable):</span></span><br><span class="line"><span class="comment">// 或者，牺牲移植性来减少一个指令</span></span><br><span class="line">sign = v &gt;&gt; (<span class="keyword">sizeof</span>(<span class="type">int</span>) * CHAR_BIT - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><blockquote><p>译者注：IntelX86架构的比较指令(cmp)通常与条件跳转语句配合使用。参考链接：<a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/25623721/why-does-this-method-of-computing-the-sign-of-an-integer-avoids-branching-on-cpu">关于这段代码为何能够防止出现分支指令的讨论</a>）</p></blockquote><p>对于32位整型数来说，上面的最后一条语句会计算<code>sign=v&gt;&gt;31</code>。这样的方式比<code>sign=-(v&lt;0)</code>这种直接的方式要快一次运算左右。由于右移时，最左端的符号位会被填充到多出来的位中，所以在这个技巧（指v&gt;&gt;31）能够工作。如果最左端的符号位是1，那么结果就是-1；否则就是0。因为右移时，负数的所有位都会被填充为1，而二进制位全1正好是是-1的补码。不过不幸的是，这个操作是依赖底层实现的（所以是说牺牲了移植性）。</p><blockquote><p>译者注：<a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/141525/what-are-bitwise-shift-bit-shift-operators-and-how-do-they-work">关于右移操作自动填充符号位的讨论</a></p></blockquote><p>也许你可能更喜欢，对于正数返回1，对于负数返回-1，那么有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sign = +<span class="number">1</span> | (v &gt;&gt; (<span class="keyword">sizeof</span>(<span class="type">int</span>) * CHAR_BIT - <span class="number">1</span>));  <span class="comment">// if v &lt; 0 then -1, else +1</span></span><br></pre></td></tr></table></figure><p>更或者，还有对于负数零正数而返回-1, 0, 1的方案，那么有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sign = (v != <span class="number">0</span>) | -(<span class="type">int</span>)((<span class="type">unsigned</span> <span class="type">int</span>)((<span class="type">int</span>)v) &gt;&gt; (<span class="keyword">sizeof</span>(<span class="type">int</span>) * CHAR_BIT - <span class="number">1</span>));</span><br><span class="line"><span class="comment">// Or, for more speed but less portability:</span></span><br><span class="line"><span class="comment">// 或者，牺牲移植性来提升速度</span></span><br><span class="line">sign = (v != <span class="number">0</span>) | (v &gt;&gt; (<span class="keyword">sizeof</span>(<span class="type">int</span>) * CHAR_BIT - <span class="number">1</span>));  <span class="comment">// -1, 0, or +1</span></span><br><span class="line"><span class="comment">// Or, for portability, brevity, and (perhaps) speed:</span></span><br><span class="line"><span class="comment">// 或者，更易移植，更加简洁，或者(有可能)更快的方案</span></span><br><span class="line">sign = (v &gt; <span class="number">0</span>) - (v &lt; <span class="number">0</span>); <span class="comment">// -1, 0, or +1</span></span><br></pre></td></tr></table></figure><p>反之，如果你希望对于负数返回0，非负数返回+1，那么有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sign = <span class="number">1</span> ^ ((<span class="type">unsigned</span> <span class="type">int</span>)v &gt;&gt; (<span class="keyword">sizeof</span>(<span class="type">int</span>) * CHAR_BIT - <span class="number">1</span>)); <span class="comment">// if v &lt; 0 then 0, else 1</span></span><br></pre></td></tr></table></figure><p>附加说明：</p><p>2003年3月7日，Augus Duggan指出1989 ANSI C标准指明带符号数右移的结构是由编译器实现时定义(implementation-defined)的，所以这个技巧有可能不会正常工作。</p><p>2005年9月28日，Toby Speight为了提高移植性，他提议使用CHAR_BIT常量表示比特的长度，而不是简单地假设比特长度是8位。</p><p>2006年3月4日，Augus提出了几种更具移植性的代码版本，包括类型转换。</p><p>2009年9月12日，<a target="_blank" rel="noopener" href="http://rpg-314.blogspot.com/">Rohit Gary</a>提出了集中支持非负数的代码版本。</p><h3>判断两整数符号是否相反</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x, y;               <span class="comment">// input values to compare signs</span></span><br><span class="line">                        <span class="comment">// 输入的数值放在变量x和y中，用于比较符号</span></span><br><span class="line"><span class="type">bool</span> f = ((x ^ y) &lt; <span class="number">0</span>); <span class="comment">// true iff x and y have opposite signs</span></span><br><span class="line">                        <span class="comment">// 当且仅当(iff) x和y的符号相反时返回true</span></span><br></pre></td></tr></table></figure><p>2009年11月26日，Manfred Weis建议我加入这一条内容。</p><h3>计算整数的绝对值(不使用分支指令)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> v;           <span class="comment">// we want to find the absolute value of v</span></span><br><span class="line">                 <span class="comment">// 我们希望算出变量v的绝对值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r;  <span class="comment">// the result goes here</span></span><br><span class="line">                 <span class="comment">// 结果保存在这里</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> mask = v &gt;&gt; <span class="keyword">sizeof</span>(<span class="type">int</span>) * CHAR_BIT - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">r = (v + mask) ^ mask;</span><br></pre></td></tr></table></figure><p>一个简单的变形:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = (v ^ mask) - mask;</span><br></pre></td></tr></table></figure><p>有些CPU并不支持计算整数绝对值的指令（也可以说有些编译器没用上这些指令）。在有的机器上，分支判断操作非常昂贵，会消耗较多计算资源。在这些机器上，上面的表达式会比 <code>r = (v &lt; 0) ? -(unsigned)v : v</code> 这种简单的实现更快一些，尽管他们的操作数都是相同的。</p><p>2003年3月7日，Augus Duggan指出1989 ANSI C标准指明带符号数右移的结构是由编译器实现时定义(implementation-defined)的，所以这个技巧有可能不会正常工作。同时，我也阅读了ANSI C标准，发现ANSI C并没有要求数值一定要以二补数（two’s complement，即补码）的形式表示出来，所以由于这个原因，上面的技巧（在一些极少部分仍使用一补数(one’s complement)的古董机器上）也有可能不工作。</p><p>2004年3月14日，Keith H. Duggar提出了上面的变形。这个版本比我一开始想出来的初始版本更好，<code>r=(+1|(v&gt;&gt;(sizeof(int)*CHAR_BIT-1)))*v</code>，其中有一次乘法是没用的。</p><p>不幸的是，2000年6月6日，这个技巧已经被Vladimir Yu Volkonsky在美国申请了专利，并且归属于<a target="_blank" rel="noopener" href="http://www.sun.com/">Sun公司的Microsystems</a>。<br>2006年8月13日，Yuriy Kaminskiy告诉我这个专利可能是无效的，因为这个技巧在申请专利之前就被人公开发表了，见1996年11月9日，由Agner Fog发表的<a target="_blank" rel="noopener" href="http://www.goof.com/pcg/doc/pentopt.txt">How to Optimize for the Pentium Processor</a>。Yuriy同时也提到这份文档在1997年被翻译成了俄语，所以Vladimir有可能阅读过。除此之外，The Internet Archive（网站时光倒流机器）网站也收录了这个老旧的链接。</p><p>2007年1月30日，Peter Kankowski给我分享了一个他的<a target="_blank" rel="noopener" href="http://www.strchr.com/optimized_abs_function">发现</a>。这来源于他在观察微软的Visual C++编译器的输出时的发现。这个技巧在这里被采用为最优解法。</p><p>(译者注，Peter发现了VC++的编译器有可能使用了之前那个被Sun公司专利保护的技巧，但在评论中也同时有人指出Sun公司的这个专利是无效的)</p><p>2007年12月6日，Hai Jin提出反对意见，算法的结果是带符号的，所以在计算最大的负数时，结果会依然是负的。</p><p>2008年4月15日，Andrew Shapira指出上面的那个简单实现的版本可能会溢出，需要一个<code>(unsigned)</code>来做强制类型转换；为了最大程度的兼容性，他提议使用<code>(v &lt; 0) ? (1 + ((unsigned)(-1-v))) : (unsigned)v</code>。但是根据2008年7月9日的ISO C99标准，Vincent Lefèvre说服我删除了这个版本，因为即便是在非基于二补数的机器上，<code>-(unsigned)v</code>这条语句也会做我们希望他做的事情。在计算<code>-(signed)v</code>时，程序会通过将负数v增加2**N来得到无符号类型的数，这个数正好是v的补码表示形式，我们令U等于这个数。然后将U的符号取负，就能得出结果，有-U=0-U=2**N-U=2**N-(v+2**N)=-v=abs(v)。</p><h3>计算两个整数之间的最大值和最小值(不使用分支指令)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;  <span class="comment">// we want to find the minimum of x and y</span></span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">        <span class="comment">// 我们希望找出x和y之间的最小值</span></span><br><span class="line"><span class="type">int</span> r;  <span class="comment">// the result goes here</span></span><br><span class="line">        <span class="comment">// 结果保存在这里</span></span><br><span class="line">r = y ^ ((x ^ y) &amp; -(x &lt; y)); <span class="comment">// min(x, y)</span></span><br></pre></td></tr></table></figure><p>这个技巧能工作的原因是当<code>x&lt;y</code>, 那么<code>-(x&lt;y)</code>数值的二进制补码会是全1（-1的补码是全1），所以<code>r = y ^ (x ^ y) &amp; ~0 = y ^ x ^ y = x</code>。反之，如果<code>x&gt;=y</code>，那么<code>-(x&lt;y)</code>会是全0，所以<code>r = y ^ ((x ^ y) &amp; 0) = y</code>。在有些分支操作非常昂贵的机器，和没有提供条件跳转指令的机器上，上面的技巧会比这种常见的写法更快一些：<code>r = (x &lt; y) ? x : y</code>，尽管这种常见的写法只使用了两三个指令。（虽然通常来讲，这种简单实现是最好的）。需要注意的是，在有的机器上，计算<code>x&lt;y</code>的值也需要使用分支指令，所以这个时候这个技巧对比普通的实现也没有任何优势。</p><p>如果需要计算最大值，那么有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r = x ^ ((x ^ y) &amp; -(x &lt; y)); <span class="comment">// max(x, y)</span></span><br></pre></td></tr></table></figure><p>快但是有缺陷(dirty)的版本：</p><p>如果事先知道<code>INT_MIN &lt;= x - y &lt;= INT_MAX</code>(译者注：不会溢出)，那么你就可以使用以下技巧。由于(x-y)只需要计算一次，所以这个版本会更快一些。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = y + ((x - y) &amp; ((x - y) &gt;&gt; (<span class="keyword">sizeof</span>(<span class="type">int</span>) * CHAR_BIT - <span class="number">1</span>))); <span class="comment">// min(x, y)</span></span><br><span class="line">r = x - ((x - y) &amp; ((x - y) &gt;&gt; (<span class="keyword">sizeof</span>(<span class="type">int</span>) * CHAR_BIT - <span class="number">1</span>))); <span class="comment">// max(x, y)</span></span><br></pre></td></tr></table></figure><p>注意，1989年的ANSI C标准并没有指明带符号类型变量的右移行为，所以这个版本不具备兼容性。如果计算时由于溢出而导致抛出异常，x和y的值都应该是无符号型的或者被强制转换成无符号型的，来避免由于减法而导致不必要地抛出异常。然而，当进行右移操作是需要用强制类型转换，将数值转换成带符号的，这样才能根据数值的正负来产生全0和全1。</p><p>2003年3月7日，Angus Duggan指出了右移操作的兼容性问题。<br>2005年5月3日，Randal E.Bryant提示我只有在<code>INT_MIN &lt;= x - y &lt;= INT_MAX</code>的先决条件下，那个炫酷版本的代码才算完善，并且他还提出了之前那个较朴实的解法。这些问题都需要在炫酷版本的代码中考虑到。<br>2005年7月6日，Nigel Horspoon注意到gcc在一款奔腾处理器上编译这份代码时，由于其计算(x-y)的方式，而产生了和之前的简单写法相同的代码。<br>2008年7月9日，Vincent Lefèvre指出上一个版本中，即<code>r = y + ((x - y) &amp; -(x &lt; y))</code>，存在减法溢出的潜在风险。<br>2009年6月2日，Timothy B. Terriberry建议使用异或来代替加减以避免强制类型转换和溢出的风险。</p><h3>判断某个整数是不是2的次幂</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v; <span class="comment">// we want to see if v is a power of 2</span></span><br><span class="line">                <span class="comment">// 判断变量v是否是2的次幂</span></span><br><span class="line"><span class="type">bool</span> f;         <span class="comment">// the result goes here</span></span><br><span class="line">                <span class="comment">// 结果保存在这里</span></span><br><span class="line"></span><br><span class="line">f = (v &amp; (v - <span class="number">1</span>)) == <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>注意，0也是2的幂，但运算发生错误。为了更严谨一些，有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = v &amp;&amp; !(v &amp; (v - <span class="number">1</span>));</span><br></pre></td></tr></table></figure><h3>符号扩展</h3><h4>符号扩展(固定位长)</h4><p>符号扩展(sign extension)是系统内建的自动机制，比如char型和int型之间的互相转换。但当你有一个带符号长度为b位的补码数x，你想要把x转换为长度超过b位的int型时，这个机制就不能满足需求了。诚然，简单赋值对于正数x是有效的，但是负数x都不行了，因为符号位需要被扩展。举个例子来简单说明什么是符号扩展(sign extension)，我们现在有一个4位长的变量来保存数，对于-3来说，保存下来的补码形式为1101。如果我们有8位长，那么-3保存下来的补码形式为11111101。当尝试将一个4位长的数转换为更多位长的数时，符号位会向左复制填充空出来的位，直到填满。在C语言中，使用结构体或联合体的位域很容易实现固定长度的符号扩展。比如，将长度为5位的数转换成整型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x; <span class="comment">// convert this from using 5 bits to a full int</span></span><br><span class="line">       <span class="comment">// 变量x中保存长度为5位的数</span></span><br><span class="line"><span class="type">int</span> r; <span class="comment">// resulting sign extended number goes here</span></span><br><span class="line">       <span class="comment">// 转换的结果保存在变量r中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> {</span><span class="type">signed</span> <span class="type">int</span> x:<span class="number">5</span>;} s;</span><br><span class="line">r = s.x = x;</span><br></pre></td></tr></table></figure><p>下面的C++模版函数使用了同样的语言特性通过一次操作来转换长度为B的数到整型(当然，编译器会生成更多代码)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">unsigned</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">signextend</span><span class="params">(<span class="type">const</span> T x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">struct</span> {T x:B;} s;</span><br><span class="line">  <span class="keyword">return</span> s.x = x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r = <span class="built_in">signextend</span>&lt;<span class="type">signed</span> <span class="type">int</span>,<span class="number">5</span>&gt;(x);  <span class="comment">// sign extend 5 bit number x to r</span></span><br><span class="line">                                      <span class="comment">// 从5位长的数x转换到r</span></span><br></pre></td></tr></table></figure><p>2005年5月2日，John Byrd找到了一处由于html格式问题导致的样式显示错误。</p><p>2006年3月4日，Pat Wood指出ANSI C标准规定带符号的位域必须要用关键字“signed”来显式地指定其带符号，否则其符号位是未定义的。</p><h4>符号扩展(可变位长)</h4><p>有时，我们可能事先不知道位的长度，来完成符号扩展，上面的技巧就失效了。（也有可能是在某些不提供位域功能的编程语言，如Java）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> b; <span class="comment">// number of bits representing the number in x</span></span><br><span class="line">            <span class="comment">// 变量b指定需要扩展的位长</span></span><br><span class="line"><span class="type">int</span> x;      <span class="comment">// sign extend this b-bit number to r</span></span><br><span class="line">            <span class="comment">// 需要将变量x中的数值符号扩展的结果保存到r中</span></span><br><span class="line"><span class="type">int</span> r;      <span class="comment">// resulting sign-extended number</span></span><br><span class="line">            <span class="comment">// 存放计算结果到变量r</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> m = <span class="number">1U</span> &lt;&lt; (b - <span class="number">1</span>); <span class="comment">// mask can be pre-computed if b is fixed</span></span><br><span class="line">                             <span class="comment">// 如果b是常量，那么这个掩码可以被预处理</span></span><br><span class="line"></span><br><span class="line">x = x &amp; ((<span class="number">1U</span> &lt;&lt; b) - <span class="number">1</span>);  <span class="comment">// (Skip this if bits in x above position b are already zero.)</span></span><br><span class="line">                          <span class="comment">// (如果超过b位的部分都已经是0了，那么这步可以跳过)</span></span><br><span class="line">r = (x ^ m) - m;</span><br></pre></td></tr></table></figure><p>这段代码需要四次操作，但当位长是常量时，假设高位部分都已经清零了，那么这个技巧只需要两次操作。</p><p>还有一个更快但是略微损失移植性的方法，这个方法不需要假设位长度超过b的部分，即高位部分，都已经被清零：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> m = CHAR_BIT * <span class="keyword">sizeof</span>(x) - b;</span><br><span class="line">r = (x &lt;&lt; m) &gt;&gt; m;</span><br></pre></td></tr></table></figure><p>2004年6月13日，Sean A. Irvine建议我将符号扩展的方法添加进这个页面。同时他提供了这段代码<code>m = (1 &lt;&lt; (b - 1)) - 1; r = -(x &amp; ~m) | x</code>。后来我在这份代码的基础上，优化出了<code>m = 1U &lt;&lt; (b - 1); r = -(x &amp; m) | x</code>这个版本。</p><p>但是在2007年5月11日，Shay Green提出了上面的这个比我少一个操作的版本。</p><p>2008年10月15日，Vipin Sharma 建议我考虑增加一个步骤来解决如果x在除了b位长之外的二进制部分还存在1的情况。</p><p>2009年12月31日，Chris Pirazzi建议我增加目前最快的版本，这个版本对于固定位长的符号扩展，只需要2次操作；对于变长的，也只需要3次操作。</p><h4>使用3次运算的符号扩展(可变位长)</h4><p>这个技巧由于乘法和除法的关系，在某些机器上可能会慢一些。这个版本准确来说需要4次运算。如果你知道你的初始位长大于1的话，那么你就可以用<code>r = (x * multipliers[b]) / multipliers[b]</code>这种方法来完成符号扩展。这个技巧是基于一个事先初始化的表，它只需要3次操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> b; <span class="comment">// number of bits representing the number in x</span></span><br><span class="line">            <span class="comment">// 变量b指定需要扩展的位长</span></span><br><span class="line"><span class="type">int</span> x;      <span class="comment">// sign extend this b-bit number to r</span></span><br><span class="line">            <span class="comment">// 需要将变量x中的数值符号扩展的结果保存到r中</span></span><br><span class="line"><span class="type">int</span> r;      <span class="comment">// resulting sign-extended number</span></span><br><span class="line">            <span class="comment">// 存放计算结果到变量r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M(B) (1U &lt;&lt; ((sizeof(x) * CHAR_BIT) - B)) <span class="comment">// CHAR_BIT=bits/byte</span></span></span><br><span class="line">                                                  <span class="comment">// CHAR_BIT是指一个字节中有多少位</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="type">const</span> multipliers[] =</span><br><span class="line">{</span><br><span class="line">  <span class="number">0</span>,     M(<span class="number">1</span>),  M(<span class="number">2</span>),  M(<span class="number">3</span>),  M(<span class="number">4</span>),  M(<span class="number">5</span>),  M(<span class="number">6</span>),  M(<span class="number">7</span>),</span><br><span class="line">  M(<span class="number">8</span>),  M(<span class="number">9</span>),  M(<span class="number">10</span>), M(<span class="number">11</span>), M(<span class="number">12</span>), M(<span class="number">13</span>), M(<span class="number">14</span>), M(<span class="number">15</span>),</span><br><span class="line">  M(<span class="number">16</span>), M(<span class="number">17</span>), M(<span class="number">18</span>), M(<span class="number">19</span>), M(<span class="number">20</span>), M(<span class="number">21</span>), M(<span class="number">22</span>), M(<span class="number">23</span>),</span><br><span class="line">  M(<span class="number">24</span>), M(<span class="number">25</span>), M(<span class="number">26</span>), M(<span class="number">27</span>), M(<span class="number">28</span>), M(<span class="number">29</span>), M(<span class="number">30</span>), M(<span class="number">31</span>),</span><br><span class="line">  M(<span class="number">32</span>)</span><br><span class="line">}; <span class="comment">// (add more if using more than 64 bits)</span></span><br><span class="line">   <span class="comment">// (如果需要支持到64位的话，可以继续添加)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="type">const</span> divisors[] =</span><br><span class="line">{</span><br><span class="line">  <span class="number">1</span>,    ~M(<span class="number">1</span>),  M(<span class="number">2</span>),  M(<span class="number">3</span>),  M(<span class="number">4</span>),  M(<span class="number">5</span>),  M(<span class="number">6</span>),  M(<span class="number">7</span>),</span><br><span class="line">  M(<span class="number">8</span>),  M(<span class="number">9</span>),  M(<span class="number">10</span>), M(<span class="number">11</span>), M(<span class="number">12</span>), M(<span class="number">13</span>), M(<span class="number">14</span>), M(<span class="number">15</span>),</span><br><span class="line">  M(<span class="number">16</span>), M(<span class="number">17</span>), M(<span class="number">18</span>), M(<span class="number">19</span>), M(<span class="number">20</span>), M(<span class="number">21</span>), M(<span class="number">22</span>), M(<span class="number">23</span>),</span><br><span class="line">  M(<span class="number">24</span>), M(<span class="number">25</span>), M(<span class="number">26</span>), M(<span class="number">27</span>), M(<span class="number">28</span>), M(<span class="number">29</span>), M(<span class="number">30</span>), M(<span class="number">31</span>),</span><br><span class="line">  M(<span class="number">32</span>)</span><br><span class="line">}; <span class="comment">// (add more for 64 bits)</span></span><br><span class="line">   <span class="comment">// (继续添加以支持64位)</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> M</span></span><br><span class="line">r = (x * multipliers[b]) / divisors[b];</span><br></pre></td></tr></table></figure><p>下面这个变种可能兼容性不高，但在某些支持算术右移架构，可以保持符号位的系统上，这个变种会更快一些。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> s = -b; <span class="comment">// OR:  sizeof(x) * CHAR_BIT - b;</span></span><br><span class="line">                  <span class="comment">// 或者：sizeof(x) * CHAR_BIT - b;</span></span><br><span class="line">r = (x &lt;&lt; s) &gt;&gt; s;</span><br></pre></td></tr></table></figure><p>2005年3月3日，Randal E.Bryant指出了一个最初版本的bug(即使用查表的版本)，当x和b都为1时，这个技巧就会失效。</p><h3>带条件判断的设置位或清除位（不使用分支指令）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> f;         <span class="comment">// conditional flag</span></span><br><span class="line">                <span class="comment">// 使用这个标志来表示条件判断</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> m; <span class="comment">// the bit mask</span></span><br><span class="line">                <span class="comment">// 位掩码</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> w; <span class="comment">// the word to modify:  if (f) w |= m; else w &amp;= ~m;</span></span><br><span class="line">                <span class="comment">// 需要进行操作的变量</span></span><br><span class="line"></span><br><span class="line">w ^= (-f ^ w) &amp; m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OR, for superscalar CPUs:</span></span><br><span class="line"><span class="comment">// 在一些超标量架构的CPU上，也可以这样:</span></span><br><span class="line">w = (w &amp; ~m) | (-f &amp; m);</span><br></pre></td></tr></table></figure><p>在某些架构上，不使用分支指令会比使用分支指令多出2个甚至更多的操作。举个例子，通过非正式速度测试表明，AMD Athlon™ XP 2100+能快5-10%； Intel Core 2 Duo的超标量版本能比能比前一个快16%。<br>2003年12月11日，Gelnn Slayden告诉了我第一个算法。<br>2007年4月3日，Marco Yu给我分享了超标量版本的算法，在两天后给我提出了一处显示排版错误。</p><h3>带条件判断的将变量置为相反数（不使用分支指令）</h3><p>在不使用分支指令的情况下，你可能会需要判断某个flag是否false，来将某个变量置为其相反数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> fDontNegate;  <span class="comment">// Flag indicating we should not negate v.</span></span><br><span class="line">                   <span class="comment">// Flag标志，用于判断我们是否需要将变量v置为相反数</span></span><br><span class="line"><span class="type">int</span> v;             <span class="comment">// Input value to negate if fDontNegate is false.</span></span><br><span class="line">                   <span class="comment">// 输入的数值保存在v中，当fDontNegate为false时，就将变量v置为相反数</span></span><br><span class="line"><span class="type">int</span> r;             <span class="comment">// result = fDontNegate ? v : -v;</span></span><br><span class="line"></span><br><span class="line">r = (fDontNegate ^ (fDontNegate - <span class="number">1</span>)) * v;</span><br></pre></td></tr></table></figure><p>如果flag为true才将变量置为相反，那么可以用这个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> fNegate;  <span class="comment">// Flag indicating if we should negate v.</span></span><br><span class="line">               <span class="comment">// Flag标志，用于判断我们是否需要将变量v置为相反数</span></span><br><span class="line"><span class="type">int</span> v;         <span class="comment">// Input value to negate if fNegate is true.</span></span><br><span class="line">               <span class="comment">// 输入的数值保存在v中，当fDontNegate为true时，就将变量v置为相反数</span></span><br><span class="line"><span class="type">int</span> r;         <span class="comment">// result = fNegate ? -v : v;</span></span><br><span class="line"></span><br><span class="line">r = (v ^ -fNegate) + fNegate;</span><br></pre></td></tr></table></figure><p>2009年6月2日，Avraham Plotnitzky建议我添加第一个版本。</p><p>2009年6月8日，为了去除掉乘法，我想出了第二个版本。</p><p>2009年11月26日，Alfonso De Gregorio指出某个地方缺少括号。这是一个合理的bug，所以它得到了指出bug的赏金。</p><h3>根据掩码对两个数值进行位合并</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a;    <span class="comment">// value to merge in non-masked bits</span></span><br><span class="line">                   <span class="comment">// 将变量a中没被掩码覆盖的位保留下来</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b;    <span class="comment">// value to merge in masked bits</span></span><br><span class="line">                   <span class="comment">// 将变量b中被掩码覆盖的位保留下来</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mask; <span class="comment">// 1 where bits from b should be selected; 0 where from a.</span></span><br><span class="line">                   <span class="comment">// 如果某一位是1，那么结果中对应的位就保存b所对应位置的值；如果是0，则保存a所对应位置的值。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r;    <span class="comment">// result of (a &amp; ~mask) | (b &amp; mask) goes here</span></span><br><span class="line">                   <span class="comment">// 这里保存(a &amp; ~mask) | (b &amp; mask)的结果</span></span><br><span class="line"></span><br><span class="line">r = a ^ ((a ^ b) &amp; mask);</span><br></pre></td></tr></table></figure><p>这个算法比这种简单的实现`(a &amp; ~mask) | (b &amp; mask)节省一次操作。然而如果掩码是一个常量，那么这两种算法实际上都差不多。</p><p>2006年2月9日，Ron Jeffery将这个算法发给我了。</p><h3>统计二进制位</h3><h4>统计二进制位中1的个数(普通实现)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v; <span class="comment">// count the number of bits set in v</span></span><br><span class="line">                <span class="comment">// 计算变量v的二进制中1的个数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> c; <span class="comment">// c accumulates the total bits set in v</span></span><br><span class="line">                <span class="comment">// 保存计算的结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">0</span>; v; v &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">  c += v &amp; <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这个简单算法对于每一位都需要一次操作，直到结束。所以对于32位字长，且只有最高位为1时（即最坏情况），这个算法会操作32次。</p><h4>统计二进制位中1的个数(查表法)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> BitsSetTable256[<span class="number">256</span>] =</span><br><span class="line">{</span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> B2(n) n,     n+1,     n+1,     n+2</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> B4(n) B2(n), B2(n+1), B2(n+1), B2(n+2)</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> B6(n) B4(n), B4(n+1), B4(n+1), B4(n+2)</span></span><br><span class="line">    B6(<span class="number">0</span>), B6(<span class="number">1</span>), B6(<span class="number">1</span>), B6(<span class="number">2</span>)</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v; <span class="comment">// count the number of bits set in v</span></span><br><span class="line">                <span class="comment">// 计算变量v的二进制中1的个数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> c; <span class="comment">// c accumulates the total bits set in v</span></span><br><span class="line">                <span class="comment">// 保存计算的结果</span></span><br><span class="line"><span class="comment">// Option 1:</span></span><br><span class="line"><span class="comment">// 第一种：</span></span><br><span class="line">c = BitsSetTable256[v &amp; <span class="number">0xff</span>] +</span><br><span class="line">    BitsSetTable256[(v &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>] +</span><br><span class="line">    BitsSetTable256[(v &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>] +</span><br><span class="line">    BitsSetTable256[v &gt;&gt; <span class="number">24</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 2:</span></span><br><span class="line"><span class="comment">// 第二种：</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> * p = (<span class="type">unsigned</span> <span class="type">char</span> *) &amp;v;</span><br><span class="line">c = BitsSetTable256[p[<span class="number">0</span>]] +</span><br><span class="line">    BitsSetTable256[p[<span class="number">1</span>]] +</span><br><span class="line">    BitsSetTable256[p[<span class="number">2</span>]] +</span><br><span class="line">    BitsSetTable256[p[<span class="number">3</span>]];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// To initially generate the table algorithmically:</span></span><br><span class="line"><span class="comment">// 使用算法来预处理表的内容</span></span><br><span class="line">BitsSetTable256[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">{</span><br><span class="line">  BitsSetTable256[i] = (i &amp; <span class="number">1</span>) + BitsSetTable256[i / <span class="number">2</span>];</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>2009年7月14日，Hallvard Furuseth提出了宏压缩版本的预处理表的方法。</p><h4>统计二进制位中1的个数(Brian Kernighan方法)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v; <span class="comment">// count the number of bits set in v</span></span><br><span class="line">                <span class="comment">// 计算变量v的二进制中1的个数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> c; <span class="comment">// c accumulates the total bits set in v</span></span><br><span class="line">                <span class="comment">// 保存计算的结果</span></span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">0</span>; v; c++)</span><br><span class="line">{</span><br><span class="line">  v &amp;= v - <span class="number">1</span>; <span class="comment">// clear the least significant bit set</span></span><br><span class="line">              <span class="comment">// 清除掉从最低位到最高位数的第一个为1的位</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>Brian Kernighan的方法运算次数取决于二进制位中1的个数。所以如果一个32位字长的数，只有最高位是1，那么这个算法只会执行1次。</p><p>1988年，发布于《C程序设计语言》（第二版），作者Brian W. Kernighan和Dennis M. Ritchie。在此书的练习2-9中提到了这个算法。</p><p>2006年4月19日，Don Knuth向我指出这个算法，“是被Peter Wegner首先在CACM 3 (1960), 322发表的”。（同时也被Derrick Lehmer独立发现，并且在1964年由Beckenbach编辑发表在一本书上）</p><h4>统计14位字长，24位字长，32位字长的二进制位中1的个数(64位架构下)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v; <span class="comment">// count the number of bits set in v</span></span><br><span class="line">                <span class="comment">// 计算变量v的二进制中1的个数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> c; <span class="comment">// c accumulates the total bits set in v</span></span><br><span class="line">                <span class="comment">// 保存计算的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// option 1, for at most 14-bit values in v:</span></span><br><span class="line"><span class="comment">// 第一种情况，只计算统计变量v中的14位</span></span><br><span class="line">c = (v * <span class="number">0x200040008001</span>ULL &amp; <span class="number">0x111111111111111</span>ULL) % <span class="number">0xf</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// option 2, for at most 24-bit values in v:</span></span><br><span class="line"><span class="comment">// 第二种情况，只计算统计变量v中的24位</span></span><br><span class="line">c =  ((v &amp; <span class="number">0xfff</span>) * <span class="number">0x1001001001001</span>ULL &amp; <span class="number">0x84210842108421</span>ULL) % <span class="number">0x1f</span>;</span><br><span class="line">c += (((v &amp; <span class="number">0xfff000</span>) &gt;&gt; <span class="number">12</span>) * <span class="number">0x1001001001001</span>ULL &amp; <span class="number">0x84210842108421</span>ULL)</span><br><span class="line">     % <span class="number">0x1f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// option 3, for at most 32-bit values in v:</span></span><br><span class="line"><span class="comment">// 第三种情况，只计算统计变量v中的32位</span></span><br><span class="line">c =  ((v &amp; <span class="number">0xfff</span>) * <span class="number">0x1001001001001</span>ULL &amp; <span class="number">0x84210842108421</span>ULL) % <span class="number">0x1f</span>;</span><br><span class="line">c += (((v &amp; <span class="number">0xfff000</span>) &gt;&gt; <span class="number">12</span>) * <span class="number">0x1001001001001</span>ULL &amp; <span class="number">0x84210842108421</span>ULL) %</span><br><span class="line">     <span class="number">0x1f</span>;</span><br><span class="line">c += ((v &gt;&gt; <span class="number">24</span>) * <span class="number">0x1001001001001</span>ULL &amp; <span class="number">0x84210842108421</span>ULL) % <span class="number">0x1f</span>;</span><br></pre></td></tr></table></figure><p>这个算法需要在支持快速模除的64位CPU上才能达到高性能的效果。第一种情况只需要3次操作，第二种需要10次，第三种需要15次。</p><p>Rich Schroeppel最初想出了一个和第一种类似的9位长版本，见Programming Hacks的这一章节<a target="_blank" rel="noopener" href="http://www.inwap.com/pdp10/hbaker/hakmem/hakmem.html">Beeler, M., Gosper, R. W., and Schroeppel, R. HAKMEM. MIT AI Memo 239, Feb. 29, 1972</a>。他的想法是收此启发，并最终由Sean Anderson完成设计。</p><p>2005年5月3日，Randal E.Byrant提了几个bug修复补丁。</p><p>2007年2月1日，Bruce Dawson对原来的12位版本做了一些调整，将其变成了兼容性更好的14位版本，并且保持操作数不变。</p><h4>统计二进制位中1的个数(并行计算的方法)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v; <span class="comment">// count the number of bits set in v</span></span><br><span class="line">                <span class="comment">// 计算变量v的二进制中1的个数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> c; <span class="comment">// c accumulates the total bits set in v</span></span><br><span class="line">                <span class="comment">// 保存计算的结果</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> S[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>}; <span class="comment">// Magic Binary Numbers</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> B[] = {<span class="number">0x55555555</span>, <span class="number">0x33333333</span>, <span class="number">0x0F0F0F0F</span>, <span class="number">0x00FF00FF</span>, <span class="number">0x0000FFFF</span>};</span><br><span class="line"></span><br><span class="line">c = v - ((v &gt;&gt; <span class="number">1</span>) &amp; B[<span class="number">0</span>]);</span><br><span class="line">c = ((c &gt;&gt; S[<span class="number">1</span>]) &amp; B[<span class="number">1</span>]) + (c &amp; B[<span class="number">1</span>]);</span><br><span class="line">c = ((c &gt;&gt; S[<span class="number">2</span>]) + c) &amp; B[<span class="number">2</span>];</span><br><span class="line">c = ((c &gt;&gt; S[<span class="number">3</span>]) + c) &amp; B[<span class="number">3</span>];</span><br><span class="line">c = ((c &gt;&gt; S[<span class="number">4</span>]) + c) &amp; B[<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>B数组，以及其二进制的形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B[<span class="number">0</span>] = <span class="number">0x55555555</span> = <span class="number">01010101</span> <span class="number">01010101</span> <span class="number">01010101</span> <span class="number">01010101</span></span><br><span class="line">B[<span class="number">1</span>] = <span class="number">0x33333333</span> = <span class="number">00110011</span> <span class="number">00110011</span> <span class="number">00110011</span> <span class="number">00110011</span></span><br><span class="line">B[<span class="number">2</span>] = <span class="number">0x0F0F0F0F</span> = <span class="number">00001111</span> <span class="number">00001111</span> <span class="number">00001111</span> <span class="number">00001111</span></span><br><span class="line">B[<span class="number">3</span>] = <span class="number">0x00FF00FF</span> = <span class="number">00000000</span> <span class="number">11111111</span> <span class="number">00000000</span> <span class="number">11111111</span></span><br><span class="line">B[<span class="number">4</span>] = <span class="number">0x0000FFFF</span> = <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">11111111</span> <span class="number">11111111</span></span><br></pre></td></tr></table></figure><p>通过添加两个幻数数组B和S，就能够扩展这个方法，以适应位长更多的整数类型。如果有k位的话，那么我们只需要把数组S和B扩展到ceil(lg(k))个元素就好，同时添加对应数量的计算c的表达式。对于32位长度的v来说，一共需要16次操作。</p><p>然而对于计算32位整型数来说，最好的计算方法下面这种：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v = v - ((v &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);                    <span class="comment">// reuse input as temporary</span></span><br><span class="line">                                                    <span class="comment">// 将输入变量作为临时变量重复使用</span></span><br><span class="line">v = (v &amp; <span class="number">0x33333333</span>) + ((v &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);     <span class="comment">// temp</span></span><br><span class="line">                                                    <span class="comment">// 临时变量</span></span><br><span class="line">c = ((v + (v &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xF0F0F0F</span>) * <span class="number">0x1010101</span>) &gt;&gt; <span class="number">24</span>; <span class="comment">// count</span></span><br><span class="line">                                                    <span class="comment">// 计算结果</span></span><br></pre></td></tr></table></figure><p>这种计算方法只需要12次操作，虽然和上面查表的方法差不多，但是却能够节省了内存和避免了潜在的缓存未命中而导致的额外操作。这是在并行计算方法和之前使用乘法的那种方法（在64位架构下，二进制位中1的个数那一小节中）之间的结合，然而这个方法却不需要64位架构的指令。每个比特中的1统计可以并行的计算，最终的结果计算是通过乘以0x1010101后右移24位来得出的。</p><p>这个方法还有一个推广，可以计算长度多达128位的整型数(128位整型的数据类型使用T来代替)，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v = v - ((v &gt;&gt; <span class="number">1</span>) &amp; (T)~(T)<span class="number">0</span>/<span class="number">3</span>);                           <span class="comment">// temp</span></span><br><span class="line">v = (v &amp; (T)~(T)<span class="number">0</span>/<span class="number">15</span>*<span class="number">3</span>) + ((v &gt;&gt; <span class="number">2</span>) &amp; (T)~(T)<span class="number">0</span>/<span class="number">15</span>*<span class="number">3</span>);      <span class="comment">// temp</span></span><br><span class="line">v = (v + (v &gt;&gt; <span class="number">4</span>)) &amp; (T)~(T)<span class="number">0</span>/<span class="number">255</span>*<span class="number">15</span>;                      <span class="comment">// temp</span></span><br><span class="line">c = (T)(v * ((T)~(T)<span class="number">0</span>/<span class="number">255</span>)) &gt;&gt; (<span class="keyword">sizeof</span>(T) - <span class="number">1</span>) * CHAR_BIT; <span class="comment">// count</span></span><br></pre></td></tr></table></figure><p>在<a target="_blank" rel="noopener" href="http://groups.google.com/groups?q=reverse+bits&amp;num=100&amp;hl=en&amp;group=comp.graphics.algorithms&amp;imgsafe=off&amp;safe=off&amp;rnum=2&amp;ic=1&amp;selm=4fulhm$8dn@atlas.uniserve.com">Ian Ashdown’s nice newsgroup post</a>还可以看到更多关于计算二进制位中1个数（也被人称为sideways addition）的相关信息。</p><p>2005年12月14日，Charlie Gordon提出了一种方法，可以让纯平行计算的版本减少一次操作。2005年12月30日，Don Clugston在此之上又优化掉了3次操作。</p><p>2006年1月8日，Eric Cole指出了我在按照Don的建议修改本文时留下的一处显示错误。</p><p>2006年11月17日，Eric提出了最好计算方法的可变位长推广方案。</p><p>2007年4月5日，Al Williams发现我在第一个方法中留下了一行无用的代码。</p><h4>统计从最高位到指定的某位之间的二进制位1的个数</h4><p>这个方法是用来计算某一位的rank，意思是统计从最高位到指定的某位之间二进制位1的个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> v; <span class="comment">// Compute the rank (bits set) in v from the MSB（最高位） to pos.</span></span><br><span class="line">            <span class="comment">// 计算v中从第pos位到最高位的rank(二进制位1的个数)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> pos; <span class="comment">// Bit position to count bits upto.</span></span><br><span class="line">                  <span class="comment">// 指定某一位，向最高位统计</span></span><br><span class="line"><span class="type">uint64_t</span> r; <span class="comment">// Resulting rank of bit at pos goes here.</span></span><br><span class="line">            <span class="comment">// 保存统计的结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Shift out bits after given position.</span></span><br><span class="line"><span class="comment">// 将其余的位右移出去</span></span><br><span class="line">r = v &gt;&gt; (<span class="keyword">sizeof</span>(v) * CHAR_BIT - pos);</span><br><span class="line"><span class="comment">// Count set bits in parallel.</span></span><br><span class="line"><span class="comment">// 并行地统计1的个数</span></span><br><span class="line"><span class="comment">// r = (r &amp; 0x5555...) + ((r &gt;&gt; 1) &amp; 0x5555...);</span></span><br><span class="line">r = r - ((r &gt;&gt; <span class="number">1</span>) &amp; ~<span class="number">0UL</span>/<span class="number">3</span>);</span><br><span class="line"><span class="comment">// r = (r &amp; 0x3333...) + ((r &gt;&gt; 2) &amp; 0x3333...);</span></span><br><span class="line">r = (r &amp; ~<span class="number">0UL</span>/<span class="number">5</span>) + ((r &gt;&gt; <span class="number">2</span>) &amp; ~<span class="number">0UL</span>/<span class="number">5</span>);</span><br><span class="line"><span class="comment">// r = (r &amp; 0x0f0f...) + ((r &gt;&gt; 4) &amp; 0x0f0f...);</span></span><br><span class="line">r = (r + (r &gt;&gt; <span class="number">4</span>)) &amp; ~<span class="number">0UL</span>/<span class="number">17</span>;</span><br><span class="line"><span class="comment">// r = r % 255;</span></span><br><span class="line">r = (r * (~<span class="number">0UL</span>/<span class="number">255</span>)) &gt;&gt; ((<span class="keyword">sizeof</span>(v) - <span class="number">1</span>) * CHAR_BIT);</span><br></pre></td></tr></table></figure><p>2009年11月21日，Juha Järvi将这个算法发给了我，这个算法是下一个算法（给定从某位到最高位1的个数，推算出该位的位置）的逆运算。</p><h4>给定从某位到最高位1的个数，推算该位的位置</h4><p>接下来这份64位的代码可以选取出从左到右第r个二进制1的位置。也就是说，如果我们从最高位往右，统计二进制位为1的个数，直到达到了预期的rank（译者：解释见上一条），那么我们停下的位置就是答案。如果超出了最低位还没有算出结果，那么会返回64。这段代码可以改编出32位版本，也可以从最右边开始统计。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Do a normal parallel bit count for a 64-bit integer,</span></span><br><span class="line"><span class="comment">// 并行地统计出二进制1的个数</span></span><br><span class="line"> <span class="comment">// but store all intermediate steps.</span></span><br><span class="line"> <span class="comment">// 保存所有的中间结果</span></span><br><span class="line"> <span class="comment">// a = (v &amp; 0x5555...) + ((v &gt;&gt; 1) &amp; 0x5555...);</span></span><br><span class="line"> a =  v - ((v &gt;&gt; <span class="number">1</span>) &amp; ~<span class="number">0UL</span>/<span class="number">3</span>);</span><br><span class="line"> <span class="comment">// b = (a &amp; 0x3333...) + ((a &gt;&gt; 2) &amp; 0x3333...);</span></span><br><span class="line"> b = (a &amp; ~<span class="number">0UL</span>/<span class="number">5</span>) + ((a &gt;&gt; <span class="number">2</span>) &amp; ~<span class="number">0UL</span>/<span class="number">5</span>);</span><br><span class="line"> <span class="comment">// c = (b &amp; 0x0f0f...) + ((b &gt;&gt; 4) &amp; 0x0f0f...);</span></span><br><span class="line"> c = (b + (b &gt;&gt; <span class="number">4</span>)) &amp; ~<span class="number">0UL</span>/<span class="number">0x11</span>;</span><br><span class="line"> <span class="comment">// d = (c &amp; 0x00ff...) + ((c &gt;&gt; 8) &amp; 0x00ff...);</span></span><br><span class="line"> d = (c + (c &gt;&gt; <span class="number">8</span>)) &amp; ~<span class="number">0UL</span>/<span class="number">0x101</span>;</span><br><span class="line"> t = (d &gt;&gt; <span class="number">32</span>) + (d &gt;&gt; <span class="number">48</span>);</span><br><span class="line"> <span class="comment">// Now do branchless select!</span></span><br><span class="line"> <span class="comment">// 这里进行无分支指令的条件选取</span></span><br><span class="line"> s  = <span class="number">64</span>;</span><br><span class="line"> <span class="comment">// if (r &gt; t) {s -= 32; r -= t;}</span></span><br><span class="line"> s -= ((t - r) &amp; <span class="number">256</span>) &gt;&gt; <span class="number">3</span>; r -= (t &amp; ((t - r) &gt;&gt; <span class="number">8</span>));</span><br><span class="line"> t  = (d &gt;&gt; (s - <span class="number">16</span>)) &amp; <span class="number">0xff</span>;</span><br><span class="line"> <span class="comment">// if (r &gt; t) {s -= 16; r -= t;}</span></span><br><span class="line"> s -= ((t - r) &amp; <span class="number">256</span>) &gt;&gt; <span class="number">4</span>; r -= (t &amp; ((t - r) &gt;&gt; <span class="number">8</span>));</span><br><span class="line"> t  = (c &gt;&gt; (s - <span class="number">8</span>)) &amp; <span class="number">0xf</span>;</span><br><span class="line"> <span class="comment">// if (r &gt; t) {s -= 8; r -= t;}</span></span><br><span class="line"> s -= ((t - r) &amp; <span class="number">256</span>) &gt;&gt; <span class="number">5</span>; r -= (t &amp; ((t - r) &gt;&gt; <span class="number">8</span>));</span><br><span class="line"> t  = (b &gt;&gt; (s - <span class="number">4</span>)) &amp; <span class="number">0x7</span>;</span><br><span class="line"> <span class="comment">// if (r &gt; t) {s -= 4; r -= t;}</span></span><br><span class="line"> s -= ((t - r) &amp; <span class="number">256</span>) &gt;&gt; <span class="number">6</span>; r -= (t &amp; ((t - r) &gt;&gt; <span class="number">8</span>));</span><br><span class="line"> t  = (a &gt;&gt; (s - <span class="number">2</span>)) &amp; <span class="number">0x3</span>;</span><br><span class="line"> <span class="comment">// if (r &gt; t) {s -= 2; r -= t;}</span></span><br><span class="line"> s -= ((t - r) &amp; <span class="number">256</span>) &gt;&gt; <span class="number">7</span>; r -= (t &amp; ((t - r) &gt;&gt; <span class="number">8</span>));</span><br><span class="line"> t  = (v &gt;&gt; (s - <span class="number">1</span>)) &amp; <span class="number">0x1</span>;</span><br><span class="line"> <span class="comment">// if (r &gt; t) s--;</span></span><br><span class="line"> s -= ((t - r) &amp; <span class="number">256</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line"> s = <span class="number">65</span> - s;</span><br></pre></td></tr></table></figure><p>如果在你的CPU上分支指令速度足够快，可以考虑将使用被注释掉的那些if语句，将对应的其它语句注释掉。</p><p>2009年11月21日，Juha Järvi将这个发给了我。</p><h3>计算奇偶校验位(给定位数的二进制数中1的个数是奇数还是偶数)</h3><h4>计算奇偶校验位（普通实现）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v;       <span class="comment">// word value to compute the parity of</span></span><br><span class="line">                      <span class="comment">// 需要计算的值保存在变量v中</span></span><br><span class="line"><span class="type">bool</span> parity = <span class="literal">false</span>;  <span class="comment">// parity will be the parity of v</span></span><br><span class="line">                      <span class="comment">// 变量parity保存v的奇偶校验位</span></span><br><span class="line"><span class="keyword">while</span> (v)</span><br><span class="line">{</span><br><span class="line">  parity = !parity;</span><br><span class="line">  v = v &amp; (v - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上面这段代码实现使用了类似Brian Kernigan的统计二进制位中1个数的方法。二进制中有多少个1，这个算法就会计算多少次。</p><h4>计算奇偶校验位（查表法）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">bool</span> ParityTable256[<span class="number">256</span>] =</span><br><span class="line">{</span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> P2(n) n, n^1, n^1, n</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> P4(n) P2(n), P2(n^1), P2(n^1), P2(n)</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> P6(n) P4(n), P4(n^1), P4(n^1), P4(n)</span></span><br><span class="line">    P6(<span class="number">0</span>), P6(<span class="number">1</span>), P6(<span class="number">1</span>), P6(<span class="number">0</span>)</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> b;  <span class="comment">// byte value to compute the parity of</span></span><br><span class="line">                  <span class="comment">// 需要计算的值保存在变量b中</span></span><br><span class="line"><span class="type">bool</span> parity = ParityTable256[b];</span><br><span class="line"></span><br><span class="line"><span class="comment">// OR, for 32-bit words:</span></span><br><span class="line"><span class="comment">// 或者，32位字长下</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v;</span><br><span class="line">v ^= v &gt;&gt; <span class="number">16</span>;</span><br><span class="line">v ^= v &gt;&gt; <span class="number">8</span>;</span><br><span class="line"><span class="type">bool</span> parity = ParityTable256[v &amp; <span class="number">0xff</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Variation:</span></span><br><span class="line"><span class="comment">// 变种</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> * p = (<span class="type">unsigned</span> <span class="type">char</span> *) &amp;v;</span><br><span class="line">parity = ParityTable256[p[<span class="number">0</span>] ^ p[<span class="number">1</span>] ^ p[<span class="number">2</span>] ^ p[<span class="number">3</span>]];</span><br></pre></td></tr></table></figure><p>2005年5月3日，Randal E.Bryant提出了使用变量p的那个变种版本。</p><p>2005年9月27日，Bruce Rawles发现了表中有一处变量名拼写错误，并获得了10美刀的奖励。</p><p>2006年10月9日，Fabrice Bellard提出了32位字长的变种，这个变种只需要查表一次；最初的版本需要4次查表（每个字节一次），明显更慢一些。</p><p>2009年7月14日，Hallvard Furuseth提出用宏来精简表的长度。</p><h4>计算单个字节的奇偶校验位（使用64位的乘法和模除）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> b;  <span class="comment">// byte value to compute the parity of</span></span><br><span class="line">                  <span class="comment">// 需要计算的值保存在变量b中</span></span><br><span class="line"><span class="type">bool</span> parity =</span><br><span class="line">  (((b * <span class="number">0x0101010101010101</span>ULL) &amp; <span class="number">0x8040201008040201</span>ULL) % <span class="number">0x1FF</span>) &amp; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这个方法只需要4次操作，然而只能计算单个字节。</p><h4>计算单个字的奇偶校验位（使用乘法）</h4><p>这个方法计算32位字长的值在使用乘法的情况下，只需要8次操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v; <span class="comment">// 32-bit word</span></span><br><span class="line">                <span class="comment">// 32位长度的字</span></span><br><span class="line">v ^= v &gt;&gt; <span class="number">1</span>;</span><br><span class="line">v ^= v &gt;&gt; <span class="number">2</span>;</span><br><span class="line">v = (v &amp; <span class="number">0x11111111</span>U) * <span class="number">0x11111111</span>U;</span><br><span class="line"><span class="keyword">return</span> (v &gt;&gt; <span class="number">28</span>) &amp; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>对于64位，仍只需要8次操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> v; <span class="comment">// 64-bit word</span></span><br><span class="line">                      <span class="comment">// 64位长度的字</span></span><br><span class="line"></span><br><span class="line">v ^= v &gt;&gt; <span class="number">1</span>;</span><br><span class="line">v ^= v &gt;&gt; <span class="number">2</span>;</span><br><span class="line">v = (v &amp; <span class="number">0x1111111111111111</span>UL) * <span class="number">0x1111111111111111</span>UL;</span><br><span class="line"><span class="keyword">return</span> (v &gt;&gt; <span class="number">60</span>) &amp; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>2007年9月2日，Andrew Shapira想出的这个算法，并发给了我。</p><h4>计算奇偶校验位（并行计算）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v;  <span class="comment">// word value to compute the parity of</span></span><br><span class="line">                 <span class="comment">// 需要计算奇偶校验位的字长度的值</span></span><br><span class="line">v ^= v &gt;&gt; <span class="number">16</span>;</span><br><span class="line">v ^= v &gt;&gt; <span class="number">8</span>;</span><br><span class="line">v ^= v &gt;&gt; <span class="number">4</span>;</span><br><span class="line">v &amp;= <span class="number">0xf</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0x6996</span> &gt;&gt; v) &amp; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这个方法需要9次运算，可以工作在32位字长的环境下。如果是只需要对字节进行计算，那么可以把“unsigned int v;”的下两行去掉，这样可以把操作数优化到5次。这个方法先是将这个32位值的分成8个半字节，通过右移和异或将v压缩到v的最低的半字节中。然后将二进制位0110 1001 1001 0110(十六位表示为0x6996)的数值右移，右移的位数是刚刚计算出来的v的最低半字节的值。这个幻数就像是一个16位的小型奇偶校验位的表，通过v的最低半字节的值可以查到v的奇偶校验位。最终结果存放在最低位中，代码最后通过掩码的方式计算出了结果并返回。</p><p>2002年12月15日，感谢Mathew Hendry提出了右移查表的想法。相比只使用右移和异或的方法，这个优化可以减少掉节省两次操作。</p><h3>数值交换</h3><h4>交换数值（使用加法和减法）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SWAP(a, b) ((&amp;(a) == &amp;(b)) || \</span></span><br><span class="line"><span class="meta">                    (((a) -= (b)), ((b) += (a)), ((a) = (b) - (a))))</span></span><br></pre></td></tr></table></figure><p>这个交换的方法不使用临时变量。一开始有一个检查变量a和变量b在内存中的位置是否相同，如果你能确保这种情况不会发生，那么这个检查可以去掉。（编译器可能也会把这个给优化掉）如果程序有溢出时抛异常的机制，那么传入无符号型的值就不会抛异常了。待会儿会介绍一个使用异或的方法，这个方法在某些机器上可能会稍微快一些。注意这个方法不能应用在浮点数的交换上（除非你就是想使用他们的整数形式）。</p><h4>交换数值（使用异或）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SWAP(a, b) (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b)))</span></span><br></pre></td></tr></table></figure><p>2005年1月20日，Iain A. Fleming指出如果我们交换的数值在内存中的地址相同，这个宏不会起作用，比如SWAP(a[i], a[j])，i == j。所以，如果那种情况可能发生，可以考虑增加一个判断，就像这样 (((a) == (b)) || (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b))))。</p><p>2009年7月14日，Hallvard Furuseth建议，在有些机器上可能这条语句会更快一点<code>(((a) ^ (b)) &amp;&amp; ((b) ^= (a) ^= (b), (a) ^= (b)))</code>，因为(a) ^ (b)这条表达式被再利用了（译者注：意思应该是省去了重复计算的步骤）。</p><h4>指定范围，交换数值的二进制位（使用异或）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i, j; <span class="comment">// positions of bit sequences to swap</span></span><br><span class="line">                   <span class="comment">// 指定交换的位置</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> n;    <span class="comment">// number of consecutive bits in each sequence</span></span><br><span class="line">                   <span class="comment">// 区间的长度</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b;    <span class="comment">// bits to swap reside in b</span></span><br><span class="line">                   <span class="comment">// 变量b中的二进制位需要交换</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r;    <span class="comment">// bit-swapped result goes here</span></span><br><span class="line">                   <span class="comment">// 变量r存放位交换后的结果</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> x = ((b &gt;&gt; i) ^ (b &gt;&gt; j)) &amp; ((<span class="number">1U</span> &lt;&lt; n) - <span class="number">1</span>); <span class="comment">// XOR temporary</span></span><br><span class="line">                                                          <span class="comment">// 异或操作的临时变量</span></span><br><span class="line">r = b ^ ((x &lt;&lt; i) | (x &lt;&lt; j));</span><br></pre></td></tr></table></figure><p>举一个 指定二进制位范围来交换数值 的例子，我们有b = 00101111（二进制形式），希望交换的位长度为n = 3，起始点是i = 1（从右往左数第2个位）的连续3个位，以及起点为j = 5的连续3个位；那么结果就会是r = 11100011(二进制)。</p><p>这个交换数值的技巧很像之前那个通用的异或交换的技巧，区别于这个技巧是用来操作特定的某些位。变量x中保存我们想要交换的两段二进制位值异或后的结果，然后用x与原来的值进行异或，便可以达到交换的效果。当然如果指定的范围溢出了的话，计算结果是未定义的。</p><p>2009年7月14日，Hallvard Furuseth建议我将1 &lt;&lt; n 改成 1U &lt;&lt; n，因为使用无符号整型可以防止移位操作覆盖掉了符号位。</p><h3>反转位序列</h3><h4>位的反转（朴素方法）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v;     <span class="comment">// input bits to be reversed</span></span><br><span class="line">                    <span class="comment">// 需要翻转的数值输入保存在这里</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r = v; <span class="comment">// r will be reversed bits of v; first get LSB of v</span></span><br><span class="line">                    <span class="comment">// 将v反转后的结果保存在变量r中；首先会算出v的最低有效位（注：推测此处的LSB是指Least Significant Bit，故翻译为最低有效位，不太确定）</span></span><br><span class="line"><span class="type">int</span> s = <span class="keyword">sizeof</span>(v) * CHAR_BIT - <span class="number">1</span>; <span class="comment">// extra shift needed at end</span></span><br><span class="line">                                  <span class="comment">// 最终需要额外左移的长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (v &gt;&gt;= <span class="number">1</span>; v; v &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">{</span><br><span class="line">  r &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  r |= v &amp; <span class="number">1</span>;</span><br><span class="line">  s--;</span><br><span class="line">}</span><br><span class="line">r &lt;&lt;= s; <span class="comment">// shift when v's highest bits are zero</span></span><br><span class="line">         <span class="comment">// v的高位可能存在0，所以这里需要左移</span></span><br></pre></td></tr></table></figure><p>2004年10月15日，Michael Hoisie指出了一个最初版本的bug。</p><p>2005年5月3日，Randal E. Bryant提议去除掉一处多余的操作。</p><p>2005年5月18日，Behdad Esfabod指出一个改动，可以让少循环一次。</p><p>2007年2月6日，Liyong Zhou给出了一个更好的版本，如果v不是0的话才进入循环，而不是循环遍历完所有位，这样可以早一些退出循环。</p><h4>位的反转（查表法）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> BitReverseTable256[<span class="number">256</span>] =</span><br><span class="line">{</span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> R2(n)     n,     n + 2*64,     n + 1*64,     n + 3*64</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> R4(n) R2(n), R2(n + 2*16), R2(n + 1*16), R2(n + 3*16)</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> R6(n) R4(n), R4(n + 2*4 ), R4(n + 1*4 ), R4(n + 3*4 )</span></span><br><span class="line">    R6(<span class="number">0</span>), R6(<span class="number">2</span>), R6(<span class="number">1</span>), R6(<span class="number">3</span>)</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v; <span class="comment">// reverse 32-bit value, 8 bits at time</span></span><br><span class="line">                <span class="comment">// 需要反转的32位值，每次反转8位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> c; <span class="comment">// c will get v reversed</span></span><br><span class="line">                <span class="comment">// 变量c结果保存v反转后的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 1:</span></span><br><span class="line">c = (BitReverseTable256[v &amp; <span class="number">0xff</span>] &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">    (BitReverseTable256[(v &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>] &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">    (BitReverseTable256[(v &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>] &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">    (BitReverseTable256[(v &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Option 2:</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> * p = (<span class="type">unsigned</span> <span class="type">char</span> *) &amp;v;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> * q = (<span class="type">unsigned</span> <span class="type">char</span> *) &amp;c;</span><br><span class="line">q[<span class="number">3</span>] = BitReverseTable256[p[<span class="number">0</span>]];</span><br><span class="line">q[<span class="number">2</span>] = BitReverseTable256[p[<span class="number">1</span>]];</span><br><span class="line">q[<span class="number">1</span>] = BitReverseTable256[p[<span class="number">2</span>]];</span><br><span class="line">q[<span class="number">0</span>] = BitReverseTable256[p[<span class="number">3</span>]];</span><br></pre></td></tr></table></figure><p>假定你的CPU可以轻松存取字节，那么第一个方法需要17次左右的操作，第二个需要12个。</p><p>2009年7月14日，Hallvard Furuseth提供了这个宏压缩的表。</p><h4>单字节的位反转（3次操作，需要64位乘和模）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> b; <span class="comment">// reverse this (8-bit) byte</span></span><br><span class="line">                 <span class="comment">// 反转这个（8位长）字节</span></span><br><span class="line"></span><br><span class="line">b = (b * <span class="number">0x0202020202</span>ULL &amp; <span class="number">0x010884422010</span>ULL) % <span class="number">1023</span>;</span><br></pre></td></tr></table></figure><p>乘法操作产生了5份8位长的串，保存在64位整数里。按位与操作选取出一些特定位置上（反转）的位，并按照10位一组的方式分组。乘法和按位与操作将需要的二进制位从原始的字节中提取出来，使得他们都只出现在10位长的组里。原始字节反转后的位置，正好是他们在每个10位小组里面的相对位置。最后一步，通过模除2^10 - 1，可以使64位整数的值按照每10位每10位的方式合并在一起。这个操作不会让他们溢出，所以这个模除的步骤看起来很像按位或。</p><p>这个方法出自 Rich Schroeppel 的<a target="_blank" rel="noopener" href="http://www.inwap.com/pdp10/hbaker/hakmem/hakmem.html">Beeler, M., Gosper, R. W., and Schroeppel, R. HAKMEM. MIT AI Memo 239, Feb. 29, 1972</a>中的Programming Hacks小节。</p><h4>单字节的位反转（4次操作，需要64位乘，不需要除法）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> b; <span class="comment">// reverse this byte</span></span><br><span class="line">                 <span class="comment">// 反转这个字节的二进制位</span></span><br><span class="line"></span><br><span class="line">b = ((b * <span class="number">0x80200802</span>ULL) &amp; <span class="number">0x0884422110</span>ULL) * <span class="number">0x0101010101</span>ULL &gt;&gt; <span class="number">32</span>;</span><br></pre></td></tr></table></figure><p>下图中展示了计算的每个步骤，通过a, b, c, d, e, f, g和h来表示8位长字节的每一位。仔细观察可以发现，第一个乘法产生了几份原始串的拷贝，最后一个乘法则将散落的位从第五个字节开始向右将他们合并在了一起。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">                                                                                        abcd efgh (-&gt; hgfe dcba)</span><br><span class="line">*                                                      1000 0000  0010 0000  0000 1000  0000 0010 (0x80200802)</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line">                                            0abc defg  h00a bcde  fgh0 0abc  defg h00a  bcde fgh0</span><br><span class="line">&amp;                                           0000 1000  1000 0100  0100 0010  0010 0001  0001 0000 (0x0884422110)</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line">                                            0000 d000  h000 0c00  0g00 00b0  00f0 000a  000e 0000</span><br><span class="line">*                                           0000 0001  0000 0001  0000 0001  0000 0001  0000 0001 (0x0101010101)</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line">                                            0000 d000  h000 0c00  0g00 00b0  00f0 000a  000e 0000</span><br><span class="line">                                 0000 d000  h000 0c00  0g00 00b0  00f0 000a  000e 0000</span><br><span class="line">                      0000 d000  h000 0c00  0g00 00b0  00f0 000a  000e 0000</span><br><span class="line">           0000 d000  h000 0c00  0g00 00b0  00f0 000a  000e 0000</span><br><span class="line">0000 d000  h000 0c00  0g00 00b0  00f0 000a  000e 0000</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line">0000 d000  h000 dc00  hg00 dcb0  hgf0 dcba  hgfe dcba  hgfe 0cba  0gfe 00ba  00fe 000a  000e 0000</span><br><span class="line">&gt;&gt; 32</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line">                                            0000 d000  h000 dc00  hg00 dcb0  hgf0 dcba  hgfe dcba</span><br><span class="line">&amp;                                                                                       1111 1111</span><br><span class="line">-------------------------------------------------------------------------------------------------</span><br><span class="line">                                                                                        hgfe dcba</span><br></pre></td></tr></table></figure><p>注意在某些处理器上最后两步可以合并，因为32位寄存器可以作为8位字节长度访问(译者注：IntelX86架构上EAX的最低8位可以使用AL访问)，寄存器存储了乘法运算的结果而我们只需要取低位字节，因此它可能只需要6个操作。</p><p>2001年7月13日，出自Sean Anderson之手。</p><h4>单字节的位反转（7次操作，不需要64位操作）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = ((b * <span class="number">0x0802</span>LU &amp; <span class="number">0x22110</span>LU) | (b * <span class="number">0x8020</span>LU &amp; <span class="number">0x88440</span>LU)) * <span class="number">0x10101</span>LU &gt;&gt; <span class="number">16</span>;</span><br></pre></td></tr></table></figure><p>这个技巧借助高位溢出来消除计算中产生的无用数值，使用前要确保操作的结果保存在无符号char型变量里，以避免这个技巧失效。</p><p>2001年7月13日，出自Sean Anderson之手。<br>2002年1月3日，Mike Keith指出并纠正了书写错误。</p><h4>N位长的串的位反转（5*lg(N)次操作，并行）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> v; <span class="comment">// 32-bit word to reverse bit order</span></span><br><span class="line">                <span class="comment">// 反转32位长的字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// swap odd and even bits</span></span><br><span class="line"><span class="comment">// 反转奇数位和偶数位的位</span></span><br><span class="line">v = ((v &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>) | ((v &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>);</span><br><span class="line"><span class="comment">// swap consecutive pairs</span></span><br><span class="line"><span class="comment">// 反转两两一组的位</span></span><br><span class="line">v = ((v &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>) | ((v &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line"><span class="comment">// swap nibbles ...</span></span><br><span class="line"><span class="comment">// 反转半字节</span></span><br><span class="line">v = ((v &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F0F0F0F</span>) | ((v &amp; <span class="number">0x0F0F0F0F</span>) &lt;&lt; <span class="number">4</span>);</span><br><span class="line"><span class="comment">// swap bytes</span></span><br><span class="line"><span class="comment">// 反转字节</span></span><br><span class="line">v = ((v &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00FF00FF</span>) | ((v &amp; <span class="number">0x00FF00FF</span>) &lt;&lt; <span class="number">8</span>);</span><br><span class="line"><span class="comment">// swap 2-byte long pairs</span></span><br><span class="line"><span class="comment">// 反转两字节一组的位</span></span><br><span class="line">v = ( v &gt;&gt; <span class="number">16</span>             ) | ( v               &lt;&lt; <span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>下面的这个变种时间复杂度同样是O(lg(N))，然而它需要额外的操作来反转变量v。它的优点是常数在过程中计算，这样可以占用更少的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> s = <span class="keyword">sizeof</span>(v) * CHAR_BIT; <span class="comment">// bit size; must be power of 2</span></span><br><span class="line">                                       <span class="comment">// 位长；必须要是2的乘幂</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> mask = ~<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((s &gt;&gt;= <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line">  mask ^= (mask &lt;&lt; s);</span><br><span class="line">  v = ((v &gt;&gt; s) &amp; mask) | ((v &lt;&lt; s) &amp; ~mask);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这些方法很适合用在N很大的场景下。如果你需要用在大于64位的整型数时，那么就便需要按照对应的模式添加代码；不然只会有低32位会被反转，答案也会保存在低32位下。</p><p>参考1983年的Dr.Dobb日志，Binary Magic Numbers中Edwin Freed的文章可以查到更多信息。</p><p>2005年9月13日，Ken Raeburn提出了第二个变种。</p><p>2006年3月19日，Veldmeijer提到，第一个版本的算法的最后一行可以不用位与操作。</p><h3>除法求模运算（或者称为求余运算）</h3><h4>手工计算模除（模数是 <code>1&lt;&lt;s</code> 时）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> n;          <span class="comment">// numerator</span></span><br><span class="line">                               <span class="comment">// 变量n为分子（被模除的数）</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> s;</span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> d = <span class="number">1U</span> &lt;&lt; s; <span class="comment">// So d will be one of: 1, 2, 4, 8, 16, 32, ...</span></span><br><span class="line">                                <span class="comment">// 那么变量d从小到大依次为:1, 2, 4, 8, 16, 32, ...</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> m;                <span class="comment">// m will be n % d</span></span><br><span class="line">                               <span class="comment">// m保存n%d的结果</span></span><br><span class="line">m = n &amp; (d - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这个技巧大多数程序员都会，为了保持完整性，这里还是把这个技巧放在了这里。</p><h4>手工计算模除（模数是 <code>(1&lt;&lt;s)-1</code> 时）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> n;                      <span class="comment">// numerator</span></span><br><span class="line">                                     <span class="comment">// 变量n为分子（被模除的数）</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> s;                <span class="comment">// s &gt; 0</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> d = (<span class="number">1</span> &lt;&lt; s) - <span class="number">1</span>; <span class="comment">// so d is either 1, 3, 7, 15, 31, ...).</span></span><br><span class="line">                                     <span class="comment">// 那么变量d从小到大依次为:1, 3, 7, 15, 31, ...</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> m;                      <span class="comment">// n % d goes here.</span></span><br><span class="line">                                     <span class="comment">// 保存n%d的结果</span></span><br><span class="line"><span class="keyword">for</span> (m = n; n &gt; d; n = m)</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">for</span> (m = <span class="number">0</span>; n; n &gt;&gt;= s)</span><br><span class="line">  {</span><br><span class="line">    m += n &amp; d;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Now m is a value from 0 to d, but since with modulus division</span></span><br><span class="line"><span class="comment">// 此时m的值范围时0到d，但由于这里是模除（译者注：所以需要特殊处理m等于d的情况）</span></span><br><span class="line"><span class="comment">// we want m to be 0 when it is d.</span></span><br><span class="line"><span class="comment">// 当m的值为d时，我们希望m的值变成0</span></span><br><span class="line">m = m == d ? <span class="number">0</span> : m;</span><br></pre></td></tr></table></figure><p>这个用来处理 模数是比2的乘幂少1的整数 的模除技巧，最多需要 5 + (4 + 5 * ceil(N / s)) * ceil(lg(N / s)) 次操作，此处N表示被模数的有效位。也就是说，这个技巧最多需要O(N * lg(N))的时间复杂度。</p><p>2001年8月15日，出自Sean Anderson之手。</p><p>2004年6月17日，Sean A. Irvine纠正了我一个错误，我之前曾错误地写道“我们也可以在后面直接对m赋值，m = ((m + 1) &amp; d) - 1;”。</p><p>2005年4月25日，Michael Miller订正了代码中的一处排版显示错误。</p><h4>手工计算模除（模数是 <code>(1&lt;&lt;s)-1</code> 时，并行）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The following is for a word size of 32 bits!</span></span><br><span class="line"><span class="comment">// 下面的方式适用于字长为32位的情况</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> M[] =</span><br><span class="line">{</span><br><span class="line">  <span class="number">0x00000000</span>, <span class="number">0x55555555</span>, <span class="number">0x33333333</span>, <span class="number">0xc71c71c7</span>,</span><br><span class="line">  <span class="number">0x0f0f0f0f</span>, <span class="number">0xc1f07c1f</span>, <span class="number">0x3f03f03f</span>, <span class="number">0xf01fc07f</span>,</span><br><span class="line">  <span class="number">0x00ff00ff</span>, <span class="number">0x07fc01ff</span>, <span class="number">0x3ff003ff</span>, <span class="number">0xffc007ff</span>,</span><br><span class="line">  <span class="number">0xff000fff</span>, <span class="number">0xfc001fff</span>, <span class="number">0xf0003fff</span>, <span class="number">0xc0007fff</span>,</span><br><span class="line">  <span class="number">0x0000ffff</span>, <span class="number">0x0001ffff</span>, <span class="number">0x0003ffff</span>, <span class="number">0x0007ffff</span>,</span><br><span class="line">  <span class="number">0x000fffff</span>, <span class="number">0x001fffff</span>, <span class="number">0x003fffff</span>, <span class="number">0x007fffff</span>,</span><br><span class="line">  <span class="number">0x00ffffff</span>, <span class="number">0x01ffffff</span>, <span class="number">0x03ffffff</span>, <span class="number">0x07ffffff</span>,</span><br><span class="line">  <span class="number">0x0fffffff</span>, <span class="number">0x1fffffff</span>, <span class="number">0x3fffffff</span>, <span class="number">0x7fffffff</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> Q[][<span class="number">6</span>] =</span><br><span class="line">{</span><br><span class="line">  { <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>}, {<span class="number">16</span>,  <span class="number">8</span>,  <span class="number">4</span>,  <span class="number">2</span>,  <span class="number">1</span>,  <span class="number">1</span>}, {<span class="number">16</span>,  <span class="number">8</span>,  <span class="number">4</span>,  <span class="number">2</span>,  <span class="number">2</span>,  <span class="number">2</span>},</span><br><span class="line">  {<span class="number">15</span>,  <span class="number">6</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>,  <span class="number">3</span>}, {<span class="number">16</span>,  <span class="number">8</span>,  <span class="number">4</span>,  <span class="number">4</span>,  <span class="number">4</span>,  <span class="number">4</span>}, {<span class="number">15</span>,  <span class="number">5</span>,  <span class="number">5</span>,  <span class="number">5</span>,  <span class="number">5</span>,  <span class="number">5</span>},</span><br><span class="line">  {<span class="number">12</span>,  <span class="number">6</span>,  <span class="number">6</span>,  <span class="number">6</span> , <span class="number">6</span>,  <span class="number">6</span>}, {<span class="number">14</span>,  <span class="number">7</span>,  <span class="number">7</span>,  <span class="number">7</span>,  <span class="number">7</span>,  <span class="number">7</span>}, {<span class="number">16</span>,  <span class="number">8</span>,  <span class="number">8</span>,  <span class="number">8</span>,  <span class="number">8</span>,  <span class="number">8</span>},</span><br><span class="line">  { <span class="number">9</span>,  <span class="number">9</span>,  <span class="number">9</span>,  <span class="number">9</span>,  <span class="number">9</span>,  <span class="number">9</span>}, {<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>}, {<span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>, <span class="number">11</span>},</span><br><span class="line">  {<span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>}, {<span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>, <span class="number">13</span>}, {<span class="number">14</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">14</span>},</span><br><span class="line">  {<span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>}, {<span class="number">16</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="number">16</span>}, {<span class="number">17</span>, <span class="number">17</span>, <span class="number">17</span>, <span class="number">17</span>, <span class="number">17</span>, <span class="number">17</span>},</span><br><span class="line">  {<span class="number">18</span>, <span class="number">18</span>, <span class="number">18</span>, <span class="number">18</span>, <span class="number">18</span>, <span class="number">18</span>}, {<span class="number">19</span>, <span class="number">19</span>, <span class="number">19</span>, <span class="number">19</span>, <span class="number">19</span>, <span class="number">19</span>}, {<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>},</span><br><span class="line">  {<span class="number">21</span>, <span class="number">21</span>, <span class="number">21</span>, <span class="number">21</span>, <span class="number">21</span>, <span class="number">21</span>}, {<span class="number">22</span>, <span class="number">22</span>, <span class="number">22</span>, <span class="number">22</span>, <span class="number">22</span>, <span class="number">22</span>}, {<span class="number">23</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">23</span>},</span><br><span class="line">  {<span class="number">24</span>, <span class="number">24</span>, <span class="number">24</span>, <span class="number">24</span>, <span class="number">24</span>, <span class="number">24</span>}, {<span class="number">25</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">25</span>}, {<span class="number">26</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">26</span>},</span><br><span class="line">  {<span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>, <span class="number">27</span>}, {<span class="number">28</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">28</span>}, {<span class="number">29</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">29</span>, <span class="number">29</span>},</span><br><span class="line">  {<span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>}, {<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> R[][<span class="number">6</span>] =</span><br><span class="line">{</span><br><span class="line">  {<span class="number">0x00000000</span>, <span class="number">0x00000000</span>, <span class="number">0x00000000</span>, <span class="number">0x00000000</span>, <span class="number">0x00000000</span>, <span class="number">0x00000000</span>},</span><br><span class="line">  {<span class="number">0x0000ffff</span>, <span class="number">0x000000ff</span>, <span class="number">0x0000000f</span>, <span class="number">0x00000003</span>, <span class="number">0x00000001</span>, <span class="number">0x00000001</span>},</span><br><span class="line">  {<span class="number">0x0000ffff</span>, <span class="number">0x000000ff</span>, <span class="number">0x0000000f</span>, <span class="number">0x00000003</span>, <span class="number">0x00000003</span>, <span class="number">0x00000003</span>},</span><br><span class="line">  {<span class="number">0x00007fff</span>, <span class="number">0x0000003f</span>, <span class="number">0x00000007</span>, <span class="number">0x00000007</span>, <span class="number">0x00000007</span>, <span class="number">0x00000007</span>},</span><br><span class="line">  {<span class="number">0x0000ffff</span>, <span class="number">0x000000ff</span>, <span class="number">0x0000000f</span>, <span class="number">0x0000000f</span>, <span class="number">0x0000000f</span>, <span class="number">0x0000000f</span>},</span><br><span class="line">  {<span class="number">0x00007fff</span>, <span class="number">0x0000001f</span>, <span class="number">0x0000001f</span>, <span class="number">0x0000001f</span>, <span class="number">0x0000001f</span>, <span class="number">0x0000001f</span>},</span><br><span class="line">  {<span class="number">0x00000fff</span>, <span class="number">0x0000003f</span>, <span class="number">0x0000003f</span>, <span class="number">0x0000003f</span>, <span class="number">0x0000003f</span>, <span class="number">0x0000003f</span>},</span><br><span class="line">  {<span class="number">0x00003fff</span>, <span class="number">0x0000007f</span>, <span class="number">0x0000007f</span>, <span class="number">0x0000007f</span>, <span class="number">0x0000007f</span>, <span class="number">0x0000007f</span>},</span><br><span class="line">  {<span class="number">0x0000ffff</span>, <span class="number">0x000000ff</span>, <span class="number">0x000000ff</span>, <span class="number">0x000000ff</span>, <span class="number">0x000000ff</span>, <span class="number">0x000000ff</span>},</span><br><span class="line">  {<span class="number">0x000001ff</span>, <span class="number">0x000001ff</span>, <span class="number">0x000001ff</span>, <span class="number">0x000001ff</span>, <span class="number">0x000001ff</span>, <span class="number">0x000001ff</span>},</span><br><span class="line">  {<span class="number">0x000003ff</span>, <span class="number">0x000003ff</span>, <span class="number">0x000003ff</span>, <span class="number">0x000003ff</span>, <span class="number">0x000003ff</span>, <span class="number">0x000003ff</span>},</span><br><span class="line">  {<span class="number">0x000007ff</span>, <span class="number">0x000007ff</span>, <span class="number">0x000007ff</span>, <span class="number">0x000007ff</span>, <span class="number">0x000007ff</span>, <span class="number">0x000007ff</span>},</span><br><span class="line">  {<span class="number">0x00000fff</span>, <span class="number">0x00000fff</span>, <span class="number">0x00000fff</span>, <span class="number">0x00000fff</span>, <span class="number">0x00000fff</span>, <span class="number">0x00000fff</span>},</span><br><span class="line">  {<span class="number">0x00001fff</span>, <span class="number">0x00001fff</span>, <span class="number">0x00001fff</span>, <span class="number">0x00001fff</span>, <span class="number">0x00001fff</span>, <span class="number">0x00001fff</span>},</span><br><span class="line">  {<span class="number">0x00003fff</span>, <span class="number">0x00003fff</span>, <span class="number">0x00003fff</span>, <span class="number">0x00003fff</span>, <span class="number">0x00003fff</span>, <span class="number">0x00003fff</span>},</span><br><span class="line">  {<span class="number">0x00007fff</span>, <span class="number">0x00007fff</span>, <span class="number">0x00007fff</span>, <span class="number">0x00007fff</span>, <span class="number">0x00007fff</span>, <span class="number">0x00007fff</span>},</span><br><span class="line">  {<span class="number">0x0000ffff</span>, <span class="number">0x0000ffff</span>, <span class="number">0x0000ffff</span>, <span class="number">0x0000ffff</span>, <span class="number">0x0000ffff</span>, <span class="number">0x0000ffff</span>},</span><br><span class="line">  {<span class="number">0x0001ffff</span>, <span class="number">0x0001ffff</span>, <span class="number">0x0001ffff</span>, <span class="number">0x0001ffff</span>, <span class="number">0x0001ffff</span>, <span class="number">0x0001ffff</span>},</span><br><span class="line">  {<span class="number">0x0003ffff</span>, <span class="number">0x0003ffff</span>, <span class="number">0x0003ffff</span>, <span class="number">0x0003ffff</span>, <span class="number">0x0003ffff</span>, <span class="number">0x0003ffff</span>},</span><br><span class="line">  {<span class="number">0x0007ffff</span>, <span class="number">0x0007ffff</span>, <span class="number">0x0007ffff</span>, <span class="number">0x0007ffff</span>, <span class="number">0x0007ffff</span>, <span class="number">0x0007ffff</span>},</span><br><span class="line">  {<span class="number">0x000fffff</span>, <span class="number">0x000fffff</span>, <span class="number">0x000fffff</span>, <span class="number">0x000fffff</span>, <span class="number">0x000fffff</span>, <span class="number">0x000fffff</span>},</span><br><span class="line">  {<span class="number">0x001fffff</span>, <span class="number">0x001fffff</span>, <span class="number">0x001fffff</span>, <span class="number">0x001fffff</span>, <span class="number">0x001fffff</span>, <span class="number">0x001fffff</span>},</span><br><span class="line">  {<span class="number">0x003fffff</span>, <span class="number">0x003fffff</span>, <span class="number">0x003fffff</span>, <span class="number">0x003fffff</span>, <span class="number">0x003fffff</span>, <span class="number">0x003fffff</span>},</span><br><span class="line">  {<span class="number">0x007fffff</span>, <span class="number">0x007fffff</span>, <span class="number">0x007fffff</span>, <span class="number">0x007fffff</span>, <span class="number">0x007fffff</span>, <span class="number">0x007fffff</span>},</span><br><span class="line">  {<span class="number">0x00ffffff</span>, <span class="number">0x00ffffff</span>, <span class="number">0x00ffffff</span>, <span class="number">0x00ffffff</span>, <span class="number">0x00ffffff</span>, <span class="number">0x00ffffff</span>},</span><br><span class="line">  {<span class="number">0x01ffffff</span>, <span class="number">0x01ffffff</span>, <span class="number">0x01ffffff</span>, <span class="number">0x01ffffff</span>, <span class="number">0x01ffffff</span>, <span class="number">0x01ffffff</span>},</span><br><span class="line">  {<span class="number">0x03ffffff</span>, <span class="number">0x03ffffff</span>, <span class="number">0x03ffffff</span>, <span class="number">0x03ffffff</span>, <span class="number">0x03ffffff</span>, <span class="number">0x03ffffff</span>},</span><br><span class="line">  {<span class="number">0x07ffffff</span>, <span class="number">0x07ffffff</span>, <span class="number">0x07ffffff</span>, <span class="number">0x07ffffff</span>, <span class="number">0x07ffffff</span>, <span class="number">0x07ffffff</span>},</span><br><span class="line">  {<span class="number">0x0fffffff</span>, <span class="number">0x0fffffff</span>, <span class="number">0x0fffffff</span>, <span class="number">0x0fffffff</span>, <span class="number">0x0fffffff</span>, <span class="number">0x0fffffff</span>},</span><br><span class="line">  {<span class="number">0x1fffffff</span>, <span class="number">0x1fffffff</span>, <span class="number">0x1fffffff</span>, <span class="number">0x1fffffff</span>, <span class="number">0x1fffffff</span>, <span class="number">0x1fffffff</span>},</span><br><span class="line">  {<span class="number">0x3fffffff</span>, <span class="number">0x3fffffff</span>, <span class="number">0x3fffffff</span>, <span class="number">0x3fffffff</span>, <span class="number">0x3fffffff</span>, <span class="number">0x3fffffff</span>},</span><br><span class="line">  {<span class="number">0x7fffffff</span>, <span class="number">0x7fffffff</span>, <span class="number">0x7fffffff</span>, <span class="number">0x7fffffff</span>, <span class="number">0x7fffffff</span>, <span class="number">0x7fffffff</span>}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> n;       <span class="comment">// numerator</span></span><br><span class="line">                      <span class="comment">// 变量n为分子（被模除的数）</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> s; <span class="comment">// s &gt; 0</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> d = (<span class="number">1</span> &lt;&lt; s) - <span class="number">1</span>; <span class="comment">// so d is either 1, 3, 7, 15, 31, ...).</span></span><br><span class="line">                                     <span class="comment">// 那么变量d从小到大依次为:1, 3, 7, 15, 31, ...</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> m;       <span class="comment">// n % d goes here.</span></span><br><span class="line">                      <span class="comment">// m保存n%d的结果</span></span><br><span class="line"></span><br><span class="line">m = (n &amp; M[s]) + ((n &gt;&gt; s) &amp; M[s]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> * q = &amp;Q[s][<span class="number">0</span>], * r = &amp;R[s][<span class="number">0</span>]; m &gt; d; q++, r++)</span><br><span class="line">{</span><br><span class="line">  m = (m &gt;&gt; *q) + (m &amp; *r);</span><br><span class="line">}</span><br><span class="line">m = m == d ? <span class="number">0</span> : m; <span class="comment">// OR, less portably: m = m &amp; -((signed)(m - d) &gt;&gt; s);</span></span><br></pre></td></tr></table></figure><p>这个用来处理 模数是比2的乘幂少1的整数 的模除技巧，最多需要 O(lg(N)) 的时间复杂度，其中N是指被模除的数（如代码注释，32位整数）。操作数最多为 12 + 9 * ceil(lg(N)) 次。如果在编译期可以知道分母（除数），那么这里的表可以去掉；留下表中需要用到的数据，然后去掉循环。这个方法可以轻易地扩展到更多位。</p></div><div class="article-copyright"><p>本作品采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> 进行许可。</p><p>转载时请注明<a href="https://blog.hufeifei.cn/2017/07/DataStructure/bit-hacks/">原文链接</a>：https://blog.hufeifei.cn/2017/07/DataStructure/bit-hacks/</p></div><footer class="article-footer"><div class="article-tag"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/bit-hack/" rel="tag">bit-hack</a></li></ul></div></footer></div><div id="article-reward"><i class="iconfont ic-money"></i><div>鼓励一下</div><table><thead><tr><th style="text-align:center">支付宝</th><th style="text-align:center">微信</th></tr></thead><tbody><tr><td style="text-align:center"><img width="150" src="https://www.hufeifei.cn/reward-img/alipay.jpg"></td><td style="text-align:center"><img width="135" src="https://www.hufeifei.cn/reward-img/wechat.jpg"></td></tr></tbody></table></div><nav id="article-nav"><a class="article-nav-link-wrap" href="/2017/08/Java/Java-i18n/" id="article-nav-newer"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">Java 国际化主题大合集</div></a><a class="article-nav-link-wrap" href="/2017/07/DataStructure/%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95%E3%80%81%E6%9B%B4%E7%9B%B8%E5%87%8F%E6%8D%9F%E6%B3%95%E3%80%81Stein%E7%AE%97%E6%B3%95/" id="article-nav-older"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">辗转相除法、更相减损法、Stein算法</div></a></nav></article><div id="waline-comments"></div><script type="module">import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js';init({"el":"#waline-comments","pageview":true,"enable":true,"serverURL":"https://api.waline.blog.hufeifei.cn","avatar":"mp","pageSize":10,"lang":"zh-cn","placeholder":"Just go go","visitor":true,"recordIP":true,"requiredFields":["nick"]});</script></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">关注微信公众号</h3><div class="widget wechat"><img src="//www.hufeifei.cn/wechat-public-account.jpg"></div></div><div class="widget-wrap"><h3 class="widget-title">Categories</h3><div class="widget"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C&C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/J2EE/">J2EE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux%E8%BF%90%E7%BB%B4/">Linux运维</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby/">Ruby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rust/">Rust</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%A3%E7%A0%81%E6%97%A5%E5%B8%B8/">代码日常</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%95%86%E4%B8%9A/">商业</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%8F%E6%B5%8E%E4%B8%8E%E9%87%91%E8%9E%8D/">经济与金融</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/">计算机组成</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Tag Cloud</h3><div class="widget tagcloud"><a href="/tags/AVL/" style="font-size:11.11px">AVL</a> <a href="/tags/Alibaba/" style="font-size:14.44px">Alibaba</a> <a href="/tags/Android/" style="font-size:18.89px">Android</a> <a href="/tags/B-Tree/" style="font-size:12.22px">B-Tree</a> <a href="/tags/BKD-Tree/" style="font-size:10px">BKD-Tree</a> <a href="/tags/BST/" style="font-size:10px">BST</a> <a href="/tags/BigData/" style="font-size:11.11px">BigData</a> <a href="/tags/C/" style="font-size:14.44px">C</a> <a href="/tags/CGlib/" style="font-size:10px">CGlib</a> <a href="/tags/CS/" style="font-size:11.11px">CS</a> <a href="/tags/Canal/" style="font-size:10px">Canal</a> <a href="/tags/ClassLoader/" style="font-size:10px">ClassLoader</a> <a href="/tags/ClickHouse/" style="font-size:10px">ClickHouse</a> <a href="/tags/Config/" style="font-size:10px">Config</a> <a href="/tags/Cryptography/" style="font-size:10px">Cryptography</a> <a href="/tags/DB/" style="font-size:20px">DB</a> <a href="/tags/Dapper/" style="font-size:10px">Dapper</a> <a href="/tags/DataStructure/" style="font-size:14.44px">DataStructure</a> <a href="/tags/Debezium/" style="font-size:10px">Debezium</a> <a href="/tags/Diamond/" style="font-size:10px">Diamond</a> <a href="/tags/Distributed/" style="font-size:13.33px">Distributed</a> <a href="/tags/ElasticSearch/" style="font-size:10px">ElasticSearch</a> <a href="/tags/Encoding/" style="font-size:10px">Encoding</a> <a href="/tags/FastJson/" style="font-size:10px">FastJson</a> <a href="/tags/File/" style="font-size:10px">File</a> <a href="/tags/FlowMarketing/" style="font-size:10px">FlowMarketing</a> <a href="/tags/Grade/" style="font-size:10px">Grade</a> <a href="/tags/Gson/" style="font-size:10px">Gson</a> <a href="/tags/HTTP/" style="font-size:10px">HTTP</a> <a href="/tags/Handler/" style="font-size:10px">Handler</a> <a href="/tags/Hanlder/" style="font-size:10px">Hanlder</a> <a href="/tags/Hessian/" style="font-size:10px">Hessian</a> <a href="/tags/IO-Multiplex/" style="font-size:10px">IO-Multiplex</a> <a href="/tags/JAVA/" style="font-size:18.89px">JAVA</a> <a href="/tags/JVM/" style="font-size:10px">JVM</a> <a href="/tags/KD-Tree/" style="font-size:10px">KD-Tree</a> <a href="/tags/KDB-Tree/" style="font-size:10px">KDB-Tree</a> <a href="/tags/Kafka/" style="font-size:10px">Kafka</a> <a href="/tags/Kubernetes/" style="font-size:10px">Kubernetes</a> <a href="/tags/LSM-Tree/" style="font-size:11.11px">LSM-Tree</a> <a href="/tags/Linux/" style="font-size:17.78px">Linux</a> <a href="/tags/Lock/" style="font-size:11.11px">Lock</a> <a href="/tags/Lucene/" style="font-size:10px">Lucene</a> <a href="/tags/MQ/" style="font-size:10px">MQ</a> <a href="/tags/Macro/" style="font-size:10px">Macro</a> <a href="/tags/Magisk/" style="font-size:10px">Magisk</a> <a href="/tags/MultiDex/" style="font-size:10px">MultiDex</a> <a href="/tags/MySQL/" style="font-size:17.78px">MySQL</a> <a href="/tags/NIO/" style="font-size:10px">NIO</a> <a href="/tags/Nginx/" style="font-size:11.11px">Nginx</a> <a href="/tags/OGNL/" style="font-size:10px">OGNL</a> <a href="/tags/OpenResty/" style="font-size:10px">OpenResty</a> <a href="/tags/OpenTelemetry/" style="font-size:10px">OpenTelemetry</a> <a href="/tags/Oracle/" style="font-size:10px">Oracle</a> <a href="/tags/PostgreSQL/" style="font-size:10px">PostgreSQL</a> <a href="/tags/RB-Tree/" style="font-size:10px">RB-Tree</a> <a href="/tags/Redis/" style="font-size:10px">Redis</a> <a href="/tags/Rust/" style="font-size:10px">Rust</a> <a href="/tags/Sharding/" style="font-size:10px">Sharding</a> <a href="/tags/SpringBoot/" style="font-size:10px">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size:10px">SpringCloud</a> <a href="/tags/SpringCloudConfig/" style="font-size:10px">SpringCloudConfig</a> <a href="/tags/Sqlite/" style="font-size:10px">Sqlite</a> <a href="/tags/SurfaceView/" style="font-size:10px">SurfaceView</a> <a href="/tags/VSCode/" style="font-size:11.11px">VSCode</a> <a href="/tags/WebFlux/" style="font-size:10px">WebFlux</a> <a href="/tags/WebPush/" style="font-size:10px">WebPush</a> <a href="/tags/Web%E6%8C%96%E6%8E%98/" style="font-size:11.11px">Web挖掘</a> <a href="/tags/awk/" style="font-size:10px">awk</a> <a href="/tags/bit-hack/" style="font-size:10px">bit-hack</a> <a href="/tags/cheat-sheet/" style="font-size:10px">cheat sheet</a> <a href="/tags/curl/" style="font-size:10px">curl</a> <a href="/tags/epoll/" style="font-size:10px">epoll</a> <a href="/tags/gRPC/" style="font-size:10px">gRPC</a> <a href="/tags/grep/" style="font-size:10px">grep</a> <a href="/tags/kqueue/" style="font-size:10px">kqueue</a> <a href="/tags/libev/" style="font-size:10px">libev</a> <a href="/tags/libevent/" style="font-size:10px">libevent</a> <a href="/tags/libuv/" style="font-size:10px">libuv</a> <a href="/tags/metaq/" style="font-size:10px">metaq</a> <a href="/tags/poll/" style="font-size:10px">poll</a> <a href="/tags/sed/" style="font-size:10px">sed</a> <a href="/tags/select/" style="font-size:10px">select</a> <a href="/tags/ssh/" style="font-size:10px">ssh</a> <a href="/tags/%E5%8E%86%E5%8F%B2/" style="font-size:10px">历史</a> <a href="/tags/%E5%95%86%E4%B8%9A/" style="font-size:10px">商业</a> <a href="/tags/%E5%BF%83%E7%90%86%E5%AD%A6/" style="font-size:10px">心理学</a> <a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size:11.11px">生活</a> <a href="/tags/%E7%A8%8E%E6%94%B6/" style="font-size:10px">税收</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size:14.44px">算法</a> <a href="/tags/%E7%BB%8F%E6%B5%8E/" style="font-size:15.56px">经济</a> <a href="/tags/%E8%90%A5%E9%94%80/" style="font-size:10px">营销</a> <a href="/tags/%E8%B4%A7%E5%B8%81/" style="font-size:10px">货币</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size:16.67px">随笔</a></div></div><div class="widget-wrap"><h3 class="widget-title">Recent Posts</h3><div class="widget"><ul><li><a href="/2024/04/economic/value-added-tax/">增值税与贫富差距</a></li><li><a href="/2024/01/Net/x-forward-for/">“真”的IP真的是真的吗？</a></li><li><a href="/2024/01/paper/MarkupLM-web-extract/">【译】基于MarkupLM的web数据抽取</a></li><li><a href="/2023/09/economic/tax-reform/">直接税改革——王朝周期律的胜负手</a></li><li><a href="/2023/09/Rust/macro-rules-learning/">Rust中的宏</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">网站运营不易</h3><div class="ads-wrapper"><div class="google_ads"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7111912103882824" data-ad-slot="8429272980" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div></div></aside></div><footer id="footer"><div class="outer"><div class="inner" id="footer-info"><p><a href="https://beian.miit.gov.cn/" target="_blank">赣ICP备17009276号</a><i class="far fa-copyright"></i>2016 ~ 2024 胡飞飞</p><p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a><i class="fas fa-angle-right"></i>Theme by <a target="_blank" rel="noopener" href="https://github.com/holmofy/hexo-theme-paper">paper</a></p></div></div></footer></div><nav id="mobile-nav"><a class="mobile-nav-link" href="//www.hufeifei.cn">主页</a><a class="mobile-nav-link" href="/">博客</a><a class="mobile-nav-link" href="/archives">归档</a><a class="mobile-nav-link" target="_blank" rel="noopener" href="//algo.hufeifei.cn">算法</a><a class="mobile-nav-link" href="/book">书籍</a><a class="mobile-nav-link" href="/github">Github</a></nav><script src="//cdnjs.loli.net/ajax/libs/jquery/3.0.0/jquery.min.js"></script><link rel="stylesheet" href="//cdnjs.loli.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="//cdnjs.loli.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/script.js"></script></div><script>
  $(document).ready(function() {
    $('figure.codeblock').find('.tab').click(function() {
        var $codeblock = $(this).parent().parent().parent();
        var $tab = $(this);
        // remove "active" css class on all tabs
        $tab.siblings().removeClass('active');
        // add "active" css class on the clicked tab
        $tab.addClass('active');
        // hide all tab contents
        $codeblock.find('.highlight').hide();
        // show only the right one
        $codeblock.find('.highlight.' + $tab.text()).show();
    });
  });
  </script><script>(function (w, d, s, id) {
            if (typeof (w.webpushr) !== 'undefined') return; w.webpushr = w.webpushr || function () { (w.webpushr.q = w.webpushr.q || []).push(arguments) }; var js, fjs = d.getElementsByTagName(s)[0]; js = d.createElement(s); js.id = id; js.async = 1; js.src = "https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window, document, 'script', 'webpushr-jssdk'));webpushr('setup', { 'key': 'BPJzNs1QEtbYa3Bn0gMAQHBAzX3Jm71llGUKHTkKEUs3D9xiDYZ0DWJ3S9sfCAAJHxXEoBkUANFyONjeIlgrJUo'' });</script></body></html>