<!doctype html><html lang="en"><head><meta charset="utf-8"><script async src="https://www.googletagmanager.com/gtag/js?id=G-H58NSPXYPF"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-H58NSPXYPF")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?b3392fb5f6d65fb10354f590338d1ee4",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,a,i){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/95vxjpui4h",(i=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,i)}(window,document,"clarity","script")</script><title>Java多线程复习与巩固（一）--线程基本使用 | holmofy</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="baidu_union_verify" content="b7d27ec946758934fcdf3c5c26386237"><meta description="系列文章：  Java多线程复习与巩固（一）–线程基本使用 Java多线程复习与巩固（二）–线程相关工具类的使用 Java多线程复习与巩固（三）–线程同步 Java多线程复习与巩固（四）–synchronized的实现 Java多线程复习与巩固（五）–生产者消费者问题（第一部分） Java多线程复习与巩固（六）–线程池ThreadPoolExecutor详解 Java多线程复习与巩固（七）–任务调"><meta property="og:type" content="article"><meta property="og:title" content="Java多线程复习与巩固（一）--线程基本使用"><meta property="og:url" content="https://blog.hufeifei.cn/2017/06/Java/multithread/01-Thread-Basic/index.html"><meta property="og:site_name" content="holmofy"><link rel="canonical" href="https://blog.hufeifei.cn/2017/06/Java/multithread/01-Thread-Basic/index.html"><meta property="description" content="系列文章：  Java多线程复习与巩固（一）–线程基本使用 Java多线程复习与巩固（二）–线程相关工具类的使用 Java多线程复习与巩固（三）–线程同步 Java多线程复习与巩固（四）–synchronized的实现 Java多线程复习与巩固（五）–生产者消费者问题（第一部分） Java多线程复习与巩固（六）–线程池ThreadPoolExecutor详解 Java多线程复习与巩固（七）–任务调"><meta name="description" content="系列文章：  Java多线程复习与巩固（一）–线程基本使用 Java多线程复习与巩固（二）–线程相关工具类的使用 Java多线程复习与巩固（三）–线程同步 Java多线程复习与巩固（四）–synchronized的实现 Java多线程复习与巩固（五）–生产者消费者问题（第一部分） Java多线程复习与巩固（六）–线程池ThreadPoolExecutor详解 Java多线程复习与巩固（七）–任务调"><meta property="og:description" content="系列文章：  Java多线程复习与巩固（一）–线程基本使用 Java多线程复习与巩固（二）–线程相关工具类的使用 Java多线程复习与巩固（三）–线程同步 Java多线程复习与巩固（四）–synchronized的实现 Java多线程复习与巩固（五）–生产者消费者问题（第一部分） Java多线程复习与巩固（六）–线程池ThreadPoolExecutor详解 Java多线程复习与巩固（七）–任务调"><meta property="article:published_time" content="2017-06-13T16:00:00.000Z"><meta property="article:modified_time" content="2024-05-03T05:17:06.695Z"><meta property="article:author" content="胡飞飞"><meta property="article:tag" content="Java 多线程编程"><meta property="keywords" content="Java 多线程编程"><meta property="twitter:card" content="summary"><script data-ad-client="ca-pub-7111912103882824" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7111912103882824" crossorigin="anonymous"></script><script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js"></script><script type="text/javascript" src="//cpro.baidustatic.com/cpro/ui/cm.js" async defer></script><link rel="alternate" href="/atom.xml" title="holmofy" type="application/atom+xml"><link rel="icon" href="//www.hufeifei.cn/favicon.jpg"><link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"><link href="//unpkg.com/@waline/client@v3/dist/waline.css" rel="stylesheet" type="text/css"><link href="//at.alicdn.com/t/font_841402_efkj8jo1xld.css" rel="stylesheet" type="text/css"><link rel="stylesheet" href="//cdnjs.loli.net/ajax/libs/font-awesome/5.15.3/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/style.css"><link rel="dns-prefetch" href="//static.zhimg.com"><link rel="dns-prefetch" href="//at.alicdn.com"><link rel="dns-prefetch" href="//cdn.jsdelivr.net"><link rel="dns-prefetch" href="//img-blog.csdn.net"><link rel="dns-prefetch" href="//img-blog.csdnimg.cn"><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><style>
    figure.codeblock {
       margin: 0;
    }
    figure figcaption .tabs {
      display: flex;
      margin: 0;
    }
    figure figcaption .tabs .tab {
      cursor: pointer;
      list-style: none;
      padding: 5px 15px;
    }
    figure figcaption .tabs .tab.active {
      background: #2d2d2d;
      color: white;
    }
  </style></head><body><amp-auto-ads type="adsense" data-ad-client="ca-pub-7111912103882824"></amp-auto-ads><div id="container"><div id="wrap"><header id="header"><div class="outer" id="header-outer"><div class="inner" id="header-inner"><nav id="main-nav"><a class="nav-icon" id="main-nav-toggle"><i class="fas fa-bars"></i></a><a class="main-nav-link" href="//www.hufeifei.cn">主页</a><a class="main-nav-link" href="/">博客</a><a class="main-nav-link" href="/archives">归档</a><a class="main-nav-link" target="_blank" rel="noopener" href="//algo.hufeifei.cn">算法</a><a class="main-nav-link" href="/book">书籍</a><a class="main-nav-link" href="/github">Github</a></nav><nav id="sub-nav"><a class="nav-icon" id="nav-rss-link" href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a><a class="nav-icon" id="nav-search-btn" title="Search"><i class="fas fa-search"></i></a></nav><div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="fas fa-search"></i></button><input type="hidden" name="sitesearch" value="https://blog.hufeifei.cn"></form></div></div></div></header><div class="outer"><section id="main"><article class="article article-type-post" id="post-Java/multithread/01-Thread-Basic" itemscope itemprop="blogPost"><div class="article-meta"><a class="article-date" href="/2017/06/Java/multithread/01-Thread-Basic/"><time datetime="2017-06-13T16:00:00.000Z" itemprop="datePublished">2017-06-14</time></a><div class="article-category"><a class="article-category-link" href="/categories/JAVA/">JAVA</a></div><div class="article-views leancloud_visitors" id="/2017/06/Java/multithread/01-Thread-Basic/" data-flag-title="Java多线程复习与巩固（一）--线程基本使用" title="Views"><i class="fas fa-eye"></i><span class="waline-pageview-count" data-path="/2017/06/Java/multithread/01-Thread-Basic/"></span></div></div><div class="article-inner"><header class="article-header" style="text-align:center"><h1 class="article-title" itemprop="name">Java多线程复习与巩固（一）--线程基本使用</h1></header><div class="article-entry" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><strong>系列文章：</strong></p><ul><li><a href="https://blog.hufeifei.cn/2017/06/Java/multithread/01-Thread-Basic/">Java多线程复习与巩固（一）–线程基本使用</a></li><li><a href="https://blog.hufeifei.cn/2017/06/Java/multithread/02-Thread-Utility/">Java多线程复习与巩固（二）–线程相关工具类的使用</a></li><li><a href="https://blog.hufeifei.cn/2017/06/Java/multithread/03-Synchronized/">Java多线程复习与巩固（三）–线程同步</a></li><li><a href="https://blog.hufeifei.cn/2017/06/Java/multithread/04-Synchronized-Implement/">Java多线程复习与巩固（四）–synchronized的实现</a></li><li><a href="https://blog.hufeifei.cn/2017/06/Java/multithread/05-Provider-Consumer/">Java多线程复习与巩固（五）–生产者消费者问题（第一部分）</a></li><li><a href="https://blog.hufeifei.cn/2017/06/Java/multithread/06-ThreadPoolExecutor/">Java多线程复习与巩固（六）–线程池ThreadPoolExecutor详解</a></li><li><a href="https://blog.hufeifei.cn/2017/06/Java/multithread/07-ScheduledThreadPoolExecutor/">Java多线程复习与巩固（七）–任务调度线程池ScheduledThreadPoolExecutor</a></li><li><a href="https://blog.hufeifei.cn/2017/06/Java/multithread/08-Atomic/">Java多线程复习与巩固（八）–原子性操作与原子变量</a></li><li><a href="https://blog.hufeifei.cn/2017/06/Java/multithread/09-volatile-CAS/">Java多线程复习与巩固（九）–volatile关键字与CAS操作</a></li><li><a href="https://blog.hufeifei.cn/2018/07/Java/ThreadPoolExecutor-best-practice-thread-size/">ThreadPoolExecutor最佳实践–如何选择线程数</a></li><li><a href="https://blog.hufeifei.cn/2018/08/Java/ThreadPoolExecutor-best-practice-queue/">ThreadPoolExecutor最佳实践–如何选择队列</a></li></ul><hr><h2>1、进程与线程</h2><p>在并发编程中，有两个基本的执行单元：进程和线程。在Java中，并发编程主要关心的是线程。当然，进程也很重要。</p><h3>1.1、进程(Process)</h3><p>进程有独立的执行环境，一个进程有一套私有的、完整的运行时资源，比如：每个进程都有自己的内存空间。</p><p>进程通常会被认为是一个应用程序的代名词。但实际上一个应用程序可能会包含多个协同工作的进程。比如你电脑里的360打开后肯定有两个或两个以上的进程：一个管理是后台服务模块，一个是主程序控制模块。而为了促进进程之间的通信，操作系统都会支持进程间通信(Inter-Process Communication IPC)的机制，例如：套接字、管道机制。IPC不仅可以用于同一系统上进程之间的通信，还可以用于不同系统上进程之间的通信，比如Java的RMI(Remote Method Invoke)就是不同系统间IPC的体现。</p><p>Java虚拟机的大多数实现都是作为一个进程运行的。Java应用程序可以使用<code>Runtime.exec()</code>执行指定命定来创建新进程，Java1.5之后还提供了更灵活的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/ProcessBuilder.htm">ProcessBuilder</a>来创建进程，Java中以<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Process.html">Process</a>对象表示创建的进程。</p><p>下面是用ProcessBuilder调用<code>unzip</code>命令执行解压的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeUnzip</span><span class="params">(String password, Path targetDir, Path zipFile)</span> {</span><br><span class="line">        <span class="type">ProcessBuilder</span> <span class="variable">pb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(<span class="string">"unzip"</span>, </span><br><span class="line">                                               <span class="string">"-P"</span>, password, </span><br><span class="line">                                               <span class="string">"-d"</span>, targetDir.toAbsolutePath().toString(), </span><br><span class="line">                                               zipFile.toAbsolutePath().toString());</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            FileUtils.deleteDirectory(targetDir.toFile());</span><br><span class="line">            pb.redirectErrorStream(<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) {</span><br><span class="line">                log.debug(<span class="string">"invoke unzip, command:"</span> + String.join(<span class="string">" "</span>, pb.command()));</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="type">Process</span> <span class="variable">unzipProcess</span> <span class="operator">=</span> pb.start();</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">stdOutReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(unzipProcess.getInputStream()))) {</span><br><span class="line">                stdOutReader.lines().forEach(log::info);</span><br><span class="line">            }</span><br><span class="line">            unzipProcess.waitFor();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            log.error(<span class="string">"unzip file failed"</span>);</span><br><span class="line">            ExceptionUtils.rethrow(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，由于创建的子进程没有终端控制台，所以它的标准IO流(stdin,stdout,stderr)都会被交由父进程处理(即我们的写的Java程序)。一方面这让我们能更灵活的控制子进程的IO，但如果我们没有对IO流进行处理将会导致子进程阻塞(子进程等待输入或输出导致进入sleep状态)。比如上面的例子中如果我们没有将子进程的输出消费掉(打印到日志中)，会导致子进程的阻塞；<code>FileUtils.deleteDirectory(targetDir.toFile())</code>这句也是为了防止程序运行时解压出来的文件已经存在在目录中，<code>unzip</code>命令会询问是否覆盖原文件而等待用户输入，这也会导致程序阻塞。</p></blockquote><h3>1.2、线程(Thread)</h3><p>线程有个更形象的名字——“轻量级进程”。进程和线程都提供一个执行环境，但创建线程消耗的资源比创建进程少的多。</p><p>线程存在于一个进程中，每个进程至少包含一个线程(主线程)。同一进程中的线程共享该进程中的资源，比如内存资源或进程占用的文件资源等。这使得线程间通信比进程间通信更加简单，但也更容易出现问题。</p><blockquote><p>正因为线程与进程有很多的相似之处，所以线程出现的问题以及解决方法和进程是类似的。在接下来的文章中我们会提到线程同步和线程死锁的问题，这和操作系统中的进程同步、进程死锁问题相似。进程同步已经由操作系统实现了，而线程同步需要我们程序员自己实现。</p></blockquote><h2>2、并发与并行</h2><p>计算机系统通常有很多的活动进程和线程。但在单核处理器的系统中，任何<strong>时刻</strong>实际只有一个进程(或线程)执行。单核系统通过时间分片的方式处理进程(或线程)之间的共享。这就是早期的分时系统(Time Sharing System)。</p><p>后来多核处理器变得越来越普及，这大大增强了系统并行执行进程和线程的能力。因为多核处理器有多套处理设备(寄存器，ALU等)，所以同一时刻可以有多个进程(或线程)同时执行。</p><p><strong>并发（Concurrent）</strong>是由于时间片非常短，CPU的流水线工作使得CPU看上去能够同时处理多个任务，但实际上只是同时处理不同任务的不同部分。</p><p>比如下面这个前趋图中：任务3的输入执行操作的同时(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.375ex" xmlns="http://www.w3.org/2000/svg" width="1.983ex" height="1.92ex" role="img" focusable="false" viewBox="0 -683 876.6 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D43C" d="M43 1Q26 1 26 10Q26 12 29 24Q34 43 39 45Q42 46 54 46H60Q120 46 136 53Q137 53 138 54Q143 56 149 77T198 273Q210 318 216 344Q286 624 286 626Q284 630 284 631Q274 637 213 637H193Q184 643 189 662Q193 677 195 680T209 683H213Q285 681 359 681Q481 681 487 683H497Q504 676 504 672T501 655T494 639Q491 637 471 637Q440 637 407 634Q393 631 388 623Q381 609 337 432Q326 385 315 341Q245 65 245 59Q245 52 255 50T307 46H339Q345 38 345 37T342 19Q338 6 332 0H316Q279 2 179 2Q143 2 113 2T65 2T43 1Z"></path></g><g data-mml-node="mn" transform="translate(473,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></g></svg></mjx-container>)，可以执行任务2的计算(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.339ex" xmlns="http://www.w3.org/2000/svg" width="2.605ex" height="1.934ex" role="img" focusable="false" viewBox="0 -705 1151.6 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mn" transform="translate(748,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg></mjx-container>)和任务1的打印操作(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.339ex" xmlns="http://www.w3.org/2000/svg" width="2.44ex" height="1.885ex" role="img" focusable="false" viewBox="0 -683 1078.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mn" transform="translate(675,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container>)。</p><p><img src="http://tva1.sinaimg.cn/large/bda5cd74ly1g2h85n3imgj20rm0d8423.jpg" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="CPU并发工作的前趋图"></p><p><strong>并行（Parallel）</strong>是由于有多核处理器，有多套处理设备，它可以<strong>真正的同时</strong>处理多个任务。</p><p>比如下面这个前趋图中，有4个处理机的CPU，在一号处理机处理一号任务输入的同时(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.339ex" xmlns="http://www.w3.org/2000/svg" width="1.983ex" height="1.885ex" role="img" focusable="false" viewBox="0 -683 876.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D43C" d="M43 1Q26 1 26 10Q26 12 29 24Q34 43 39 45Q42 46 54 46H60Q120 46 136 53Q137 53 138 54Q143 56 149 77T198 273Q210 318 216 344Q286 624 286 626Q284 630 284 631Q274 637 213 637H193Q184 643 189 662Q193 677 195 680T209 683H213Q285 681 359 681Q481 681 487 683H497Q504 676 504 672T501 655T494 639Q491 637 471 637Q440 637 407 634Q393 631 388 623Q381 609 337 432Q326 385 315 341Q245 65 245 59Q245 52 255 50T307 46H339Q345 38 345 37T342 19Q338 6 332 0H316Q279 2 179 2Q143 2 113 2T65 2T43 1Z"></path></g><g data-mml-node="mn" transform="translate(473,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container>)，二号处理机可以处理二号任务的输入(<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align:-.339ex" xmlns="http://www.w3.org/2000/svg" width="1.983ex" height="1.885ex" role="img" focusable="false" viewBox="0 -683 876.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D43C" d="M43 1Q26 1 26 10Q26 12 29 24Q34 43 39 45Q42 46 54 46H60Q120 46 136 53Q137 53 138 54Q143 56 149 77T198 273Q210 318 216 344Q286 624 286 626Q284 630 284 631Q274 637 213 637H193Q184 643 189 662Q193 677 195 680T209 683H213Q285 681 359 681Q481 681 487 683H497Q504 676 504 672T501 655T494 639Q491 637 471 637Q440 637 407 634Q393 631 388 623Q381 609 337 432Q326 385 315 341Q245 65 245 59Q245 52 255 50T307 46H339Q345 38 345 37T342 19Q338 6 332 0H316Q279 2 179 2Q143 2 113 2T65 2T43 1Z"></path></g><g data-mml-node="mn" transform="translate(473,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg></mjx-container>)…</p><p><img src="http://tva1.sinaimg.cn/large/bda5cd74ly1g2h862ck7vj20ic0cs3yh.jpg" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="多核CPU并行的前趋图"></p><p>而且多核处理器的每个处理机又可以使用流水线并发处理多个任务，这就大大加强了计算机系统的处理能力。</p><h2>3、Thread类</h2><p>Java是纯面向对象的语言，所以线程也有与之对应的类——Thread。</p><h3>3.1、Java中创建线程的两种方式</h3><p>创建线程必须提供在该线程运行的代码，这在Java中有两种方式实现。</p><ol><li><p>实现Runnable接口。</p><p>Runnable接口代表了线程中可执行的任务，在Runnable接口中只有一个方法：<code>run()</code>。实现这个接口的<code>run()</code>方法，并创建这个对象，作为参数交给Thread处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>{</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">HelloRunnable</span>()).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li><p>继承Thread类，重写run方法。</p><p>Thread类本身就实现了Runnable对象，但它的<code>run</code>方法只检查执行代理的runnable对象的<code>run</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread类默认的run方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 代理了target的run方法</span></span><br><span class="line">        target.run();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>我们可以继承Thread类，重写它的<code>run</code>方法，来提供执行任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>{</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HelloThread</span>().start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li></ol><h3>3.2、应该使用哪种方式创建线程呢？</h3><p>因为Java是单继承的，如果使用第二种方式重写run方法，那么意味着你就不能继承其他的类来扩展类的功能了。而如果使用第一种方式实现Runnable接口，对你的类没有什么影响，你想继承哪个类就继承哪个类，想继续实现哪个接口可以继续实现。</p><p>所以一般使用实现Runnable接口的方式来创建线程。</p><h1>4、Thread类的相关方法与线程的状态</h1><p>先来看一张神图：</p><p><img src="http://tva1.sinaimg.cn/large/bda5cd74ly1g2h885pwmlj20qo0l140e.jpg" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="java线程的生命周期"></p><p>上面这张图中涉及到了<code>Object.wait</code>和<code>Object.notify</code>这一对方法，这个放在<a target="_blank" rel="noopener" href="http://blog.csdn.net/holmofy/article/details/76553437">生产者与消费者</a>中讨论，我们先把Thread类中的常用方法解决掉！</p><p>Thread类和所有类一样有两种方法：类静态方法，实例成员方法(加了删除线的方法表示已经被弃用的方法)。</p><ul><li>静态方法都是在本线程中执行，如：sleep()，yield()，interrupted()。</li><li>实例成员方法可以在其他线程执行，当然也可以在本线程中执行(但通常由其他线程调用)，如：interrupt()， join()， <del>destroy()</del>， <del>resume()</del>， <del>stop()</del>， <del>suspend()</del> 。</li></ul><h3>4.1、暂停执行与sleep方法</h3><p><code>Thread.sleep</code>方法会导致当前线程在指定的时间内暂停执行，这使得处理器可以处理其他的线程任务。</p><p><code>sleep</code>方法有两个重载版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 精确到毫秒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 精确到纳秒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span></span><br></pre></td></tr></table></figure><p>但实际上这个纳秒级的睡眠时间是无法精确的，因为它受到底层操作系统的限制(实际上还是调用C语言层面的sleep方法)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 四舍五入操作</span></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) {</span><br><span class="line">        millis++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    sleep(millis);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>另外调用<code>sleep</code>方法后的睡眠阶段可以调用<code>interrupt</code>方法来中断线程，这时<code>sleep</code>方法会抛出<code>InterruptedException</code>的异常(下面的线程中断机制会讲到)。所以我们调用<code>Thread.sleep</code>方法时经常要用<code>try catch</code>包裹。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>{</span><br><span class="line">	Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">}<span class="keyword">catch</span>(InterruptedException e){</span><br><span class="line">	...</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3>4.2、sleep与被弃用的suspend的区别</h3><p><code>Thread.suspend</code>方法也是暂停本线程的执行，会导致线程的挂起，<code>Thread.suspend</code>挂起必须要<code>Thread.resume</code>方法来唤醒。而<code>Thread.sleep</code>方法是定时挂起，它会在一段时间后自动还原成就绪态。而且使用<code>Thread.suspend</code>和<code>Thread.resume</code>方法非常容易造成死锁，因为<code>Thread.suspend</code>和<code>Thread.sleep</code>方法一样不会释放已经获取的锁。而后面要讲到的<code>Object.wait</code>方法在挂起后会释放锁。这也是<code>Thread.suspend</code>和<code>Thread.resume</code>方法被弃用的原因。</p><h3>4.3、线程中断机制</h3><p>通常我们会使用一个标志位来控制线程的终止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptTest</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">        <span class="type">boolean</span> stoped;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"Thread start at "</span> + start);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">while</span> (!stoped) {</span><br><span class="line">                    System.out.println(<span class="string">"sleep..."</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1600</span>);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) { }</span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"Thread finish at "</span> + end);</span><br><span class="line">            System.out.println(<span class="string">"Thread execute for "</span> + (end - start));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        child.start();</span><br><span class="line">        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        task.stoped = <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread start at 1502876260431</span><br><span class="line">sleep...</span><br><span class="line">sleep...</span><br><span class="line">sleep...</span><br><span class="line">Thread finish at 1502876265234</span><br><span class="line">Thread execute for 4803    # 执行时间超过4000毫秒</span><br></pre></td></tr></table></figure><p>可以看出这种方式有个小问题，如果while循环中有<code>Thread.sleep</code>这样的阻塞方法，那么这个线程必须等到该方法返回后才能终止，所以这种自定义标志位的方法有时候并不能达到立马终止线程的目的。</p><p>Thread类在底层已经提供了一个类似的标志——中断标志，我们可以通过以下三个方法来对中断标志位进行操作。</p><table><thead><tr><th align="center">方法</th><th align="center">方法描述</th></tr></thead><tbody><tr><td align="center">public static boolean interrupted()</td><td align="center">测试当前线程是否已经中断，线程的中断状态由该方法清除。<br>换句话说，如果连续两次调用该方法，则第二次调用将返回false。</td></tr><tr><td align="center">public boolean isInterrupted()</td><td align="center">测试线程是否已经中断。线程的中断状态不受该方法的影响。</td></tr><tr><td align="center">public void interrupt()</td><td align="center">中断线程。</td></tr></tbody></table><p>前两个方法区别在于会不会清除中断状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除中断状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 不清除中断状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;</span><br></pre></td></tr></table></figure><p>第二个方法一般由其他线程调用，该方法会将中断标志设为<code>true</code>。</p><p>如果调用<code>interrupt</code>方法时，线程正阻塞在某些阻塞方法时，这些阻塞方法将会立即抛出InterruptedException异常，并将中断状态清空(置为<code>false</code>)，这些方法包括前面提到的<code>Thread.sleep</code>还有后面要讲到的<code>Thread.join</code>和<code>Object.wait</code>等方法。</p><p>来个例子演示一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.hff.functor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptTest</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"Thread start at "</span> + start);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.println(<span class="string">"start doing something"</span>);</span><br><span class="line">                <span class="keyword">while</span> (!Thread.interrupted()) {</span><br><span class="line">                    System.out.println(<span class="string">"sleep..."</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1600</span>); <span class="comment">// 中断后直接退出该方法</span></span><br><span class="line">                }</span><br><span class="line">                System.out.println(<span class="string">"finish something"</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                System.out.println(<span class="string">"Thread interrupt"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"Thread finish at "</span> + end);</span><br><span class="line">            System.out.println(<span class="string">"Thread execute for "</span> + (end - start));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        child.start();</span><br><span class="line">        Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        child.interrupt();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread start at 1502876450763</span><br><span class="line">start doing something</span><br><span class="line">sleep...</span><br><span class="line">sleep...</span><br><span class="line">sleep...</span><br><span class="line">Thread interrupt    # 中断后finish something不会打印</span><br><span class="line">Thread finish at 1502876454764</span><br><span class="line">Thread execute for 4001  # 基本能在4000毫秒后结束</span><br></pre></td></tr></table></figure><p>如果Thread.sleep的异常在while循环内捕捉的话，还需要调用一次interrupt。因为<code>Thread.sleep</code>抛出异常时，中断标志为false。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">	System.out.println(<span class="string">"Thread start"</span>);</span><br><span class="line">	<span class="keyword">while</span> (!Thread.interrupted()) {</span><br><span class="line">		<span class="keyword">try</span> {</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		} <span class="keyword">catch</span> (InterruptedException e) {   <span class="comment">// 当我们捕获异常时中断标志位已经为false</span></span><br><span class="line">			System.out.println(<span class="string">"Thread interrupt"</span>);</span><br><span class="line">			Thread.currentThread().interrupt();<span class="comment">// 还原中断标志位</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	System.out.println(<span class="string">"Thread finish"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><blockquote><p>Java的中断机制让程序有更高的响应性，但需要我们正确理解的是，它并不会真正地中断一个正在运行的线程，只是发出中断请求，然后由线程自己在何时的时刻中断自己，这样的好处是线程能在结束任务前进行相应的收尾工作，比如关闭文件释放资源等。</p><p>Java的中断机制<a target="_blank" rel="noopener" href="https://www.yegor256.com/2015/10/20/interrupted-exception.html">令初学者非常反感</a>，因为每次都try_catch会令代码不整洁，而且我们还不能简单的try_catch吞掉异常就不管了，还需要把异常标志位设回去，Guava提供了一个简单处理阻塞方法的工具类——<a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/util/concurrent/Uninterruptibles.java">Uninterruptibles</a></p></blockquote><h3>4.4、join方法</h3><p>thread.join把指定的线程加入到当前线程来执行。你可以用“并线(join)”这个词来进行理解：让调用该方法的线程等待thread线程执行完。</p><p><img src="http://tva1.sinaimg.cn/large/bda5cd74ly1g2h88w76uoj20pq0gowfi.jpg" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="Thread.join"></p><p>和sleep方法一样，这个方法会也会抛出InterruptedException中断异常。</p><h3>4.5、Java守护线程和setDaemon方法</h3><p>看到“守护线程”这个概念，你可能会联想到Linux中的守护进程。Java程序由于运行在虚拟机上，虚拟机一般作为一个进程运行的，所以这里所说的守护线程和Linux中说的守护进程没什么关系，但在概念上也有很多与之类似的地方。</p><p><strong>如果一个程序主线程结束了，但还有非守护线程没有结束，那主线程会等待非守护线程的结束。</strong></p><p><strong>如果一个程序主线程结束了，非守护线程也结束了，但还有守护线程没有结束，主线程不会等待守护线程。</strong></p><p>Java里面最典型的守护线程就是垃圾回收线程(GC，garbage collector)。</p><p>我们先来写一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> {</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(String msg)</span> {</span><br><span class="line">		<span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">		System.out.println(threadName + <span class="string">": "</span> + msg);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">				<span class="keyword">try</span> { Thread.sleep(<span class="number">500</span>); } <span class="keyword">catch</span> (InterruptedException e) {}</span><br><span class="line">				printMessage(<span class="string">"loop"</span> + i);</span><br><span class="line">			}</span><br><span class="line">			printMessage(<span class="string">"finish!"</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">		thread.start();</span><br><span class="line">		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		printMessage(<span class="string">"finish!"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread-0: loop0</span><br><span class="line">Thread-0: loop1</span><br><span class="line">main: finish!</span><br><span class="line">Thread-0: loop2</span><br><span class="line">Thread-0: loop3</span><br><span class="line">Thread-0: loop4</span><br><span class="line">Thread-0: loop5</span><br><span class="line">Thread-0: loop6</span><br><span class="line">Thread-0: loop7</span><br><span class="line">Thread-0: loop8</span><br><span class="line">Thread-0: loop9</span><br><span class="line">Thread-0: finish!</span><br></pre></td></tr></table></figure><blockquote><p>你会发现主线程已经结束了但它还在等待子线程的执行。</p></blockquote><p>而如果我们添加<code>setDaemon(true)</code>后再执行一次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">	<span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">	thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">	thread.start();</span><br><span class="line">	Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">	printMessage(<span class="string">"finish!"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>: loop0</span><br><span class="line">Thread-<span class="number">0</span>: loop1</span><br><span class="line">main: finish!</span><br></pre></td></tr></table></figure><blockquote><p>子线程后面的循环将不会执行。这就是守护线程与非守护线程的区别。</p></blockquote><p>需要注意：<code>thread.setDaemon()</code>方法必须要在<code>thread.start()</code>之前调用，否则将会报IllegalThreadStateException异常。可以看一下setDaemon的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setDaemon</span><span class="params">(<span class="type">boolean</span> on)</span> {</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (isAlive()) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">    }</span><br><span class="line">    daemon = on;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>另外我们可以手动调用<code>Thread.join</code>方法，让主线程等待守护子线程的执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">	<span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>());</span><br><span class="line">	thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">	thread.start();</span><br><span class="line">	Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">	printMessage(<span class="string">"finish!"</span>);</span><br><span class="line">	thread.join(); <span class="comment">// 让主线程等待守护线程的执行</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2>5、总结性的小例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleThreads</span> {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(String message)</span> {</span><br><span class="line">		<span class="type">String</span> <span class="variable">threadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">		System.out.format(<span class="string">"%s: %s%n"</span>, threadName, message);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MessageLoop</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">		String messages[] = {</span><br><span class="line">				<span class="string">"message1"</span>, <span class="string">"message2"</span>, <span class="string">"message3"</span>, <span class="string">"message4"</span></span><br><span class="line">		};</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">			<span class="keyword">try</span> {</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; messages.length; i++) {</span><br><span class="line">					Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">					printMessage(messages[i]);</span><br><span class="line">				}</span><br><span class="line">			} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">				printMessage(<span class="string">"我还没干完呢!"</span>);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">		<span class="type">long</span> <span class="variable">patience</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">		<span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		printMessage(<span class="string">"开始启动MessageLoop线程"</span>);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MessageLoop</span>());</span><br><span class="line">		t.start();</span><br><span class="line"></span><br><span class="line">		printMessage(<span class="string">"开始等待MessageLoop线程的完成"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">long</span> <span class="variable">interval</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (t.isAlive()) {</span><br><span class="line">			<span class="comment">// 最多等MessageLoop线程1秒钟</span></span><br><span class="line">			t.join(<span class="number">1000</span>);</span><br><span class="line">			interval = System.currentTimeMillis() - startTime;</span><br><span class="line">			<span class="keyword">if</span> ((interval &gt; patience) &amp;&amp; t.isAlive()) {</span><br><span class="line">				printMessage(<span class="string">"不想再等你了!"</span>);</span><br><span class="line">				t.interrupt();</span><br><span class="line">				<span class="comment">// 不用等太久</span></span><br><span class="line">				t.join();</span><br><span class="line">			} <span class="keyword">else</span> {</span><br><span class="line">				printMessage(<span class="string">"我已经等了"</span> + interval + <span class="string">"毫秒了..."</span>);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		printMessage(<span class="string">"已经结束了!"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>参考链接：</p><p>《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/10484692/">Java并发编程实战</a>》</p><p><a target="_blank" rel="noopener" href="https://www.baeldung.com/java-process-api">https://www.baeldung.com/java-process-api</a></p><p><a target="_blank" rel="noopener" href="https://www.yegor256.com/2015/10/20/interrupted-exception.html">https://www.yegor256.com/2015/10/20/interrupted-exception.html</a></p></div><div class="article-copyright"><p>本作品采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> 进行许可。</p><p>转载时请注明<a href="https://blog.hufeifei.cn/2017/06/Java/multithread/01-Thread-Basic/">原文链接</a>：https://blog.hufeifei.cn/2017/06/Java/multithread/01-Thread-Basic/</p></div><footer class="article-footer"></footer></div><div id="article-reward"><i class="iconfont ic-money"></i><div>鼓励一下</div><table><thead><tr><th style="text-align:center">支付宝</th><th style="text-align:center">微信</th></tr></thead><tbody><tr><td style="text-align:center"><img width="150" src="https://www.hufeifei.cn/reward-img/alipay.jpg"></td><td style="text-align:center"><img width="135" src="https://www.hufeifei.cn/reward-img/wechat.jpg"></td></tr></tbody></table></div><nav id="article-nav"><a class="article-nav-link-wrap" href="/2017/06/Java/multithread/02-Thread-Utility/" id="article-nav-newer"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">Java多线程复习与巩固（二）--线程相关工具类的使用</div></a><a class="article-nav-link-wrap" href="/2017/06/DataStructure/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%89%E5%85%A8%E7%AE%97%E6%B3%95--%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" id="article-nav-older"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">密码学安全算法--对称加密算法</div></a></nav></article><div id="waline-comments"></div><script type="module">import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js';init({"el":"#waline-comments","pageview":true,"enable":true,"serverURL":"https://api.waline.blog.hufeifei.cn","avatar":"mp","pageSize":10,"lang":"zh-cn","placeholder":"Just go go","visitor":true,"recordIP":true,"requiredFields":["nick"]});</script></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">关注微信公众号</h3><div class="widget wechat"><img src="//www.hufeifei.cn/wechat-public-account.jpg"></div></div><div class="widget-wrap"><h3 class="widget-title">Categories</h3><div class="widget"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C&C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/J2EE/">J2EE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux%E8%BF%90%E7%BB%B4/">Linux运维</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby/">Ruby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rust/">Rust</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%A3%E7%A0%81%E6%97%A5%E5%B8%B8/">代码日常</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%95%86%E4%B8%9A/">商业</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%8F%E6%B5%8E%E4%B8%8E%E9%87%91%E8%9E%8D/">经济与金融</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/">计算机组成</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Tag Cloud</h3><div class="widget tagcloud"><a href="/tags/AVL/" style="font-size:11.11px">AVL</a> <a href="/tags/Alibaba/" style="font-size:14.44px">Alibaba</a> <a href="/tags/Android/" style="font-size:18.89px">Android</a> <a href="/tags/B-Tree/" style="font-size:12.22px">B-Tree</a> <a href="/tags/BKD-Tree/" style="font-size:10px">BKD-Tree</a> <a href="/tags/BST/" style="font-size:10px">BST</a> <a href="/tags/BigData/" style="font-size:11.11px">BigData</a> <a href="/tags/C/" style="font-size:14.44px">C</a> <a href="/tags/CGlib/" style="font-size:10px">CGlib</a> <a href="/tags/CS/" style="font-size:11.11px">CS</a> <a href="/tags/Canal/" style="font-size:10px">Canal</a> <a href="/tags/ClassLoader/" style="font-size:10px">ClassLoader</a> <a href="/tags/ClickHouse/" style="font-size:10px">ClickHouse</a> <a href="/tags/Config/" style="font-size:10px">Config</a> <a href="/tags/Cryptography/" style="font-size:10px">Cryptography</a> <a href="/tags/DB/" style="font-size:20px">DB</a> <a href="/tags/Dapper/" style="font-size:10px">Dapper</a> <a href="/tags/DataStructure/" style="font-size:14.44px">DataStructure</a> <a href="/tags/Debezium/" style="font-size:10px">Debezium</a> <a href="/tags/Diamond/" style="font-size:10px">Diamond</a> <a href="/tags/Distributed/" style="font-size:13.33px">Distributed</a> <a href="/tags/ElasticSearch/" style="font-size:10px">ElasticSearch</a> <a href="/tags/Encoding/" style="font-size:10px">Encoding</a> <a href="/tags/FastJson/" style="font-size:10px">FastJson</a> <a href="/tags/File/" style="font-size:10px">File</a> <a href="/tags/FlowMarketing/" style="font-size:10px">FlowMarketing</a> <a href="/tags/Grade/" style="font-size:10px">Grade</a> <a href="/tags/Gson/" style="font-size:10px">Gson</a> <a href="/tags/HTTP/" style="font-size:10px">HTTP</a> <a href="/tags/Handler/" style="font-size:10px">Handler</a> <a href="/tags/Hanlder/" style="font-size:10px">Hanlder</a> <a href="/tags/Hessian/" style="font-size:10px">Hessian</a> <a href="/tags/IO-Multiplex/" style="font-size:10px">IO-Multiplex</a> <a href="/tags/JAVA/" style="font-size:18.89px">JAVA</a> <a href="/tags/JVM/" style="font-size:10px">JVM</a> <a href="/tags/KD-Tree/" style="font-size:10px">KD-Tree</a> <a href="/tags/KDB-Tree/" style="font-size:10px">KDB-Tree</a> <a href="/tags/Kafka/" style="font-size:10px">Kafka</a> <a href="/tags/Kubernetes/" style="font-size:10px">Kubernetes</a> <a href="/tags/LSM-Tree/" style="font-size:11.11px">LSM-Tree</a> <a href="/tags/Linux/" style="font-size:17.78px">Linux</a> <a href="/tags/Lock/" style="font-size:11.11px">Lock</a> <a href="/tags/Lucene/" style="font-size:10px">Lucene</a> <a href="/tags/MQ/" style="font-size:10px">MQ</a> <a href="/tags/Macro/" style="font-size:10px">Macro</a> <a href="/tags/Magisk/" style="font-size:10px">Magisk</a> <a href="/tags/MultiDex/" style="font-size:10px">MultiDex</a> <a href="/tags/MySQL/" style="font-size:17.78px">MySQL</a> <a href="/tags/NIO/" style="font-size:10px">NIO</a> <a href="/tags/Nginx/" style="font-size:11.11px">Nginx</a> <a href="/tags/OGNL/" style="font-size:10px">OGNL</a> <a href="/tags/OpenResty/" style="font-size:10px">OpenResty</a> <a href="/tags/OpenTelemetry/" style="font-size:10px">OpenTelemetry</a> <a href="/tags/Oracle/" style="font-size:10px">Oracle</a> <a href="/tags/PostgreSQL/" style="font-size:10px">PostgreSQL</a> <a href="/tags/RB-Tree/" style="font-size:10px">RB-Tree</a> <a href="/tags/Redis/" style="font-size:10px">Redis</a> <a href="/tags/Rust/" style="font-size:10px">Rust</a> <a href="/tags/Sharding/" style="font-size:10px">Sharding</a> <a href="/tags/SpringBoot/" style="font-size:10px">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size:10px">SpringCloud</a> <a href="/tags/SpringCloudConfig/" style="font-size:10px">SpringCloudConfig</a> <a href="/tags/Sqlite/" style="font-size:10px">Sqlite</a> <a href="/tags/SurfaceView/" style="font-size:10px">SurfaceView</a> <a href="/tags/VSCode/" style="font-size:11.11px">VSCode</a> <a href="/tags/WebFlux/" style="font-size:10px">WebFlux</a> <a href="/tags/WebPush/" style="font-size:10px">WebPush</a> <a href="/tags/Web%E6%8C%96%E6%8E%98/" style="font-size:11.11px">Web挖掘</a> <a href="/tags/awk/" style="font-size:10px">awk</a> <a href="/tags/bit-hack/" style="font-size:10px">bit-hack</a> <a href="/tags/cheat-sheet/" style="font-size:10px">cheat sheet</a> <a href="/tags/curl/" style="font-size:10px">curl</a> <a href="/tags/epoll/" style="font-size:10px">epoll</a> <a href="/tags/gRPC/" style="font-size:10px">gRPC</a> <a href="/tags/grep/" style="font-size:10px">grep</a> <a href="/tags/kqueue/" style="font-size:10px">kqueue</a> <a href="/tags/libev/" style="font-size:10px">libev</a> <a href="/tags/libevent/" style="font-size:10px">libevent</a> <a href="/tags/libuv/" style="font-size:10px">libuv</a> <a href="/tags/metaq/" style="font-size:10px">metaq</a> <a href="/tags/poll/" style="font-size:10px">poll</a> <a href="/tags/sed/" style="font-size:10px">sed</a> <a href="/tags/select/" style="font-size:10px">select</a> <a href="/tags/ssh/" style="font-size:10px">ssh</a> <a href="/tags/%E5%8E%86%E5%8F%B2/" style="font-size:10px">历史</a> <a href="/tags/%E5%95%86%E4%B8%9A/" style="font-size:10px">商业</a> <a href="/tags/%E5%BF%83%E7%90%86%E5%AD%A6/" style="font-size:10px">心理学</a> <a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size:11.11px">生活</a> <a href="/tags/%E7%A8%8E%E6%94%B6/" style="font-size:10px">税收</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size:14.44px">算法</a> <a href="/tags/%E7%BB%8F%E6%B5%8E/" style="font-size:15.56px">经济</a> <a href="/tags/%E8%90%A5%E9%94%80/" style="font-size:10px">营销</a> <a href="/tags/%E8%B4%A7%E5%B8%81/" style="font-size:10px">货币</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size:16.67px">随笔</a></div></div><div class="widget-wrap"><h3 class="widget-title">Recent Posts</h3><div class="widget"><ul><li><a href="/2024/04/economic/value-added-tax/">增值税与贫富差距</a></li><li><a href="/2024/01/Net/x-forward-for/">“真”的IP真的是真的吗？</a></li><li><a href="/2024/01/paper/MarkupLM-web-extract/">【译】基于MarkupLM的web数据抽取</a></li><li><a href="/2023/09/economic/tax-reform/">直接税改革——王朝周期律的胜负手</a></li><li><a href="/2023/09/Rust/macro-rules-learning/">Rust中的宏</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">网站运营不易</h3><div class="ads-wrapper"><div class="google_ads"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7111912103882824" data-ad-slot="8429272980" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div></div></aside></div><footer id="footer"><div class="outer"><div class="inner" id="footer-info"><p><a href="https://beian.miit.gov.cn/" target="_blank">赣ICP备17009276号</a><i class="far fa-copyright"></i>2016 ~ 2024 胡飞飞</p><p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a><i class="fas fa-angle-right"></i>Theme by <a target="_blank" rel="noopener" href="https://github.com/holmofy/hexo-theme-paper">paper</a></p></div></div></footer></div><nav id="mobile-nav"><a class="mobile-nav-link" href="//www.hufeifei.cn">主页</a><a class="mobile-nav-link" href="/">博客</a><a class="mobile-nav-link" href="/archives">归档</a><a class="mobile-nav-link" target="_blank" rel="noopener" href="//algo.hufeifei.cn">算法</a><a class="mobile-nav-link" href="/book">书籍</a><a class="mobile-nav-link" href="/github">Github</a></nav><script src="//cdnjs.loli.net/ajax/libs/jquery/3.0.0/jquery.min.js"></script><link rel="stylesheet" href="//cdnjs.loli.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="//cdnjs.loli.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/script.js"></script></div><script>
  $(document).ready(function() {
    $('figure.codeblock').find('.tab').click(function() {
        var $codeblock = $(this).parent().parent().parent();
        var $tab = $(this);
        // remove "active" css class on all tabs
        $tab.siblings().removeClass('active');
        // add "active" css class on the clicked tab
        $tab.addClass('active');
        // hide all tab contents
        $codeblock.find('.highlight').hide();
        // show only the right one
        $codeblock.find('.highlight.' + $tab.text()).show();
    });
  });
  </script><script>(function (w, d, s, id) {
            if (typeof (w.webpushr) !== 'undefined') return; w.webpushr = w.webpushr || function () { (w.webpushr.q = w.webpushr.q || []).push(arguments) }; var js, fjs = d.getElementsByTagName(s)[0]; js = d.createElement(s); js.id = id; js.async = 1; js.src = "https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window, document, 'script', 'webpushr-jssdk'));webpushr('setup', { 'key': 'BPJzNs1QEtbYa3Bn0gMAQHBAzX3Jm71llGUKHTkKEUs3D9xiDYZ0DWJ3S9sfCAAJHxXEoBkUANFyONjeIlgrJUo'' });</script></body></html>