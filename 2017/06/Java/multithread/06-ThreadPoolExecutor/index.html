<!doctype html><html lang="en"><head><meta charset="utf-8"><script async src="https://www.googletagmanager.com/gtag/js?id=G-H58NSPXYPF"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-H58NSPXYPF")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?b3392fb5f6d65fb10354f590338d1ee4",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,a,i){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/95vxjpui4h",(i=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,i)}(window,document,"clarity","script")</script><title>Java多线程复习与巩固（六）--线程池ThreadPoolExecutor详解 | holmofy</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="baidu_union_verify" content="b7d27ec946758934fcdf3c5c26386237"><meta description="系列文章：  Java多线程复习与巩固（一）–线程基本使用 Java多线程复习与巩固（二）–线程相关工具类的使用 Java多线程复习与巩固（三）–线程同步 Java多线程复习与巩固（四）–synchronized的实现 Java多线程复习与巩固（五）–生产者消费者问题（第一部分） Java多线程复习与巩固（六）–线程池ThreadPoolExecutor详解 Java多线程复习与巩固（七）–任务调"><meta property="og:type" content="article"><meta property="og:title" content="Java多线程复习与巩固（六）--线程池ThreadPoolExecutor详解"><meta property="og:url" content="https://blog.hufeifei.cn/2017/06/Java/multithread/06-ThreadPoolExecutor/index.html"><meta property="og:site_name" content="holmofy"><link rel="canonical" href="https://blog.hufeifei.cn/2017/06/Java/multithread/06-ThreadPoolExecutor/index.html"><meta property="description" content="系列文章：  Java多线程复习与巩固（一）–线程基本使用 Java多线程复习与巩固（二）–线程相关工具类的使用 Java多线程复习与巩固（三）–线程同步 Java多线程复习与巩固（四）–synchronized的实现 Java多线程复习与巩固（五）–生产者消费者问题（第一部分） Java多线程复习与巩固（六）–线程池ThreadPoolExecutor详解 Java多线程复习与巩固（七）–任务调"><meta name="description" content="系列文章：  Java多线程复习与巩固（一）–线程基本使用 Java多线程复习与巩固（二）–线程相关工具类的使用 Java多线程复习与巩固（三）–线程同步 Java多线程复习与巩固（四）–synchronized的实现 Java多线程复习与巩固（五）–生产者消费者问题（第一部分） Java多线程复习与巩固（六）–线程池ThreadPoolExecutor详解 Java多线程复习与巩固（七）–任务调"><meta property="og:description" content="系列文章：  Java多线程复习与巩固（一）–线程基本使用 Java多线程复习与巩固（二）–线程相关工具类的使用 Java多线程复习与巩固（三）–线程同步 Java多线程复习与巩固（四）–synchronized的实现 Java多线程复习与巩固（五）–生产者消费者问题（第一部分） Java多线程复习与巩固（六）–线程池ThreadPoolExecutor详解 Java多线程复习与巩固（七）–任务调"><meta property="article:published_time" content="2017-06-18T16:00:00.000Z"><meta property="article:modified_time" content="2024-05-03T05:17:06.699Z"><meta property="article:author" content="胡飞飞"><meta property="article:tag" content="Java 多线程编程"><meta property="keywords" content="Java 多线程编程"><meta property="twitter:card" content="summary"><script data-ad-client="ca-pub-7111912103882824" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7111912103882824" crossorigin="anonymous"></script><script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js"></script><script type="text/javascript" src="//cpro.baidustatic.com/cpro/ui/cm.js" async defer></script><link rel="alternate" href="/atom.xml" title="holmofy" type="application/atom+xml"><link rel="icon" href="//www.hufeifei.cn/favicon.jpg"><link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"><link href="//unpkg.com/@waline/client@v3/dist/waline.css" rel="stylesheet" type="text/css"><link href="//at.alicdn.com/t/font_841402_efkj8jo1xld.css" rel="stylesheet" type="text/css"><link rel="stylesheet" href="//cdnjs.loli.net/ajax/libs/font-awesome/5.15.3/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/style.css"><link rel="dns-prefetch" href="//static.zhimg.com"><link rel="dns-prefetch" href="//at.alicdn.com"><link rel="dns-prefetch" href="//cdn.jsdelivr.net"><link rel="dns-prefetch" href="//img-blog.csdn.net"><link rel="dns-prefetch" href="//img-blog.csdnimg.cn"><meta name="generator" content="Hexo 6.3.0"><link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml"><style>
    figure.codeblock {
       margin: 0;
    }
    figure figcaption .tabs {
      display: flex;
      margin: 0;
    }
    figure figcaption .tabs .tab {
      cursor: pointer;
      list-style: none;
      padding: 5px 15px;
    }
    figure figcaption .tabs .tab.active {
      background: #2d2d2d;
      color: white;
    }
  </style></head><body><amp-auto-ads type="adsense" data-ad-client="ca-pub-7111912103882824"></amp-auto-ads><div id="container"><div id="wrap"><header id="header"><div class="outer" id="header-outer"><div class="inner" id="header-inner"><nav id="main-nav"><a class="nav-icon" id="main-nav-toggle"><i class="fas fa-bars"></i></a><a class="main-nav-link" href="//www.hufeifei.cn">主页</a><a class="main-nav-link" href="/">博客</a><a class="main-nav-link" href="/archives">归档</a><a class="main-nav-link" target="_blank" rel="noopener" href="//algo.hufeifei.cn">算法</a><a class="main-nav-link" href="/book">书籍</a><a class="main-nav-link" href="/github">Github</a></nav><nav id="sub-nav"><a class="nav-icon" id="nav-rss-link" href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a><a class="nav-icon" id="nav-search-btn" title="Search"><i class="fas fa-search"></i></a></nav><div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="fas fa-search"></i></button><input type="hidden" name="sitesearch" value="https://blog.hufeifei.cn"></form></div></div></div></header><div class="outer"><section id="main"><article class="article article-type-post" id="post-Java/multithread/06-ThreadPoolExecutor" itemscope itemprop="blogPost"><div class="article-meta"><a class="article-date" href="/2017/06/Java/multithread/06-ThreadPoolExecutor/"><time datetime="2017-06-18T16:00:00.000Z" itemprop="datePublished">2017-06-19</time></a><div class="article-category"><a class="article-category-link" href="/categories/JAVA/">JAVA</a></div><div class="article-views leancloud_visitors" id="/2017/06/Java/multithread/06-ThreadPoolExecutor/" data-flag-title="Java多线程复习与巩固（六）--线程池ThreadPoolExecutor详解" title="Views"><i class="fas fa-eye"></i><span class="waline-pageview-count" data-path="/2017/06/Java/multithread/06-ThreadPoolExecutor/"></span></div></div><div class="article-inner"><header class="article-header" style="text-align:center"><h1 class="article-title" itemprop="name">Java多线程复习与巩固（六）--线程池ThreadPoolExecutor详解</h1></header><div class="article-entry" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><strong>系列文章：</strong></p><ul><li><a href="https://blog.hufeifei.cn/2017/06/Java/multithread/01-Thread-Basic/">Java多线程复习与巩固（一）–线程基本使用</a></li><li><a href="https://blog.hufeifei.cn/2017/06/Java/multithread/02-Thread-Utility/">Java多线程复习与巩固（二）–线程相关工具类的使用</a></li><li><a href="https://blog.hufeifei.cn/2017/06/Java/multithread/03-Synchronized/">Java多线程复习与巩固（三）–线程同步</a></li><li><a href="https://blog.hufeifei.cn/2017/06/Java/multithread/04-Synchronized-Implement/">Java多线程复习与巩固（四）–synchronized的实现</a></li><li><a href="https://blog.hufeifei.cn/2017/06/Java/multithread/05-Provider-Consumer/">Java多线程复习与巩固（五）–生产者消费者问题（第一部分）</a></li><li><a href="https://blog.hufeifei.cn/2017/06/Java/multithread/06-ThreadPoolExecutor/">Java多线程复习与巩固（六）–线程池ThreadPoolExecutor详解</a></li><li><a href="https://blog.hufeifei.cn/2017/06/Java/multithread/07-ScheduledThreadPoolExecutor/">Java多线程复习与巩固（七）–任务调度线程池ScheduledThreadPoolExecutor</a></li><li><a href="https://blog.hufeifei.cn/2017/06/Java/multithread/08-Atomic/">Java多线程复习与巩固（八）–原子性操作与原子变量</a></li><li><a href="https://blog.hufeifei.cn/2017/06/Java/multithread/09-volatile-CAS/">Java多线程复习与巩固（九）–volatile关键字与CAS操作</a></li><li><a href="https://blog.hufeifei.cn/2018/07/Java/ThreadPoolExecutor-best-practice-thread-size/">ThreadPoolExecutor最佳实践–如何选择线程数</a></li><li><a href="https://blog.hufeifei.cn/2018/08/Java/ThreadPoolExecutor-best-practice-queue/">ThreadPoolExecutor最佳实践–如何选择队列</a></li></ul><hr><h2>1. 为什么要使用线程池</h2><p>线程创建与销毁都耗费时间，对于<strong>大量的短暂任务</strong>如果仍使用“创建-&gt;执行任务-&gt;销毁”的简单模式，将极大地降低线程的使用效率(一个线程仅仅处理一个短暂的任务就被销毁了)。在这种情况下，为了提高线程的使用效率，我们使用缓存池的策略让线程执行任务后不立即销毁而是等待着处理下一个任务。</p><h2>2. 使用Executors工具类创建线程池</h2><p>Executors是线程池框架提供给我们的创建线程池的工具类，它里面提供了以下创建几类线程池的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建固定线程数量的线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 创建单个线程的线程池(本质上就是容量为1的FixedThreadPool)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 创建无数量限制可自动增减线程的线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建(可计划的)任务延时执行线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 单线程版的任务计划执行的线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newSingleThreadScheduledExecutor</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>通过查看这几个方法的源码发现：前三个方法new了<code>ThreadPoolExecutor</code>对象，而后面两个方法new了<code>ScheduledThreadPoolExecutor</code>对象。</p><p>整个线程池框架的类继承图如下，其中ThreadPoolExecutor是本文的核心，<code>ScheduleThreadPoolExecutor</code>将放到后一篇文章中讲。</p><blockquote><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html">JDK文档</a>建议一般情况使用Executors去创建线程池</p></blockquote><p><img src="/2017/06/Java/multithread/06-ThreadPoolExecutor/ThreadPool.svg" alt="线程池ThreadPoolExecutor相关类继承图"></p><p>其中三个核心接口的方法如下：</p><p><img src="http://img-blog.csdn.net/20170819141127562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="三个核心接口的方法"></p><h2>3. 构造ThreadPoolExecutor对象</h2><p><code>java.util.concurrent.ThreadPoolExecutor</code> 类是线程池中最核心的类之一，因此如果要透彻地了解Java中的线程池，必须先了解这个类。下面分析一下ThreadPoolExecutor类的核心源码的具体实现。</p><p>在ThreadPoolExecutor类中提供了四个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractExecutorService</span> &#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">        <span class="comment">//代码省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　从上面的代码可以得知，ThreadPoolExecutor继承了AbstractExecutorService(实现ExecutorService接口)类，并提供了四个构造器，前三个构造器最终都会辗转调用第四个构造器。</p><p>下面解释一下第四个构造器中各个参数的含义：</p><ul><li><p>corePoolSize：核心池的大小。</p><ul><li>核心池中的线程会一致保存在线程池中(即使线程空闲)，除非调用<code>allowCoreThreadTimeOut</code>方法允许核心线程在空闲后一定时间内销毁，该时间由构造方法中的<code>keepAliveTime</code>和<code>unit</code>参数指定；</li><li>在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了<code>prestartAllCoreThreads()</code>或者<code>prestartCoreThread()</code>方法，从这两个方法的名字就可以看出，是<strong>“预创建线程”</strong>的意思，即在没有任务到来之前就创建corePoolSize个线程(prestartAllCoreThreads)或者一个线程(prestartCoreThread)；</li></ul></li><li><p>maximumPoolSize：线程池允许的最大线程数。这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程。</p><ul><li><p>默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，<strong>当线程池中的线程数目达到corePoolSize后，就会把新加入的任务放到缓存队列当中</strong>，缓存队列由构造方法中的<code>workQueue</code>参数指定，<strong>如果入队失败(队列已满)则尝试创建临时线程</strong>，但临时线程和核心线程的总数不能超过maximumPoolSize，<strong>当线程总数达到maximumPoolSize后会拒绝新任务</strong>；所以有两种方式可以让任务绝不被拒绝：</p><p>① 将maximumPoolSize设置为<code>Integer.MAX_VALUE</code>(线程数不可能达到这个值)，<code>CachedThreadPool</code>就是这么做的；</p><p>② 使用无限容量的阻塞队列(比如LinkedBlockingQueue)，所有处理不过来的任务全部排队去，<code>FixedThreadPool</code>就是这么做的。</p></li></ul></li><li><p>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。</p><ul><li>默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用——当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会被销毁，直到线程池中的线程数不超过corePoolSize。但是如果调用了<code>allowCoreThreadTimeOut(true)</code>方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；</li></ul></li><li><p>unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TimeUnit.DAYS;              <span class="comment">//天</span></span><br><span class="line">TimeUnit.HOURS;             <span class="comment">//小时</span></span><br><span class="line">TimeUnit.MINUTES;           <span class="comment">//分钟</span></span><br><span class="line">TimeUnit.SECONDS;           <span class="comment">//秒</span></span><br><span class="line">TimeUnit.MILLISECONDS;      <span class="comment">//毫秒</span></span><br><span class="line">TimeUnit.MICROSECONDS;      <span class="comment">//微妙</span></span><br><span class="line">TimeUnit.NANOSECONDS;       <span class="comment">//纳秒</span></span><br></pre></td></tr></table></figure><blockquote><p>并发库中所有时间表示方法都是以<code>TimeUnit</code>枚举类作为单位</p></blockquote></li><li><p>workQueue：一个阻塞队列(BlockingQueue接口的实现类)，用来存储等待执行的任务，一般来说，这里的阻塞队列有以下几种选择：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue    <span class="comment">// 数组实现的阻塞队列，数组不支持自动扩容。所以当阻塞队列已满</span></span><br><span class="line">                      <span class="comment">// 线程池会根据handler参数中指定的拒绝任务的策略决定如何处理后面加入的任务</span></span><br><span class="line"></span><br><span class="line">LinkedBlockingQueue   <span class="comment">// 链表实现的阻塞队列，默认容量Integer.MAX_VALUE(不限容)，</span></span><br><span class="line">                      <span class="comment">// 当然也可以通过构造方法限制容量</span></span><br><span class="line"></span><br><span class="line">SynchronousQueue      <span class="comment">// 零容量的同步阻塞队列，添加任务直到有线程接受该任务才返回</span></span><br><span class="line">                      <span class="comment">// 用于实现生产者与消费者的同步，所以被叫做同步队列</span></span><br><span class="line"></span><br><span class="line">PriorityBlockingQueue <span class="comment">// 二叉堆实现的优先级阻塞队列</span></span><br><span class="line"></span><br><span class="line">DelayQueue          <span class="comment">// 延时阻塞队列，该队列中的元素需要实现Delayed接口</span></span><br><span class="line">                    <span class="comment">// 底层使用PriorityQueue的二叉堆对Delayed元素排序</span></span><br><span class="line">                    <span class="comment">// ScheduledThreadPoolExecutor底层就用了DelayQueue的变体&quot;DelayWorkQueue&quot;</span></span><br><span class="line">                    <span class="comment">// 队列中所有的任务都会封装成ScheduledFutureTask对象(该类已实现Delayed接口)</span></span><br></pre></td></tr></table></figure><blockquote><p>有关BlockingQueue的内容可以参考<a target="_blank" rel="noopener" href="http://blog.csdn.net/holmofy/article/details/71215548">《Java集合框架总结与巩固》</a></p></blockquote></li><li><p>threadFactory：线程工厂，主要用来创建线程；默认情况都会使用Executors工具类中定义的默认工厂类<code>DefaultThreadFactory</code>。可以实现ThreadFactory接口来自己控制创建线程池的过程(比如设置创建线程的名字、优先级或者是否为Deamon守护线程)</p></li><li><p>handler：表示当拒绝处理任务时的策略，有以下四种取值(默认为AbortPolicy)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy: 丢弃任务并抛出RejectedExecutionException异常。</span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。</span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>可通过实现RejectedExecutionHandler接口来自定义任务拒绝后的处理策略</p></blockquote><h2>4. 线程池的状态转换</h2><p>ThreadPoolExecutor类中有一个<code>ctl</code>属性，该属性是AtomicInteger类型，本质上就是32bit的int类型。这个32bit字段中存储了两个数据：</p><p><img src="/2017/06/Java/multithread/06-ThreadPoolExecutor/ThreadPoolExecutor_ctl.svg" alt="ThreadPoolExecutor.ctl"></p><p>其中三个高字节位存储了线程池当前的运行状态，线程池状态有以下几个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><ul><li>RUNNING：接受新任务并处理队列中的任务</li><li>SHUTDOWN：不接受新任务但处理队列中的任务</li><li>STOP：不接受新任务也不处理队列中的任务并终断正在处理中的任务</li><li>TIDYING：所有任务已经终止，workerCount等于0，线程池切换到TIDYING后将会执行<code>terminated()</code>钩子方法</li><li>TERMINATED：<code>terminated()</code>方法已执行完成</li></ul><p>整个过程的状态转换图如下：</p><p><img src="/2017/06/Java/multithread/06-ThreadPoolExecutor/RunState.svg" alt="线程池状态转换图"></p><p>我们可以调用的两个改变线程池状态的方法分别是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进入SHUTDOWN状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 进入STOP状态</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>另外ThreadPoolExecutor提供了一些方法来查询这些状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非运行状态：SHUTDOWN,STOP,TIDYING,TERMINATED</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ! isRunning(ctl.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正在终止状态：SHUTDOWN,STOP,TIDYING</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTerminating</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="keyword">return</span> ! isRunning(c) &amp;&amp; runStateLessThan(c, TERMINATED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 终止状态：TERMINATED</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> runStateAtLeast(ctl.get(), TERMINATED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>5. 任务的提交</h2><p>任务提交主要有三种方式：</p><ul><li>execute(Runnable command)：定义在Executor接口中</li><li>submit的三个重载方法：定义在ExecutorService接口中</li><li>invoke(invokeAll,invokeAny)提交方式：定义在ExecutorService接口中</li></ul><h3>5.1 submit提交方式</h3><p>submit方法的实现源码在ThreadPoolExecutor的基类AbstractExecutorService中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将Runnable和Callable包装成FutureTask对象</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="title function_">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="literal">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Runnable task, T result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>submit最终都会调用execute方法去执行任务，区别在于submit方法返回一个FutureTask对象(顾名思义FutrueTask就是未来将执行的任务，可以通过FutureTask对象获取任务执行的结果)。</p><h4>5.1.1 FutrueTask</h4><p>FutureTask实现Future接口，Future接口及其相关类继承图如下：</p><p><img src="/2017/06/Java/multithread/06-ThreadPoolExecutor/Future.svg" alt="Future继承图"></p><p>FutureTask类中定义了如下的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The run state of this task, initially NEW.  The run state</span></span><br><span class="line"><span class="comment"> * transitions to a terminal state only in methods set,</span></span><br><span class="line"><span class="comment"> * setException, and cancel.  During completion, state may take on</span></span><br><span class="line"><span class="comment"> * transient values of COMPLETING (while outcome is being set) or</span></span><br><span class="line"><span class="comment"> * INTERRUPTING (only while interrupting the runner to satisfy a</span></span><br><span class="line"><span class="comment"> * cancel(true)). Transitions from these intermediate to final</span></span><br><span class="line"><span class="comment"> * states use cheaper ordered/lazy writes because values are unique</span></span><br><span class="line"><span class="comment"> * and cannot be further modified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Possible state transitions:</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; NORMAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span></span><br><span class="line"><span class="comment"> * NEW -&gt; CANCELLED</span></span><br><span class="line"><span class="comment"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEW</span>          <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 任务已被创建(new的时候默认状态为0)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COMPLETING</span>   <span class="operator">=</span> <span class="number">1</span>;<span class="comment">// 任务即将完成(已获取返回值或已捕获异常)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL</span>       <span class="operator">=</span> <span class="number">2</span>;<span class="comment">// 任务正常完成(以返回值的形式完成任务)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCEPTIONAL</span>  <span class="operator">=</span> <span class="number">3</span>;<span class="comment">// 任务异常完成(任务执行过程发生异常并被捕获)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span>    <span class="operator">=</span> <span class="number">4</span>;<span class="comment">// 任务已被取消(任务还没被执行就被取消了,可能在排队)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTING</span> <span class="operator">=</span> <span class="number">5</span>;<span class="comment">// 任务正在中断(任务执行时被取消)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTED</span>  <span class="operator">=</span> <span class="number">6</span>;<span class="comment">// 任务已经中断(INTERRUPTING的下一个状态)</span></span><br></pre></td></tr></table></figure><p>FutureTask的状态转换图如下(其中绿色标注的是外部可调用的方法，其他方法均有内部调用，RUNNING状态是我附加的状态，表示该任务已经被运行)：</p><p><img src="/2017/06/Java/multithread/06-ThreadPoolExecutor/FutrueTaskState.svg" alt="FutureTask状态转换图"></p><p>Future接口定义了以下几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试取消任务，根据任务的执行状态分一下几种情况</span></span><br><span class="line"><span class="comment">// 任务完成或任务已取消：该方法调用失败返回false</span></span><br><span class="line"><span class="comment">// 运行状态：任务正在执行，根据传入mayInterruptIfRunning参数判断是否应该终断任务</span></span><br><span class="line"><span class="comment">// 排队状态：任务正在排队，则将任务状态设置为CANCELLED,线程池不会执行已经被取消的任务</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>;</span><br><span class="line"><span class="comment">// 任务是否被取消,CANCELLED,INTERRUPTING,INTERRUPTED状态下返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span> &#123; <span class="keyword">return</span> state &gt;= CANCELLED; &#125;</span><br><span class="line"><span class="comment">// 任务是否被执行,只有NEW状态返回false</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>&#123; <span class="keyword">return</span> state != NEW; &#125;</span><br><span class="line"><span class="comment">// 获取任务执行结果,该方法会一直阻塞等待任务的执行结果</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"><span class="comment">// 获取任务执行结果,该方法会等待timeout时间,</span></span><br><span class="line"><span class="comment">// 如果没有结果就抛出超时异常(TimeoutException)</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程池大小固定为4，处理不完的任务全部入队</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">4</span>, <span class="number">4</span>, <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;());</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;输入0使用submit提交任务到线程池&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;输入正整数使用取消上次提交的任务并允许中断&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;输入负整数使用取消上次提交的任务不允许中断&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;输入其他字符关闭线程池并退出程序&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------&quot;</span>);</span><br><span class="line">        Future&lt;String&gt; task = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sc.hasNextInt()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">command</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                <span class="keyword">if</span> (command == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 提交任务</span></span><br><span class="line">                    task = threadPool.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            printMessage(<span class="string">&quot;Task start&quot;</span>);</span><br><span class="line">                            Thread.sleep(<span class="number">1800</span>);</span><br><span class="line">                            printMessage(<span class="string">&quot;Task finish&quot;</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command &gt; <span class="number">0</span> &amp;&amp; task != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 强制取消任务</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> task.cancel(<span class="literal">true</span>);</span><br><span class="line">                    System.out.println(task + <span class="string">&quot;:task.cancel(true)-&gt;&quot;</span></span><br><span class="line">                            + (success ? <span class="string">&quot;success&quot;</span> : <span class="string">&quot;failed&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (command &lt; <span class="number">0</span> &amp;&amp; task != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 取消任务</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> task.cancel(<span class="literal">false</span>);</span><br><span class="line">                    System.out.println(task + <span class="string">&quot;:task.cancel(false)-&gt;&quot;</span></span><br><span class="line">                            + (success ? <span class="string">&quot;success&quot;</span> : <span class="string">&quot;failed&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                threadPool.shutdownNow();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        System.out.println(name + <span class="string">&quot;:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>5.2 execute提交方式</h3><p>submit最终都会调用execute方法去执行任务，所以我们重点需要分析execute方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 如果核心线程未满，则创建核心线程并将任务交由新线程处理(即使有核心线程空闲)</span></span><br><span class="line">        <span class="comment">// 所以前corePoolSize个任务都会一次交给新创建的核心线程执行</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往下走说明核心线程已全部创建完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果线程池仍是RUNNING状态，将任务加入工作队列(也就是构造时提供的阻塞队列)</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        <span class="comment">// 如果线程池已经SHUTDOWN，将任务回滚移除工作队列并拒绝该任务</span></span><br><span class="line">            reject(command);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 该情况用于核心线程数(corePoolSize)为0</span></span><br><span class="line">        <span class="comment">// 或者允许核心线程超时(allowCoreThreadTimeOut)的时候</span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入队失败则尝试创建普通临时线程(非核心线程)</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        <span class="comment">// 如果仍无法创建线程</span></span><br><span class="line">        <span class="comment">// 可以断定线程池已经SHUTDOWN(关闭)或者SATURATED(饱和)</span></span><br><span class="line">        <span class="comment">// 所以拒绝该任务</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据源码可以得出以下执行流程：</p><ol><li>如果正在运行的线程数小于corePoolSize，Executor总是添加一个新线程，而不是任务排队。</li><li>如果已有corePoolSize或更多线程在运行，则Executor总是优先选择任务排队而不会添加新线程。</li><li>如果任务请求不能排队，则创建一个新线程，但是线程总数量不超过maximumPoolSize，如果不能创建新线程任务将会被拒绝。</li></ol><p>这里有几点需要重点注意：</p><ul><li>第五行<code>workerCountOf(c) &lt; corePoolSize</code>：如果核心线程没有创建完则新任务交由新创建的核心线程处理，但是我们如果调用<code>prestartAllCoreThreads</code>方法预先把所有核心线程创建完成，则这一分支不会执行。</li><li>第十三行<code>workQueue.offer(command)</code>：offer方法不会阻塞(名不符其实，阻塞队列不阻塞呵呵)，如果入队成功会立即返回true否则返回false。入队成功与否取决于<code>workQueue</code>的性质。比如：①单链表实现的<strong>LinkedBlockingQueue</strong>默认容量为<code>Integer.MAX_VALUE</code>(等价于无限容量)，所以此时该方法不会返回false也不会创建临时线程(都去排队去了)，当然如果创建LinkedBlockingQueue时指定了capacity，offer方法就可能返回false，但我们一般不会这么干；②而数组实现的<strong>ArrayBlockingQueue</strong>不允许扩容，所以队列已满则会返回false进入二十三行尝试创建临时线程，如果总线程数不超过maximumPoolSize则能创建临时线程，但会导致后来的任务没排队反而能得到执行(不公平)，如果超出maximumPoolSize创建临时线程失败则会拒绝任务，两种情况都不好，所以ArrayBlockingQueue用的不是很多；③使用小顶堆实现的<code>PriorityBlockingQueue</code>会根据任务的优先级来选择执行顺序；④使用没有容量的同步队列<code>SynchronousQueue</code>，如果没有空闲线程接收任务会立即返回false，所以大部分情况会创建新的临时线程。</li><li>第十七行<code>workerCountOf(recheck) == 0</code>：这句判断间接表示核心线程数为0的情况，核心线程数为0只会发生在两种条件下：①线程池本身已经指定核心数为0(构造方法指定或<code>setCorePoolSize</code>方法指定)，②调用<code>allowCoreThreadTimeOut</code>方法允许核心线程超时导致核心线程数位0。</li></ul><h3>5.3 invoke提交方式</h3><p>ExecutorService中定义了两组invoke方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> </span><br><span class="line">                              <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">// 等待timeout时间，即使一个任务都没完成也返回</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">                              <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"><span class="comment">// 等待timeout时间，即使一个任务都没完成也返回</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">                              <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure><ul><li>invokeAny取得率先完成的任务的返回值，当第一个任务结束后，会调用cancel方法取消其它任务。</li><li>invokeAll等所有任务执行完毕后，取得全部任务的结果值。</li></ul><p><strong>invokeAll存在的问题</strong></p><p>invokeAll有个严重的问题是，任务执行后不会抛出任务执行的异常。调用方需要手动调用<code>Future.get()</code>方法触发异常，而且FutureTask的异常是被ExecutionException包裹过的，所以调用<code>get</code>方法的时候是无法捕获到内部抛出的异常类型，要么通过捕获ExecutionException异常拿到它内部包装的异常，要么直接捕获所有的Exception。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractExecutorService#invokeAll</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">done</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">            RunnableFuture&lt;T&gt; f = newTaskFor(t);</span><br><span class="line">            futures.add(f);</span><br><span class="line">            execute(f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, size = futures.size(); i &lt; size; i++) &#123;</span><br><span class="line">            Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    f.get();</span><br><span class="line">                <span class="comment">// invokeAll把这个异常给忽略了。</span></span><br><span class="line">                <span class="comment">// 之所以要忽略，是要让所有的任务都执行完</span></span><br><span class="line">                <span class="comment">// 所以外部调用者仍需要调用get()方法触发这个异常。</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        done = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!done) <span class="comment">// 这部分只可能在execute抛异常的时候执行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                futures.get(i).cancel(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>5.3.1 等待任务完成</h4><p>invokeAll方式会导致调用线程阻塞直到所有任务完成，由于不知道哪个任务先执行完毕，使用这种方式效率不是很高。所以Java5还提供了一个<code>CompletionService</code>接口给我们用。<code>CompletionService</code>目前只有一个实现类——<code>ExecutorCompletionService</code>。</p><p><img src="http://tva1.sinaimg.cn/large/bda5cd74gy1ftaj3nepevj219a0fyn7o.jpg" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="ExecutorCompletionService架构图"></p><p>ExecutorCompletionService实际只是维护了一个队列，然后将完成的任务往队列里放，这个实现主要是依赖FutureTask的一个钩子方法done：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorCompletionService</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">CompletionService</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractExecutorService aes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">QueueingFuture</span> <span class="keyword">extends</span> <span class="title class_">FutureTask</span>&lt;Void&gt; &#123;</span><br><span class="line">        QueueingFuture(RunnableFuture&lt;V&gt; task) &#123;</span><br><span class="line">            <span class="built_in">super</span>(task, <span class="literal">null</span>);</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 任务执行完后会执行该钩子方法</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">done</span><span class="params">()</span> &#123; completionQueue.add(task); &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Future&lt;V&gt; task;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">// 提交任务时再用QueueingFuture包装</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;V&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;V&gt; task)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        RunnableFuture&lt;V&gt; f = newTaskFor(task);</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">QueueingFuture</span>(f));</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Future&lt;V&gt; <span class="title function_">submit</span><span class="params">(Runnable task, V result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        RunnableFuture&lt;V&gt; f = newTaskFor(task, result);</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">QueueingFuture</span>(f));</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(Executor e, Collection&lt;Callable&lt;Result&gt;&gt; solvers)</span> </span><br><span class="line">                       <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    CompletionService&lt;Result&gt; ecs = <span class="keyword">new</span> <span class="title class_">ExecutorCompletionService</span>&lt;Result&gt;(e);</span><br><span class="line">    <span class="keyword">for</span> (Callable&lt;Result&gt; s : solvers)</span><br><span class="line">        ecs.submit(s);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> solvers.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">r</span> <span class="operator">=</span> ecs.take().get();</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">            doSomething(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>invokeAny就是通过<code>CompletionService</code>实现，从而拿到第一个执行完成的任务的结果。</p></blockquote><h2>6. 线程如何创建</h2><p>刚刚的execute提交任务中调用到了addWorker方法来创建线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取线程池当前状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 线程池已经SHUTDOWN不接受任务</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 获取线程池当前的工作线程数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||<span class="comment">// 超过了最大线程容量</span></span><br><span class="line">                    <span class="comment">// 创建核心线程，超过了核心线程数</span></span><br><span class="line">                    <span class="comment">// 创建普通线程，超过了最大可允许的线程数</span></span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="comment">// 拒绝</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 尝试增加线程数WorkerCount++</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="comment">// 增加线程数成功，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="comment">// 前后状态不一致，循环重试</span></span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建Worker内部类对象，Worker内部会创建线程</span></span><br><span class="line">            w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 线程创建成功</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                        <span class="comment">// 将工作线程加入集合</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    t.start(); <span class="comment">// 启动线程</span></span><br><span class="line">                    workerStarted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果线程创建或执行失败</span></span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                <span class="comment">// 执行失败的处理</span></span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWorkerFailed</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (w != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 线程创建失败了，必须从集合中删除该Worker对象</span></span><br><span class="line">                workers.remove(w);</span><br><span class="line">            <span class="comment">// 并WorkCount--</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            tryTerminate();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2>7. 线程如何执行</h2><p>线程执行我们肯定得找到run方法，我们看一下Worker类是怎么定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/** 实际的工作线程 */</span></span><br><span class="line">        <span class="keyword">final</span> Thread thread;</span><br><span class="line">        <span class="comment">/** 线程初始的任务，可能为null. */</span></span><br><span class="line">        Runnable firstTask;</span><br><span class="line">        <span class="comment">/** 该线程执行的任务数量 */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// AQS中的内容，这个暂时不讨论</span></span><br><span class="line">            <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="comment">// 使用ThreadFactory创建线程，并指定runnable参数为this</span></span><br><span class="line">            <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** 因为创建线程时指定了runnable为this，所以会执行这个方法  */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            runWorker(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor.runWorker方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">        w.firstTask = <span class="literal">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断firstTask是否为空,否则从任务队列中取出任务</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                w.lock(); <span class="comment">// AQS中的内容暂时不做讨论</span></span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 回调beforeExecute方法</span></span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run(); <span class="comment">//执行任务</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 回调afterExecute方法</span></span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                    w.completedTasks++; <span class="comment">// 执行完成的任务数加一</span></span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 循环执行下一个任务</span></span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 没有任务执行，终结线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                    <span class="comment">// 超时功能使用阻塞队列实现</span></span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                timedOut = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                timedOut = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2>8. 线程池的其他变量和方法</h2><p>其他成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 工作队列：用于任务排队等待</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"> <span class="comment">// 操作线程池数据时，用于保持同步的锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"> <span class="comment">// 保存所有工作线程的集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br><span class="line"> <span class="comment">// 调用awaitTermination方法时等待终止的条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">termination</span> <span class="operator">=</span> mainLock.newCondition();</span><br><span class="line"> <span class="comment">// 线程池达到的最大线程数，记录曾经出现过的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> largestPoolSize;</span><br><span class="line"> <span class="comment">// 已经完成任务的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> completedTaskCount;</span><br><span class="line"> <span class="comment">// 用于创建线程的线程工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"> <span class="comment">// 任务的拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"> <span class="comment">// 线程存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> keepAliveTime;</span><br><span class="line"> <span class="comment">// 是否允许核心线程超时</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"> <span class="comment">// 核心线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> corePoolSize;</span><br><span class="line"> <span class="comment">// 线程池允许的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> maximumPoolSize;</span><br></pre></td></tr></table></figure><p>其他成员方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------</span></span><br><span class="line"><span class="comment">// 与线程大小有关的方法：</span></span><br><span class="line"><span class="comment">// 这几个数量之间满足：CorePoolSize &lt;= PoolSize &lt;= LargestPoolSize &lt;= MaximumPoolSize</span></span><br><span class="line"><span class="comment">// 核心线程数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCorePoolSize</span><span class="params">(<span class="type">int</span> corePoolSize)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCorePoolSize</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 最大线程数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMaximumPoolSize</span><span class="params">(<span class="type">int</span> maximumPoolSize)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaximumPoolSize</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 当前线程池大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPoolSize</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 线程池达到的最大线程数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLargestPoolSize</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------</span></span><br><span class="line"><span class="comment">// 和任务数量有关的方法：</span></span><br><span class="line"><span class="comment">// 当前活跃的任务数量：这个数量等于当前工作线程个数(不包括空闲线程)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getActiveCount</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 线程池已接受的任务总量</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTaskCount</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 线程池已经完成的任务数量</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCompletedTaskCount</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------</span></span><br><span class="line"><span class="comment">// 其他getter/setter方法：</span></span><br><span class="line"><span class="comment">// threadFactory的getter/setter方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setThreadFactory</span><span class="params">(ThreadFactory threadFactory)</span>;</span><br><span class="line"><span class="keyword">public</span> ThreadFactory <span class="title function_">getThreadFactory</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// handler的getter/setter方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRejectedExecutionHandler</span><span class="params">(RejectedExecutionHandler handler)</span>;</span><br><span class="line"><span class="keyword">public</span> RejectedExecutionHandler <span class="title function_">getRejectedExecutionHandler</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// allowCoreThreadTimeOut的getter/setter方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">allowCoreThreadTimeOut</span><span class="params">(<span class="type">boolean</span> value)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">allowsCoreThreadTimeOut</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// keepAliveTime的getter/setter方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setKeepAliveTime</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getKeepAliveTime</span><span class="params">(TimeUnit unit)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------</span></span><br><span class="line"><span class="comment">// 其他方法</span></span><br><span class="line"><span class="comment">// 预启动一个核心线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">prestartCoreThread</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 预启动所有核心线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">prestartAllCoreThreads</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 获取等待队列</span></span><br><span class="line"><span class="keyword">public</span> BlockingQueue&lt;Runnable&gt; <span class="title function_">getQueue</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 将task任务从等待队列中移除</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Runnable task)</span>;</span><br><span class="line"><span class="comment">// 将等待队列中的所有已经被取消的Future任务清除</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">purge</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 在shutdown请求之后，调用awaitTermination方法</span></span><br><span class="line"><span class="comment">// 会阻塞等待任务完成进入TERMINATED状态</span></span><br><span class="line"><span class="comment">// timeout设置等待时间，unit设置时间单位</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span>;</span><br></pre></td></tr></table></figure><h2>9. 扩展ThreadPoolExecutor的功能</h2><p>在ThreadPoolExecutor类中还有三个protected属性的空方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务执行之前：</span></span><br><span class="line"><span class="comment">// Thread t:执行任务的线程</span></span><br><span class="line"><span class="comment">// Runnable r:被执行的任务</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> &#123; &#125;</span><br><span class="line"><span class="comment">// 任务执行之后：</span></span><br><span class="line"><span class="comment">// Runnable r:被执行的任务</span></span><br><span class="line"><span class="comment">// Throwable t:任务执行过程中抛出的异常</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> &#123; &#125;</span><br><span class="line"><span class="comment">// 线程池进入TERMINATED状态后</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">terminated</span><span class="params">()</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>根据JDK文档中的说明，我们可以重载这三个钩子方法来对ThreadPoolExecutor进行扩展。下面是官方文档提供的扩展示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以暂停执行的线程池</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PausableThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title class_">ThreadPoolExecutor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PausableThreadPoolExecutor</span><span class="params">(...)</span> &#123; <span class="built_in">super</span>(...); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isPaused;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">pauseLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">unpaused</span> <span class="operator">=</span> pauseLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.beforeExecute(t, r);</span><br><span class="line">        pauseLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果线程池被暂停，则任务等待不暂停的条件(等待resume方法的调用)</span></span><br><span class="line">            <span class="keyword">while</span> (isPaused)</span><br><span class="line">                unpaused.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            pauseLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pause</span><span class="params">()</span> &#123;</span><br><span class="line">        pauseLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="literal">true</span>;<span class="comment">// 暂停</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            pauseLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resume</span><span class="params">()</span> &#123;</span><br><span class="line">        pauseLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="literal">false</span>;<span class="comment">// 恢复</span></span><br><span class="line">            unpaused.signalAll(); <span class="comment">// 激活所有等待的线程</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            pauseLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>10. 更多种类的线程池MoreExecutors</h2><p><a target="_blank" rel="noopener" href="https://github.com/google/guava">Guava</a>是Google提供的一个最受欢迎的通用工具包。它提供了很多并发工具，其中包括几个便捷的<code>ExecutorService</code>实现类，这些实现类我们无法直接访问，Guava提供了一个唯一的访问入口——<a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/util/concurrent/MoreExecutors.java">MoreExecutors</a>工具类。</p><p>1、 应用执行完成(主线程以及其他非守护线程执行完)后自动关闭的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 执行完成后，等待terminationTimeout后关闭线程池 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">getExitingExecutorService</span><span class="params">(</span></span><br><span class="line"><span class="params">    ThreadPoolExecutor executor, <span class="type">long</span> terminationTimeout, TimeUnit timeUnit)</span>;</span><br><span class="line"><span class="comment">/* 默认延迟120秒 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">getExitingExecutorService</span><span class="params">(ThreadPoolExecutor executor)</span>;</span><br><span class="line"><span class="comment">/* 对ScheduledExecutorService的包装 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">getExitingScheduledExecutorService</span><span class="params">(</span></span><br><span class="line"><span class="params">    ScheduledThreadPoolExecutor executor, <span class="type">long</span> terminationTimeout, TimeUnit timeUnit)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">getExitingScheduledExecutorService</span><span class="params">(</span></span><br><span class="line"><span class="params">    ScheduledThreadPoolExecutor executor)</span></span><br></pre></td></tr></table></figure><p>这个工具方法修改传入的线程池的ThreadFactory使其生成守护线程，但是线程池使用守护进程会导致有些任务只执行了一半，为了让线程池更加可控，所以Guava使用<code>Runtime.getRuntime().addShutdownHook(hook)</code>注册了一个等待线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">addShutdownHook(</span><br><span class="line">    MoreExecutors.newThread(</span><br><span class="line">    <span class="string">&quot;DelayedShutdownHook-for-&quot;</span> + service,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                service.shutdown();</span><br><span class="line">                service.awaitTermination(terminationTimeout, timeUnit);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> MoreExecutors.getExitingExecutorService(</span><br><span class="line">    executor, <span class="number">100</span>, TimeUnit.MILLISECONDS); </span><br><span class="line">executorService.submit(() -&gt; &#123; <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125; &#125;); <span class="comment">// 执行一个无限期的任务</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的代码中，如果我们直接在线程池中执行无限期的任务，会导致JVM无限期挂起。</p><p>当我们使用<code>getExitingExecutorService</code>进行包装后，程序执行完后，如果线程池100毫秒内没有执行完任务，将会直接关闭线程池。</p></blockquote><p>2、当前线程执行的线程池</p><p>有时可能需要在当前线程或线程池中执行任务，具体取决于某些条件，为了使用统一的接口可能需要在当前线程执行的Executor。虽然这个实现起来并不难，但还是需要编写样板代码。所幸Guava已经提供了这样的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举单例</span></span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> MoreExecutors.directExecutor();</span><br><span class="line"><span class="comment">// 每次都会创建一个新的对象</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> MoreExecutors.newDirectExecutorService();</span><br></pre></td></tr></table></figure><p>3、使用ListenableFuture异步增强的线程池</p><p>使用submit提交方式将会返回一个实现了Future接口的FutureTask对象，我们通过调用<code>Future.get</code>方法获取任务的执行结果，如果任务没有执行完，get方法将会导致调用线程的阻塞。为此Guava为我们提供了一个增强型的Future接口——<code>ListenableFuture</code>，能以异步回调的方式获取执行结果。</p><p>为了能让线程池返回<code>ListenableFuture</code>，MoreExecutors中提供了两个包装方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListeningExecutorService <span class="title function_">listeningDecorator</span><span class="params">(ExecutorService delegate)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListeningScheduledExecutorService <span class="title function_">listeningDecorator</span><span class="params">(ScheduledExecutorService delegate)</span></span><br></pre></td></tr></table></figure><blockquote><p>实际上<code>ListenableFutureTask</code>和上面的ExecutorComletionService一样也是通过实现FutureTask的done方法实现。</p></blockquote><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">delegate</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">// 包装成Guava的ListeningExecutorService</span></span><br><span class="line"><span class="type">ListeningExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> MoreExecutors.listeningDecorator(delegate);</span><br><span class="line"><span class="comment">// 提交有返回结果的任务</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">ListenableFuture</span> <span class="variable">future</span> <span class="operator">=</span> executor.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">future.addListener(<span class="keyword">new</span> <span class="title class_">Runable</span>() &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;result:&quot;</span> + future.get());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, MoreExecutors.directExecutor());</span><br><span class="line"><span class="comment">// Futures工具类提供了工具方法用于任务正常或异常情况的处理。</span></span><br><span class="line">Futures.addCallback(future, <span class="keyword">new</span> <span class="title class_">FutureCallback</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(Integer result)</span> &#123;</span><br><span class="line">        <span class="comment">// 任务正常返回结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        <span class="comment">// 任务抛异常了</span></span><br><span class="line">        t.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, MoreExecutors.directExecutor());</span><br></pre></td></tr></table></figure><blockquote><p>关于ListenableFuture的更多细节用法，参考<a target="_blank" rel="noopener" href="https://github.com/google/guava/wiki/ListenableFutureExplained">Guava的wiki</a></p></blockquote></div><div class="article-copyright"><p>本作品采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> 进行许可。</p><p>转载时请注明<a href="https://blog.hufeifei.cn/2017/06/Java/multithread/06-ThreadPoolExecutor/">原文链接</a>：https://blog.hufeifei.cn/2017/06/Java/multithread/06-ThreadPoolExecutor/</p></div><footer class="article-footer"></footer></div><div id="article-reward"><i class="iconfont ic-money"></i><div>鼓励一下</div><table><thead><tr><th style="text-align:center">支付宝</th><th style="text-align:center">微信</th></tr></thead><tbody><tr><td style="text-align:center"><img width="150" src="https://www.hufeifei.cn/reward-img/alipay.jpg"></td><td style="text-align:center"><img width="135" src="https://www.hufeifei.cn/reward-img/wechat.jpg"></td></tr></tbody></table></div><nav id="article-nav"><a class="article-nav-link-wrap" href="/2017/06/Java/multithread/07-ScheduledThreadPoolExecutor/" id="article-nav-newer"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">Java多线程复习与巩固（七）--任务调度线程池ScheduledThreadPoolExecutor</div></a><a class="article-nav-link-wrap" href="/2017/06/Java/multithread/05-Provider-Consumer/" id="article-nav-older"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">Java多线程复习与巩固（五）--生产者消费者问题（第一部分）</div></a></nav></article><div id="waline-comments"></div><script type="module">import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js';init({"el":"#waline-comments","pageview":true,"enable":true,"serverURL":"https://api.waline.blog.hufeifei.cn","avatar":"mp","pageSize":10,"lang":"zh-cn","placeholder":"Just go go","visitor":true,"recordIP":true,"requiredFields":["nick"]});</script></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">关注微信公众号</h3><div class="widget wechat"><img src="//www.hufeifei.cn/wechat-public-account.jpg"></div></div><div class="widget-wrap"><h3 class="widget-title">Categories</h3><div class="widget"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C&C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/J2EE/">J2EE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux%E8%BF%90%E7%BB%B4/">Linux运维</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby/">Ruby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rust/">Rust</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%A3%E7%A0%81%E6%97%A5%E5%B8%B8/">代码日常</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%95%86%E4%B8%9A/">商业</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%8F%E6%B5%8E%E4%B8%8E%E9%87%91%E8%9E%8D/">经济与金融</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/">计算机组成</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Tag Cloud</h3><div class="widget tagcloud"><a href="/tags/AVL/" style="font-size:11.11px">AVL</a> <a href="/tags/Alibaba/" style="font-size:14.44px">Alibaba</a> <a href="/tags/Android/" style="font-size:18.89px">Android</a> <a href="/tags/B-Tree/" style="font-size:12.22px">B-Tree</a> <a href="/tags/BKD-Tree/" style="font-size:10px">BKD-Tree</a> <a href="/tags/BST/" style="font-size:10px">BST</a> <a href="/tags/BigData/" style="font-size:11.11px">BigData</a> <a href="/tags/C/" style="font-size:14.44px">C</a> <a href="/tags/CGlib/" style="font-size:10px">CGlib</a> <a href="/tags/CS/" style="font-size:11.11px">CS</a> <a href="/tags/Canal/" style="font-size:10px">Canal</a> <a href="/tags/ClassLoader/" style="font-size:10px">ClassLoader</a> <a href="/tags/ClickHouse/" style="font-size:10px">ClickHouse</a> <a href="/tags/Config/" style="font-size:10px">Config</a> <a href="/tags/Cryptography/" style="font-size:10px">Cryptography</a> <a href="/tags/DB/" style="font-size:20px">DB</a> <a href="/tags/Dapper/" style="font-size:10px">Dapper</a> <a href="/tags/DataStructure/" style="font-size:14.44px">DataStructure</a> <a href="/tags/Debezium/" style="font-size:10px">Debezium</a> <a href="/tags/Diamond/" style="font-size:10px">Diamond</a> <a href="/tags/Distributed/" style="font-size:13.33px">Distributed</a> <a href="/tags/ElasticSearch/" style="font-size:10px">ElasticSearch</a> <a href="/tags/Encoding/" style="font-size:10px">Encoding</a> <a href="/tags/FastJson/" style="font-size:10px">FastJson</a> <a href="/tags/File/" style="font-size:10px">File</a> <a href="/tags/FlowMarketing/" style="font-size:10px">FlowMarketing</a> <a href="/tags/Grade/" style="font-size:10px">Grade</a> <a href="/tags/Gson/" style="font-size:10px">Gson</a> <a href="/tags/HTTP/" style="font-size:10px">HTTP</a> <a href="/tags/Handler/" style="font-size:10px">Handler</a> <a href="/tags/Hanlder/" style="font-size:10px">Hanlder</a> <a href="/tags/Hessian/" style="font-size:10px">Hessian</a> <a href="/tags/IO-Multiplex/" style="font-size:10px">IO-Multiplex</a> <a href="/tags/JAVA/" style="font-size:18.89px">JAVA</a> <a href="/tags/JVM/" style="font-size:10px">JVM</a> <a href="/tags/KD-Tree/" style="font-size:10px">KD-Tree</a> <a href="/tags/KDB-Tree/" style="font-size:10px">KDB-Tree</a> <a href="/tags/Kafka/" style="font-size:10px">Kafka</a> <a href="/tags/Kubernetes/" style="font-size:10px">Kubernetes</a> <a href="/tags/LSM-Tree/" style="font-size:11.11px">LSM-Tree</a> <a href="/tags/Linux/" style="font-size:17.78px">Linux</a> <a href="/tags/Lock/" style="font-size:11.11px">Lock</a> <a href="/tags/Lucene/" style="font-size:10px">Lucene</a> <a href="/tags/MQ/" style="font-size:10px">MQ</a> <a href="/tags/Macro/" style="font-size:10px">Macro</a> <a href="/tags/Magisk/" style="font-size:10px">Magisk</a> <a href="/tags/MultiDex/" style="font-size:10px">MultiDex</a> <a href="/tags/MySQL/" style="font-size:17.78px">MySQL</a> <a href="/tags/NIO/" style="font-size:10px">NIO</a> <a href="/tags/Nginx/" style="font-size:11.11px">Nginx</a> <a href="/tags/OGNL/" style="font-size:10px">OGNL</a> <a href="/tags/OpenResty/" style="font-size:10px">OpenResty</a> <a href="/tags/OpenTelemetry/" style="font-size:10px">OpenTelemetry</a> <a href="/tags/Oracle/" style="font-size:10px">Oracle</a> <a href="/tags/PostgreSQL/" style="font-size:10px">PostgreSQL</a> <a href="/tags/RB-Tree/" style="font-size:10px">RB-Tree</a> <a href="/tags/Redis/" style="font-size:10px">Redis</a> <a href="/tags/Rust/" style="font-size:10px">Rust</a> <a href="/tags/Sharding/" style="font-size:10px">Sharding</a> <a href="/tags/SpringBoot/" style="font-size:10px">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size:10px">SpringCloud</a> <a href="/tags/SpringCloudConfig/" style="font-size:10px">SpringCloudConfig</a> <a href="/tags/Sqlite/" style="font-size:10px">Sqlite</a> <a href="/tags/SurfaceView/" style="font-size:10px">SurfaceView</a> <a href="/tags/VSCode/" style="font-size:11.11px">VSCode</a> <a href="/tags/WebFlux/" style="font-size:10px">WebFlux</a> <a href="/tags/WebPush/" style="font-size:10px">WebPush</a> <a href="/tags/Web%E6%8C%96%E6%8E%98/" style="font-size:11.11px">Web挖掘</a> <a href="/tags/awk/" style="font-size:10px">awk</a> <a href="/tags/bit-hack/" style="font-size:10px">bit-hack</a> <a href="/tags/cheat-sheet/" style="font-size:10px">cheat sheet</a> <a href="/tags/curl/" style="font-size:10px">curl</a> <a href="/tags/epoll/" style="font-size:10px">epoll</a> <a href="/tags/gRPC/" style="font-size:10px">gRPC</a> <a href="/tags/grep/" style="font-size:10px">grep</a> <a href="/tags/kqueue/" style="font-size:10px">kqueue</a> <a href="/tags/libev/" style="font-size:10px">libev</a> <a href="/tags/libevent/" style="font-size:10px">libevent</a> <a href="/tags/libuv/" style="font-size:10px">libuv</a> <a href="/tags/metaq/" style="font-size:10px">metaq</a> <a href="/tags/poll/" style="font-size:10px">poll</a> <a href="/tags/sed/" style="font-size:10px">sed</a> <a href="/tags/select/" style="font-size:10px">select</a> <a href="/tags/ssh/" style="font-size:10px">ssh</a> <a href="/tags/%E5%8E%86%E5%8F%B2/" style="font-size:10px">历史</a> <a href="/tags/%E5%95%86%E4%B8%9A/" style="font-size:10px">商业</a> <a href="/tags/%E5%BF%83%E7%90%86%E5%AD%A6/" style="font-size:10px">心理学</a> <a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size:11.11px">生活</a> <a href="/tags/%E7%A8%8E%E6%94%B6/" style="font-size:10px">税收</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size:14.44px">算法</a> <a href="/tags/%E7%BB%8F%E6%B5%8E/" style="font-size:15.56px">经济</a> <a href="/tags/%E8%90%A5%E9%94%80/" style="font-size:10px">营销</a> <a href="/tags/%E8%B4%A7%E5%B8%81/" style="font-size:10px">货币</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size:16.67px">随笔</a></div></div><div class="widget-wrap"><h3 class="widget-title">Recent Posts</h3><div class="widget"><ul><li><a href="/2024/04/economic/value-added-tax/">增值税与贫富差距</a></li><li><a href="/2024/01/Net/x-forward-for/">“真”的IP真的是真的吗？</a></li><li><a href="/2024/01/paper/MarkupLM-web-extract/">【译】基于MarkupLM的web数据抽取</a></li><li><a href="/2023/09/economic/tax-reform/">直接税改革——王朝周期律的胜负手</a></li><li><a href="/2023/09/Rust/macro-rules-learning/">Rust中的宏</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">网站运营不易</h3><div class="ads-wrapper"><div class="google_ads"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7111912103882824" data-ad-slot="8429272980" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div></div></aside></div><footer id="footer"><div class="outer"><div class="inner" id="footer-info"><p><a href="https://beian.miit.gov.cn/" target="_blank">赣ICP备17009276号</a><i class="far fa-copyright"></i>2016 ~ 2024 胡飞飞</p><p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a><i class="fas fa-angle-right"></i>Theme by <a target="_blank" rel="noopener" href="https://github.com/holmofy/hexo-theme-paper">paper</a></p></div></div></footer></div><nav id="mobile-nav"><a class="mobile-nav-link" href="//www.hufeifei.cn">主页</a><a class="mobile-nav-link" href="/">博客</a><a class="mobile-nav-link" href="/archives">归档</a><a class="mobile-nav-link" target="_blank" rel="noopener" href="//algo.hufeifei.cn">算法</a><a class="mobile-nav-link" href="/book">书籍</a><a class="mobile-nav-link" href="/github">Github</a></nav><script src="//cdnjs.loli.net/ajax/libs/jquery/3.0.0/jquery.min.js"></script><link rel="stylesheet" href="//cdnjs.loli.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="//cdnjs.loli.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/script.js"></script></div><script>
  $(document).ready(function() {
    $('figure.codeblock').find('.tab').click(function() {
        var $codeblock = $(this).parent().parent().parent();
        var $tab = $(this);
        // remove "active" css class on all tabs
        $tab.siblings().removeClass('active');
        // add "active" css class on the clicked tab
        $tab.addClass('active');
        // hide all tab contents
        $codeblock.find('.highlight').hide();
        // show only the right one
        $codeblock.find('.highlight.' + $tab.text()).show();
    });
  });
  </script><script>(function (w, d, s, id) {
            if (typeof (w.webpushr) !== 'undefined') return; w.webpushr = w.webpushr || function () { (w.webpushr.q = w.webpushr.q || []).push(arguments) }; var js, fjs = d.getElementsByTagName(s)[0]; js = d.createElement(s); js.id = id; js.async = 1; js.src = "https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window, document, 'script', 'webpushr-jssdk'));webpushr('setup', { 'key': 'BPJzNs1QEtbYa3Bn0gMAQHBAzX3Jm71llGUKHTkKEUs3D9xiDYZ0DWJ3S9sfCAAJHxXEoBkUANFyONjeIlgrJUo'' });</script></body></html>