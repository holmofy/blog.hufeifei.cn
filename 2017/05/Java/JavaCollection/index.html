<!doctype html><html lang="en"><head><meta charset="utf-8"><script async src="https://www.googletagmanager.com/gtag/js?id=G-H58NSPXYPF"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-H58NSPXYPF")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),t=(e.src="https://hm.baidu.com/hm.js?b3392fb5f6d65fb10354f590338d1ee4",document.getElementsByTagName("script")[0]);t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">!function(t,e,n,c,a,i){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/95vxjpui4h",(i=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,i)}(window,document,"clarity","script")</script><title>Java Collection框架概述 | holmofy</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="baidu_union_verify" content="b7d27ec946758934fcdf3c5c26386237"><meta description="[TOC] JAVA集合框架可以是说是JAVA开发中使用次数最高的一套类，是JAVA对各种数据结构的实现。一个集合代表一组对象，使用集合框架可以独立于实现细节来操作这一组对象，而不用自己再造轮子。"><meta property="og:type" content="article"><meta property="og:title" content="Java Collection框架概述"><meta property="og:url" content="https://blog.hufeifei.cn/2017/05/Java/JavaCollection/index.html"><meta property="og:site_name" content="holmofy"><link rel="canonical" href="https://blog.hufeifei.cn/2017/05/Java/JavaCollection/index.html"><meta property="description" content="[TOC] JAVA集合框架可以是说是JAVA开发中使用次数最高的一套类，是JAVA对各种数据结构的实现。一个集合代表一组对象，使用集合框架可以独立于实现细节来操作这一组对象，而不用自己再造轮子。"><meta name="description" content="[TOC] JAVA集合框架可以是说是JAVA开发中使用次数最高的一套类，是JAVA对各种数据结构的实现。一个集合代表一组对象，使用集合框架可以独立于实现细节来操作这一组对象，而不用自己再造轮子。"><meta property="og:description" content="[TOC] JAVA集合框架可以是说是JAVA开发中使用次数最高的一套类，是JAVA对各种数据结构的实现。一个集合代表一组对象，使用集合框架可以独立于实现细节来操作这一组对象，而不用自己再造轮子。"><meta property="article:published_time" content="2017-05-04T16:00:00.000Z"><meta property="article:modified_time" content="2024-05-03T05:17:06.695Z"><meta property="article:author" content="胡飞飞"><meta property="article:tag" content="Java"><meta property="article:tag" content="DB"><meta property="article:tag" content="Alibaba"><meta property="article:tag" content="Holmofy"><meta property="article:tag" content="胡飞飞"><meta property="twitter:card" content="summary"><script data-ad-client="ca-pub-7111912103882824" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7111912103882824" crossorigin="anonymous"></script><script async custom-element="amp-auto-ads" src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js"></script><script type="text/javascript" src="//cpro.baidustatic.com/cpro/ui/cm.js" async defer></script><link rel="alternate" href="/atom.xml" title="holmofy" type="application/atom+xml"><link rel="icon" href="//www.hufeifei.cn/favicon.jpg"><link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"><link href="//unpkg.com/@waline/client@v3/dist/waline.css" rel="stylesheet" type="text/css"><link href="//at.alicdn.com/t/font_841402_efkj8jo1xld.css" rel="stylesheet" type="text/css"><link rel="stylesheet" href="//cdnjs.loli.net/ajax/libs/font-awesome/5.15.3/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/style.css"><link rel="dns-prefetch" href="//static.zhimg.com"><link rel="dns-prefetch" href="//at.alicdn.com"><link rel="dns-prefetch" href="//cdn.jsdelivr.net"><link rel="dns-prefetch" href="//img-blog.csdn.net"><link rel="dns-prefetch" href="//img-blog.csdnimg.cn"><meta name="generator" content="Hexo 6.3.0"><link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml"><style>
    figure.codeblock {
       margin: 0;
    }
    figure figcaption .tabs {
      display: flex;
      margin: 0;
    }
    figure figcaption .tabs .tab {
      cursor: pointer;
      list-style: none;
      padding: 5px 15px;
    }
    figure figcaption .tabs .tab.active {
      background: #2d2d2d;
      color: white;
    }
  </style></head><body><amp-auto-ads type="adsense" data-ad-client="ca-pub-7111912103882824"></amp-auto-ads><div id="container"><div id="wrap"><header id="header"><div class="outer" id="header-outer"><div class="inner" id="header-inner"><nav id="main-nav"><a class="nav-icon" id="main-nav-toggle"><i class="fas fa-bars"></i></a><a class="main-nav-link" href="//www.hufeifei.cn">主页</a><a class="main-nav-link" href="/">博客</a><a class="main-nav-link" href="/archives">归档</a><a class="main-nav-link" target="_blank" rel="noopener" href="//algo.hufeifei.cn">算法</a><a class="main-nav-link" href="/book">书籍</a><a class="main-nav-link" href="/github">Github</a></nav><nav id="sub-nav"><a class="nav-icon" id="nav-rss-link" href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a><a class="nav-icon" id="nav-search-btn" title="Search"><i class="fas fa-search"></i></a></nav><div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="fas fa-search"></i></button><input type="hidden" name="sitesearch" value="https://blog.hufeifei.cn"></form></div></div></div></header><div class="outer"><section id="main"><article class="article article-type-post" id="post-Java/JavaCollection" itemscope itemprop="blogPost"><div class="article-meta"><a class="article-date" href="/2017/05/Java/JavaCollection/"><time datetime="2017-05-04T16:00:00.000Z" itemprop="datePublished">2017-05-05</time></a><div class="article-category"><a class="article-category-link" href="/categories/JAVA/">JAVA</a></div><div class="article-views leancloud_visitors" id="/2017/05/Java/JavaCollection/" data-flag-title="Java Collection框架概述" title="Views"><i class="fas fa-eye"></i><span class="waline-pageview-count" data-path="/2017/05/Java/JavaCollection/"></span></div></div><div class="article-inner"><header class="article-header" style="text-align:center"><h1 class="article-title" itemprop="name">Java Collection框架概述</h1></header><div class="article-entry" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>[TOC]</p><p>JAVA集合框架可以是说是JAVA开发中使用次数最高的一套类，是JAVA对各种数据结构的实现。一个集合代表一组对象，使用集合框架可以独立于实现细节来操作这一组对象，而不用自己再造轮子。</p><h2>集合接口概要：</h2><p><img src="http://img-blog.csdn.net/20170505163102593?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="集合接口"></p><p>再加上并发库中的集合接口：</p><p><img src="http://img-blog.csdn.net/20170505163246463?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="所有集合接口"></p><blockquote><p>在下面的标题中用concurrent标记这个类是<code>java.util.concurrent</code>包中的集合</p></blockquote><h2>List （since 1.2）</h2><p>有序列表，代表一组<strong>有序可重复</strong>对象。</p><p><strong>实现类：</strong></p><p><img src="http://img-blog.csdn.net/20170505163345542?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="List实现类"></p><h4>Vector（since 1.0）：</h4><p>与ArrayList实现基本类似，都是用Object数组存储，区别在于Vector是线程安全的，而且Vector扩容策略也比较老式：</p><p><code>newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity)</code> (容量成倍增加)</p><p>如果构造时指定了capacityIncrement 扩容增量，则每次增加capacityIncrement (线性增加)。</p><p>该类完全可以使用<code>Collections.synchronizedList(new ArrayList())</code>代替。</p><blockquote><p>JDK1.0当初的集合设计主要模仿C++的STL，可惜1.0的时候没有泛型(Java泛型与C++的模板本质上是不同的，不可相提并论)，同时又为了线程安全加了<code>synchronized</code>锁，重点是当初没有面向接口设计整个集合框架，最终导致了这个不伦不类的设计。</p></blockquote><h4>Stack（since 1.0）：</h4><p>“后进先出(LIFO)”的栈式结构，继承自Vector，这也决定了它被淘汰的命运：因为<strong>Deque接口的实现类可以作为栈使用</strong></p><blockquote><p>查看<a href="#Deque">Deque</a>接口</p></blockquote><h4>ArrayList（since 1.2）：</h4><p>数组实现的List，自动扩容，Java8.0中一般扩容策略为<code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是说每次扩容新容量为原始容量的<strong>1.5倍</strong>，另外在第一次添加元素的时候才申请内存(<strong>默认初始容量为10</strong>)。</p><p>ArrayList绝对是集合框架中使用次数最多的类。</p><h4>LinkedList（since 1.2）：</h4><p>双向链表实现的List，在后续Java版本中又相继实现了Queue，Deque接口，所以<strong>该类可以当作链表、队列、栈</strong>使用。</p><p>因为LinkedList使用双向链表实现，所以作为List使用其查找元素效率不如ArrayList，但是在中间插入元素的效率比ArrayList高。</p><blockquote><p>更多内容查看<a href="#Queue">Queue</a>和<a href="#Deque">Deque</a>接口。</p></blockquote><h4>CopyOnWriteArrayList（since 1.5，concurrent）：</h4><p>通过拷贝数组来保证写线程不会影响到读线程(实现所谓的读写分离)，所以该类允许读写同时进行；</p><p>同时使用ReentrantLock来实现多线程执行写操作的同步。</p><p>但是拷贝数组毕竟耗时，因此该类不适合用在写操作频繁的情况。</p><h2>Map （since 1.2）</h2><blockquote><p>把Map放在前面是因为，Set的实现类是基于Map或List实现的。</p></blockquote><p>表示一系列键值对映射(Key-Value)的集合，由于Map通过Key来查找Value，所以Key不能重复。</p><p><strong>实现类：</strong></p><p><img src="http://img-blog.csdn.net/20170505163429840?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="Map实现类"></p><h4>Hashtable（since 1.0）：</h4><p>哈希表，与HashMap实现原理相同，都是使用链式地址法解决哈希碰撞的。</p><p>与HashMap的区别：</p><ul><li>Hashtable使用synchronize关键字实现线程安全的，而HashMap不能保证线程安全；这一点与Vector相同</li><li>Hashtable不允许Key为null(会抛空指针异常)，而HashMap允许。</li></ul><p>Hashtable基本被淘汰，Java的后续版本都没有对其升级。</p><blockquote><p>更多相关内容可以查看HashMap</p></blockquote><h4>Propreties（since 1.0）：</h4><p>严格的说，这个类不能算是容器类。这个类一般用于存取属性配置文件的，该类实际上是一个<code>Hashtable&lt;Object,Object&gt;</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Properties</span> <span class="keyword">extends</span> <span class="title class_">Hashtable</span>&lt;Object,Object&gt;</span><br></pre></td></tr></table></figure><h4>HashMap（since 1.2）：</h4><p>HashMap在集合框架中的地位举足轻重，所以Java在每个版本中都对它进行了大大小小的性能优化。</p><p><strong>HashMap对计算hash值的优化</strong></p><p>哈希表，根据Key生成hashCode从而确定存储位置，时间复杂度为1，获取哈希值方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="comment">// 低位与高位异或，目的是让HashMap的bucket较小时，高位也能参与哈希取余</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于hash相同的元素(也就是哈希碰撞)使用链表(<strong>拉链法</strong>)进行延伸存储，拉链使用<strong>头插法</strong>。</p><p>当总体容量达到<strong>数组长度的0.75倍</strong>这个默认阈值后，重新定容，将数组长度扩大到原来的两倍，并将原来的数据重新计算hash存入新表中，这个过程叫做<strong>rehash</strong>。</p><p>HashMap重新定容耗时耗资源，所以如果能确定存取元素的最大容量，最好在构造时通过initialCapacity参数来指定容量，**默认初始容量为16($2^4$)**。</p><p>同时也可以通过构造方法中的<code>loadFactor</code>参数来自定义扩容因子，<strong>默认扩容因子为0.75</strong>。</p><p>另外，**HashMap的容量始终保持为$2^n$**。这样设计为了方便直接根据哈希值定位索引(用<code>&amp;</code>位运算取代<code>%</code>取余运算)：</p><p><code>index = (length - 1) &amp; hash</code></p><p>当$length=2^n$时，<code>length-1</code>的二进制为全1，<code>(length-1) &amp; hash</code>​可以达到取余的效果。</p><p>所以在通过initialCapacity参数指定构造时的容量，会有下面这个运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialCapacity指定为5，6，7的时候，实际容量都为8</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从最高位的1开始，后面的全是1</span></span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 最后在全1的数上加1，从而得到2^n</span></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>官方文档中将这个延伸的链表称为桶，个人觉得还是叫“拉链”更为形象。下面当拉链进化成红黑树的时候，叫“拉链”就有点不合适了。</p></blockquote><p><strong>Java8中使用红黑树对拉链法进行优化</strong></p><p>当出现所有的元素都集中在一条拉链上的极端情况时，HashMap就退化成链表，导致查找性能下降。</p><p>我们知道红黑树能够实现$log_2(N)$级别的查找速度，所以Java8使用红黑树对拉链进行了优化。</p><p>在HashMap中有这么几个常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当拉链长度增长到8的时候，HashMap会将这条拉链转成红黑树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当拉链长度缩短到6的时候，HashMap又会把红黑树转换回拉链</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 只有当HashMap的数量达到64的时候才会进行红黑树转换</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 以避免数量较少的时候刚转成红黑树添加几个元素后又需要rehash</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br></pre></td></tr></table></figure><h4>WeakHashMap（since 1.2）：</h4><p>使用上与HashMap类似，区别在于这里的Entry对象(Key-Value对)继承自WeakReference。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakHashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="comment">// GC回收key之后，会把key对应的Entry放到这个队列中</span></span><br><span class="line">    <span class="comment">// WeakHashMap每次都会检查这个队列，把被GC回收的Entry清除掉</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;Object&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        V value;  <span class="comment">// 节点存储的值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash; <span class="comment">// 缓存hash值,避免重复计算hash值</span></span><br><span class="line">        Entry&lt;K,V&gt; next; <span class="comment">// 下一个节点,主要用于拉链</span></span><br><span class="line">        Entry(Object key, V value, ReferenceQueue&lt;Object&gt; queue, <span class="comment">// 这里传入引用队列</span></span><br><span class="line">              <span class="type">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(key, queue); <span class="comment">// 引用的对象和队列</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说<strong>Entry中持有Key的弱引用</strong>，从而不影响GC的垃圾回收，Key被系统回收后会自动将Entry放入引用队列。WeakHashMap每次读写操作都会遍历这个引用队列，从而把已过期的Entry对象从表中删除。</p><p>另外WeakHashMap与HashMap计算hash的算法也略有不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WeakHashMap也进行了二次幂优化：<code>hash &amp; (length-1)</code></p><h4>IdentityHashMap（since 1.4）：</h4><p>与HashMap功能相同，区别在于IdentityHashMap使用<code>k1 == k2</code>判断key是否相同，也就是k1和k2是同一个对象的引用才认为是同一个key；</p><p>而HashMap则是<code>(k1 == null ? k2 == null ：k1.equals(k2) )</code>，也就是两个对象满足内容相同就认为是同一个key。</p><blockquote><p>根据上述特性，<strong>IdentityHashMap允许Key重复</strong>。</p></blockquote><p>所以IdentityHashMap允许两个内容相同的对象作为Key，另外获取与HashMap获取哈希值的方式不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object x, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> System.identityHashCode(x); <span class="comment">// 使用的是对象的地址(暂且理解为地址)</span></span><br><span class="line">	<span class="keyword">return</span> ((h &lt;&lt; <span class="number">1</span>) - (h &lt;&lt; <span class="number">8</span>)) &amp; (length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>LinkedHashMap（since 1.4）：</h4><p>LinkedHashMap继承自HashMap，在HashMap的基础上，<strong>通过维护一个双向链表来保存元素插入的顺序</strong>。</p><p>根据该双向链表就可以知道哪些数据是存入时间较长的，所以LinkedHashMap可以<strong>用作数据的LRU缓存</strong>(可以通过重载<strong>removeEldestEntry</strong>方法来定义缓存策略)。</p><p>下面是一个使用LinkedHashMap实现的最简单<strong>L</strong>east <strong>r</strong>ecently <strong>u</strong>sed缓存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LruCache</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ENTRIES</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>EnumMap（since 1.5）：</h4><p>元素只能是枚举类，构造EnumMap时指定枚举类型。<strong>底层使用数组实现存储</strong>，所以<strong>数据比较紧凑</strong>。Key不允许为null。使用相对比较少。</p><p>TreeMap（since 1.2）：NavigableMap的实现类。<a href="#NavigableMap">查看NavigableMap接口实现类</a>。</p><p>ConcurrentHashMap（since 1.5，concurrent）：ConcurrentMap的实现类。<a href="#ConcurrentMap">查看ConcurrentMap接口实现类</a>。</p><p>ConcurrentSkipListMap（since 1.6，concurrent）：ConcurrentNavigableMap的实现类。<a href="#ConcurrentNavigableMap">查看ConcurrentNavigableMap接口实现类</a>。</p><blockquote><p>Android中还提供了一个数组实现的ArrayMap。HashMap将Key-Value包装成一个类对象，然后使用该类的数组。而<strong>ArrayMap直接将Key-Value放在一个Object数组中，通过2*n，2*n+1来对Key-Value进行区分</strong>，这和EnumMap在一定程度有有点相似。</p></blockquote><h3>SortedMap(since 1.2)与NavigableMap(since 1.6)</h3><p><strong>SortedMap</strong>在Map的基础上对Key自动排序</p><table><thead><tr><th align="left">方法</th><th align="left">方法说明</th></tr></thead><tbody><tr><td align="left">Comparator&lt;? super K&gt; comparator()</td><td align="left">返回该Map中Key使用的比较器</td></tr><tr><td align="left">SortedMap&lt;K,V&gt; headMap(K toKey)</td><td align="left">头：小于toKey的所有Key-Value对，不包括toKey</td></tr><tr><td align="left">SortedMap&lt;K,V&gt; tailMap(K fromKey)</td><td align="left">尾：大于fromKey的所有Key-Value对，包括fromKey</td></tr><tr><td align="left">SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey)</td><td align="left">fromKey到toKey之间的所有Key-Value对，包括fromKey，不包括toKey。</td></tr><tr><td align="left">K firstKey()</td><td align="left">第一个Key，也就是最小的Key</td></tr><tr><td align="left">K lastKey()</td><td align="left">最后一个Key，也就是最大的Key</td></tr></tbody></table><p>SortedMap实现类：</p><p><img src="http://img-blog.csdn.net/20170505163707892?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="SortMap实现类"></p><p><strong>NavigableMap</strong>在SortedMap的基础上添加了更多的有序Map的操作。下图是NavigableMap增加的操作，更多细节可以查看Java官方文档。</p><p><img src="http://img-blog.csdn.net/20170505163822018?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="NaviableMap增加的操作"></p><p>NavigableMap实现类：</p><p><img src="http://img-blog.csdn.net/20170505164048176?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="NavigableMap实现类"></p><h4>TreeMap（since 1.2）：</h4><p>通过<strong>红黑树</strong>（一种自平衡二叉查找树树）实现的有序Map映射，因为红黑树的元素查找类似于<strong>二分查找</strong>，所以保证了增删改查等方法的时间复杂度$log_2(N)$。</p><p>因为元素是有序存储，所以<strong>需要实现Comparable接口或者在构造方法中指定Comparator比较器</strong>。</p><p>因为元素之间需要进行比较，所以TreeMap不允许元素为null(会抛空指针异常)。</p><blockquote><p>ConcurrentSkipListMap可以<a href="#ConcurrentNavigableMap">查看ConcurrentNavigableMap接口的实现类</a>。</p></blockquote><h3>ConcurrentMap （since 1.5）与ConcurrentNavigableMap （since 1.6）</h3><p>在Map的基础上添加了一些原子操作，从而实现无锁数据结构，具有多线程高并发特性，更多内容可以查看<a target="_blank" rel="noopener" href="http://blog.csdn.net/holmofy/article/details/73824757">这篇文章</a>。</p><table><tr><td align="center"><b>方法</b></td><td align="center"><b>等价操作</b></td></tr><tr><td><code>V putIfAbsent(K key, V value)</code></td><td><pre><code>if (!map.containsKey(key))
    return map.put(key, value);
 else<font></font>
    return map.get(key); </code></pre></td></tr><tr><td><code>boolean remove(Object key, Object value)</code></td><td><pre><code>if (map.containsKey(key) &amp;&amp; Objects.equals(map.get(key), value)) &#123;<font></font>
    map.remove(key);
    return true;
 &#125; else
    return false; </code></pre></td></tr><tr><td><code>boolean replace(K key, V oldValue, V newValue)</code></td><td><pre><code>if (map.containsKey(key) &amp;&amp; Objects.equals(map.get(key), oldValue)) &#123;
    map.put(key, newValue);
    return true;
 &#125; else
    return false; </code></pre></td></tr><tr><td><code>V replace(K key, V value)</code></td><td><pre><code>if (map.containsKey(key)) &#123;
    return map.put(key, value);
 &#125; else
    return null; </code></pre></td></tr></table><p><strong>ConcurrentMap 实现类：</strong></p><p><img src="http://img-blog.csdn.net/20170505164202394?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="ConcurrentMap实现类"></p><p><strong>ConcurrentNavigableMap</strong>是ConcurrentMap与NavigableMap的结合体：既有序又高并发。</p><h4>ConcurrentHashMap（since 1.5，concurrent）：</h4><p>该类用来代替Hashtable实现多线高并发操作。与Hashtable相比支持高并发的读取操作，Hashtable由于所有的方法都加上了同步锁(包括读取操作)，而ConcurrentHashMap对读取操作不加锁，对写入操作的关键部分加同步锁，进而降低锁粒度，所以在多线程操作的效率上ConcurrentHashMap比Hashtable更加高效。</p><h4>ConcurrentSkipListMap（since 1.6，concurrent）：</h4><p>ConcurrentNavigableMap接口的唯一实现类。该数据结构使用<strong>跳跃链表</strong>实现，跳跃链表是一种查找速度与二叉查找树相当的数据结构，基于多级并联的链表实现，相较二叉查找树要消耗更多的内存资源，但实现起来比二叉查找树简单的多。关于跳跃链表的更多细节可以查看<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8">维基百科</a>。</p><h2>Set （since 1.2）</h2><p>无序集合，代表一组无序不可重复的对象。与数学中的集合特性类似：无序性，互异性。</p><p><strong>Set 实现类：</strong></p><p><img src="http://img-blog.csdn.net/20170505164232004?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="Set的实现类"></p><h4>HashSet（since 1.2）：</h4><p>一个<strong>底层由HashMap实现</strong>的无序集合。只使用了HashMap的Key，而<strong>没有使用Value</strong>，HashSet的所有元素的Value都是一个Object常量：<code>private static final Object PRESENT = new Object();</code>。因为HashMap允许Key为null，所以HashSet中的元素也<strong>允许为null</strong>。</p><h4>LinkedHashSet（since 1.4）：</h4><p>底层由LinkedHashMap实现。LinkedHashSet继承自HashSet，该类只有四个构造函数，这四个构造函数都是调用HashSet的这个构造函数(该构造方法包内私有)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>EnumSet（since 1.5）：</h4><p>只存储枚举类型的Set。根据具体的枚举类型，可以得到枚举类中的所有枚举值，进一步就确定这个集合最大的容量了。EnumSet就直接把所有枚举值放到一个数组，然后通过类似于BitSet的位图算法并借助枚举类值的ordinal作为索引来标记集合中是否有对应的枚举值。按照枚举类的大小它分成了两种实现，枚举值个数小于64的直接用一个<code>long</code>进行标记，这就是<code>RegularEnumSet</code>的实现；枚举值个数大于64的，则用<code>long[]</code>进行标记，这就是<code>JumboEnumSet</code>的实现。</p><p><img src="http://img-blog.csdn.net/20170505164302348?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="EnumSet的静态方法"></p><h4>CopyOnWriteArraySet（since 1.5，concurrent）：</h4><p>基于CopyOnWriteArraySet实现的无序集，<strong>与CopyOnWriteArrayList一样不适合写操作频繁的场合</strong>。由于底层使用数组实现，所以它的<strong>查找速度不如HashSet</strong>。</p><blockquote><p>ConcurrentSkipListSet可以<a href="#NavigableSet">查看NavigableSet接口</a>。</p></blockquote><h3>SortedSet （since 1.2）与NavigableSet （since 1.6）</h3><p><strong>SortedSet</strong> ：有序集合，在Set基础上提供排序功能，由于Set基本上都是使用Map实现的(除了上面提到的EnumSet)，所以SortedSet的排序功能也来自于SortedMap。</p><table><thead><tr><th align="left">方法</th><th align="left">方法说明</th></tr></thead><tbody><tr><td align="left">Comparator&lt;? super K&gt; comparator()</td><td align="left">返回该Set元素使用的比较器</td></tr><tr><td align="left">SortedSet<e>headSet(E toElement)</e></td><td align="left">头：小于toElement的所有元素，不包括toElement</td></tr><tr><td align="left">SortedSet<e>tailSet(E fromElement)</e></td><td align="left">尾：大于fromElement的所有元素，包括fromElement</td></tr><tr><td align="left">SortedSet<e>subSet(E fromElement, E toElement)</e></td><td align="left">fromElement到toElement之间的所有元素对，包括fromElement，不包括toElement。</td></tr><tr><td align="left">E first()</td><td align="left">第一个元素，也就是最小的元素</td></tr><tr><td align="left">E last()</td><td align="left">最后一个元素，也就是最大的元素</td></tr></tbody></table><p><strong>NavigableSet</strong>： 在SortedSet的基础上添加了更多的有序Set的操作。下图是NavigableSet增加的操作，更多细节可以查看Java官方文档。</p><p><img src="http://img-blog.csdn.net/20170505164416635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="NavigableSet增加的操作"></p><p><strong>NavigableSet实现类：</strong></p><p><img src="http://img-blog.csdn.net/20170505164537355?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="SortSet的实现类"></p><h4>TreeSet（since 1.2）：</h4><p>底层由TreeMap实现，与HashSet一样只使用Key不使用Value，Value都是同一个对象：<code>private static final Object PRESENT = new Object();</code></p><h4>ConcurrentSkipListSet（since 1.6，concurrent）：</h4><p>基于ConcurrentSkipListMap实现的有序集，因为ConcurrentSkipListMap支持并发操作，ConcurrentSkipListSet也支持并发操作。</p><h2>Queue （since 1.5）</h2><p><img src="http://img-blog.csdn.net/20170710235752953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="队列示意图"><br>在普通集合的基础上添加了一些队列操作：</p><table><thead><tr><th align="center">操作</th><th align="center">失败抛出异常</th><th align="center">失败返回false</th></tr></thead><tbody><tr><td align="center">入队</td><td align="center">add(e)</td><td align="center">offer(e)</td></tr><tr><td align="center">出队</td><td align="center">remove()</td><td align="center">poll()</td></tr><tr><td align="center">检查</td><td align="center">element()</td><td align="center">peek()</td></tr></tbody></table><p>看Queue的实现类之前，先来看一张Queue的继承图</p><p><img src="http://img-blog.csdn.net/20170505164720883?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="Queue继承图"></p><p>Queue这个接口仿佛就是为了并发库而设计的，所以Queue的实现类也几乎都是支持多线程的。</p><p><strong>Queue实现类：</strong></p><p><img src="http://img-blog.csdn.net/20170505164752117?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="Queue的实现类"></p><h4>PriorityQueue（since 1.5）：</h4><p>优先级队列，使用数组实现<strong>二叉堆</strong>(完全二叉树)，从而对元素进行排序，队列中的元素需要实现Comparable接口或者在构造方法中指定Comparator比较器。</p><h4>ConcurrentLinkedQueue（since 1.5，concurrent）：</h4><p>无界限非阻塞的并发队列，使用了非阻塞同步算法(CAS)实现无锁数据结构，该类与BlockingQueue接口的实现类不同，BlockingQueue通过线程阻塞来实现生产者与消费者的同步，而无锁数据结构不会导致线程阻塞。关于CAS的内容可以参考<a target="_blank" rel="noopener" href="http://blog.csdn.net/holmofy/article/details/73824757">这篇文章</a>。</p><h3>BlockingQueue （since 1.5，concurrent）</h3><p>阻塞队列。在Queue的基础上进行阻塞扩展，如果<strong>队列为空读取元素会阻塞</strong>，如果<strong>队列已满添加元素会阻塞</strong>。用生产者消费者模式来解释就是：当生产者向队列添加元素但队列已满时，生产者会被阻塞；当消费者从队列移除元素但队列为空时，消费者会被阻塞。阻塞队列是线程间通信常用的手段。</p><table border="" cellpadding="3" cellspacing="1"><caption>BlockingQueue方法的总结</caption><tbody><tr><td></td><td align="CENTER"><em>抛出异常</em></td><td align="CENTER"><em>返回false</em></td><td align="CENTER"><em>阻塞</em></td><td align="CENTER"><em>超时</em></td></tr><tr><td><b>入队</b></td><td><code>add(e)</code></td><td><code>offer(e)</code></td><td><code>put(e)</code></td><td><code>offer(e, time, unit)</code></td></tr><tr><td><b>出队</b></td><td><code>remove()</code></td><td><code>poll()</code></td><td><code>take()</code></td><td><code>poll(time, unit)</code></td></tr><tr><td><b>检查</b></td><td><code>element()</code></td><td><code>peek()</code></td><td><em>无需该操作</em></td><td><em>无需该操作</em></td></tr></tbody></table><p><strong>实现类：</strong></p><p><img src="http://img-blog.csdn.net/20170505164906876?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="BlockingQueue实现类"></p><h4>ArrayBlockingQueue（since 1.5，concurrent）：</h4><p><strong>数组实现</strong>的阻塞队列，数组大小<strong>不会自动增长</strong>。队列已满，生产者线程阻塞。元素不允许为null。</p><h4>DelayQueue（since 1.5，concurrent）：</h4><p>使用PriorityQueue与ReentrantLock实现的延时阻塞队列，该集合存储的元素需要实现Delayed接口，该集合通过Delayed接口来获取元素对应的延时时长。元素不能为null。</p><h4>LinkedBlockingQueue（since 1.5）：</h4><p>单向链表实现的阻塞队列，该集合功能上类似与ArrayBlockingQueue。LinkedBlockingQueue可以在构造方法中指定最大容量，如果没有指定则为Integer.MAX_VALUE，相当于不限容，所以LinkedBlockingQueue相比ArrayBlockingQueue有更大的吞吐量。元素不允许为null。</p><h4>PriorityBlockingQueue（since 1.5）：</h4><p>在PriorityQueue的基础上对读写操作加重入锁(ReentrantLock)来达到多线程的同步。</p><h4>SynchronousQueue（since 1.5）：</h4><p>这个类是一个比较奇葩的容器，或许不能称其为容器，因为它是一个0容量的队列，不像ArrayBockingQueue和LinkedBlockingQueue那样有缓冲区，SynchronousQueue没有缓冲区，内部直接通过TransferQueue(公平模式)或TransferStack(不公平模式)来进行生产者与消费者的数据传递（这是Java6之后的实现方式），公平模式使生产者(或消费者)线程排队依次添加(或取出)，而费公平模式允许恶性竞争，使用SynchronousQueue可以让生产者线程与消费者线程之间的同步：生产者生产一个消费者就消费一个。SynchronousQueue不允许添加null元素。<br><img src="http://img-blog.csdn.net/20170711000357264?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="公平模式下的SynchronousQueue示意图"></p><h3>Deque （since 1.6）</h3><p><img src="http://img-blog.csdn.net/20170711000453655?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="Deque示意图"><br>双端队列，两端都支持插入删除。既可以把它当Queue用又可以把它当Stack用。</p><table border="" cellpadding="3" cellspacing="1"><tbody><tr><td></td><td align="CENTER" colspan="2"><b>第一元素（头）</b></td><td align="CENTER" colspan="2"><b>最后元素（尾）</b></td></tr><tr><td></td><td align="CENTER"><em>抛出异常</em></td><td align="CENTER"><em>返回false</em></td><td align="CENTER"><em>抛出异常</em></td><td align="CENTER"><em>返回false</em></td></tr><tr><td><b>插入</b></td><td><code>addFirst(e)</code></td><td><code>offerFirst(e)</code></td><td><code>addLast(e)</code></td><td><code>offerLast(e)</code></td></tr><tr><td><b>删除</b></td><td><code>removeFirst()</code></td><td><code>pollFirst()</code></td><td><code>removeLast()</code></td><td><code>pollLast()</code></td></tr><tr><td><b>检查</b></td><td><code>getFirst()</code></td><td><code>peekFirst()</code></td><td><code>getLast()</code></td><td><code>peekLast()</code></td></tr></tbody></table><p><strong>实现类：</strong></p><p><img src="http://img-blog.csdn.net/20170505164939227?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSG9sbW9meQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" rel="external noreferrer nofollow noopener" referrerpolicy="no-referrer" alt="Deque实现类"></p><p>LinkedList（since 1.2）：双向链表实现双端队列，前面已经提过了。</p><p>ArrayDeque（since 1.6）：</p><p>数组实现的双端队列。容量按两倍的方式自动增长。不允许元素为null。双端队列既可以当栈用又可以当队列用，作为栈使用速度比Stack类更快，作为队列用速度比LinkedList类更快。</p><p>ConcurrentLinkedDeque（since 1.5，concurrent）：</p><p>无界限非阻塞的并发双端队列，与ConcurrentLinkedQueue一样使用非阻塞同步算法实现。</p><p>LinkedBlockingDeque（since 1.7，concurrent）：</p><p>BlockingDeque接口的实现类。<a href="#BlockingDeque">查看BlockingDeque接口</a></p><h3>BlockingDeque （since 1.6）</h3><p>BlockingDeque与Deque的关系类似于BlcokingQueue与Queue的关系。</p><table border="" cellpadding="3" cellspacing="1"><caption>BlockingDeque方法的总结</caption><tbody><tr><td align="CENTER" colspan="5"><b>第一元素（头）</b></td></tr><tr><td></td><td align="CENTER"><em>抛出异常</em></td><td align="CENTER"><em>返回false</em></td><td align="CENTER"><em>阻塞</em></td><td align="CENTER"><em>超时</em></td></tr><tr><td><b>插入</b></td><td><code>addFirst(e)</code></td><td><code>offerFirst(e)</code></td><td><code>putFirst(e)</code></td><td><code>offerFirst(e, time, unit)</code></td></tr><tr><td><b>删除</b></td><td><code>removeFirst()</code></td><td><code>pollFirst()</code></td><td><code>takeFirst()</code></td><td><code>pollFirst(time, unit)</code></td></tr><tr><td><b>检查</b></td><td><code>getFirst()</code></td><td><code>peekFirst()</code></td><td><em>无需该操作</em></td><td><em>无需该操作</em></td></tr><tr><td align="CENTER" colspan="5"><b>最后元素（尾）</b></td></tr><tr><td></td><td align="CENTER"><em>抛出异常</em></td><td align="CENTER"><em>返回false</em></td><td align="CENTER"><em>阻塞</em></td><td align="CENTER"><em>超时</em></td></tr><tr><td><b>插入</b></td><td><code>addLast(e)</code></td><td><code>offerLast(e)</code></td><td><code>putLast(e)</code></td><td><code>offerLast(e, time, unit)</code></td></tr><tr><td><b>删除</b></td><td><code>removeLast()</code></td><td><code>pollLast()</code></td><td><code>takeLast()</code></td><td><code>pollLast(time, unit)</code></td></tr><tr><td><b>检查</b></td><td><code>getLast()</code></td><td><code>peekLast()</code></td><td><em>无需该操作</em></td><td><em>无需该操作</em></td></tr></tbody></table><p><strong>实现类：</strong></p><ul><li>java.util.concurrent包<ul><li>LinkedBlockingDeque（since 1.7）：双向链表实现的双端阻塞队列。与LinkedBlockingQueue类似，只是说这个类还可以当作栈使用。</li></ul></li></ul><h3>TransferQueue （since 1.7）</h3><p>在BlockingQueue的基础上更进一步，生产者会一直阻塞直到所添加到队列的元素被某一个消费者所消费（不仅仅是添加到队列里就完事）。这个和SynchronousQueue有点类似，但区别在于SynchronousQueue只允许一个生产者线程将数据传递给一个消费者线程，其他线程想要添加或取出数据就会阻塞；而TransferQueue可以允许多个生产者线程同时与多个消费者线程进行数据传递，所以当我们把TransferQueue的容量设为0时TransferQueue就等价于SynchronousQueue了。</p><table border="0" cellpadding="3" cellspacing="0"><tr><th scope="col">返回值</th><th scope="col">方法说明</th></tr><tr id="i0"><td><code>int</code></td><td><code><span>getWaitingConsumerCount</span>()</code><div>返回调用<code>BlockingQueue.take()</code>或<code>BlockingQueue.poll</code>消费者方法而阻塞的消费者的数量</div></td></tr><tr id="i1"><td><code>boolean</code></td><td><code><span>hasWaitingConsumer</span>()</code><div><code>true</code>是否有消费者正在调用<code>BlockingQueue.take()</code>或<code>BlockingQueue.poll</code>消费者方法</div></td></tr><tr id="i2"><td><code>void</code></td><td><code><span>transfer</span>(E&nbsp;e)</code><div>将元素e转交给消费者，如有必要该方法阻塞以等待消费者将元素e消费。</div></td></tr><tr id="i3"><td><code>boolean</code></td><td><code><span>tryTransfer</span>(E&nbsp;e)</code><div>如果可以立即将元素e转交给等待的消费者返回true，否则返回false。</div></td></tr><tr id="i4"><td><code>boolean</code></td><td><code><span>tryTransfer</span>(E&nbsp;e, long&nbsp;timeout, TimeUnit&nbsp;unit)</code><div>如果可以在指定时间内将元素转交给消费者返回true，否则返回false。</div></td></tr></table>**实现类：**<ul><li>java.util.concurrent包<ul><li>LinkedTransferQueue（since 1.7）：TransferQueue接口唯一的一个实现类，相关功能可以查看TransferQueue接口的定义。注意的是<code>LinkedTransferQueue.size()</code>方法与大多数集合不一样，该类没有成员变量中没有保存容器的size，size()方法会临时性的去遍历整个链表来计算元素个数，所以这是个非常耗时的操作，而且由于遍历过程中可能有另外的线程操作，所以该方法获取的size可能是不准确的。</li></ul></li></ul><h2>Collections工具类</h2><h3>Collections工具类中的包装类</h3><h4>Collections.unmodifiable 不可修改包装类</h4><p>经过unmodifiable方法包装的集合对象将成为只读对象，对只读的集合进行add，remove等修改操作将会抛出异常。这个方法使用场景比较广泛。比如说一个公司(Company)有一个字段为员工表(employeeList)，同时有一个获取员工表的方法<code>List getEmployeeList()</code>，我们希望员工的删减只能通过Company类中的指定方法来修改，<code>List getEmployeeList()</code>方法返回员工表但是不能被外部修改，此时就需要使用unmodifiableList对employeeList进行包装了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;Employee&gt; employeeList;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加员工</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEmployee</span><span class="params">(Employee newEmployee)</span> &#123;</span><br><span class="line">		employeeList.add(newEmployee);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 删除员工</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeEmployee</span><span class="params">(Employee fireEmployee)</span> &#123;</span><br><span class="line">		employeeList.remove(fireEmployee);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 该方法返回的员工表只读，不允许外部对员工表进行修改。</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getEmployeeList</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.unmodifiableList(employeeList);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Collections中的unmodified方法有以下几个：</p><ul><li><code>public static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c)</code></li><li><code>public static &lt;T&gt; List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li><li><code>public static &lt;T&gt; Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; s)</code></li><li><code>public static &lt;T&gt; SortedSet&lt;T&gt; unmodifiableSortedSet(SortedSet&lt;T&gt; s)</code></li><li><code>public static &lt;T&gt; NavigableSet&lt;T&gt; unmodifiableNavigableSet(NavigableSet&lt;T&gt; s)</code></li><li><code>public static &lt;K,V&gt; Map&lt;K,V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li><li><code>public static &lt;K,V&gt; SortedMap&lt;K,V&gt; unmodifiableSortedMap(SortedMap&lt;K, ? extends V&gt; m)</code></li><li><code>public static &lt;K,V&gt; NavigableMap&lt;K,V&gt; unmodifiableNavigableMap(NavigableMap&lt;K, ? extends V&gt; m)</code></li></ul><blockquote><p>这与Google Guava中的Immutable集合工具类有点类似。</p></blockquote><h4>Collections.synchronized 同步包装类</h4><p>synchronized包装后的集合是线程同步的，比如ArrayList对象可以经过synchronizedList方法进行包装从而达到线程同步的目的，有了这个线程同步的包装类，ArrayList可以完全替代Vector。</p><ul><li><code>public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c)</code></li><li><code>public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code></li><li><code>public static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</code></li><li><code>public static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s)</code></li><li><code>public static &lt;T&gt; NavigableSet&lt;T&gt; synchronizedNavigableSet(NavigableSet&lt;T&gt; s)</code></li><li><code>public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code></li><li><code>public static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m)</code></li><li><code>public static &lt;K,V&gt; NavigableMap&lt;K,V&gt; synchronizedNavigableMap(NavigableMap&lt;K,V&gt; m)</code></li></ul><h4>Collections.checked 动态类型检查包装类</h4><p>这主要归咎于Java的类型擦除(Java的泛型与C++的泛型不同，准确的说C++应该叫做“模板”，C++在编译后会根据模版的使用情况生成多套可执行代码，而Java使用同一套代码)。Java集合实际存储的时候都是使用Object数组，集合中不保存集合元素的数据类型，所以在源代码中你会看到类似下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此Java对于<code>List list = new ArrayList&lt;String&gt;()</code>这样的赋值也不会报错。而此时我们往list中添加任何类型的数据都没有影响<code>list.add(1) list.add(true)</code>，但是我们本意是想往该集合中添加String类型的数据。这个时候就可以使用checked动态类型检查了。拿上面的那个公司与员工表的例子，现在我们可以通过getEmployeeList获取员工表并对员工表进行修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;Employee&gt; employeeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 直接返回员工表对象，外部能够添加删除员工</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getEmployeeList</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> employeeList;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户调用时可能会做出这样的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Company</span> <span class="variable">alibaba</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Company</span>();</span><br><span class="line">		<span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> alibaba.getEmployeeList();</span><br><span class="line">		list.add(<span class="number">1</span>);  	<span class="comment">// 这明显是错误的操作，但是程序照样能正常运行</span></span><br><span class="line">		list.add(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的用户很显然执行了一个不正确的操作，但是程序照样能够运行，不会报错。此时我们就可以进行动态类型检查。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;Employee&gt; employeeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> List&lt;Employee&gt; <span class="title function_">getEmployeeList</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.checkedList(employeeList, Employee.class);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能确保用户只能往员工表中添加员工，而不能添加其他元素了。</p><p>Collections中的checked方法有以下几个：</p><ul><li><code>public static &lt;E&gt; Collection&lt;E&gt; checkedCollection(Collection&lt;E&gt; c, Class&lt;E&gt; type)</code></li><li><code>public static &lt;E&gt; List&lt;E&gt; checkedList(List&lt;E&gt; list, Class&lt;E&gt; type)</code></li><li><code>public static &lt;E&gt; Set&lt;E&gt; checkedSet(Set&lt;E&gt; s, Class&lt;E&gt; type)</code></li><li><code>public static &lt;E&gt; SortedSet&lt;E&gt; checkedSortedSet(SortedSet&lt;E&gt; s, Class&lt;E&gt; type)</code></li><li><code>public static &lt;E&gt; NavigableSet&lt;E&gt; checkedNavigableSet(NavigableSet&lt;E&gt; s, Class&lt;E&gt; type)</code></li><li><code>public static &lt;K, V&gt; Map&lt;K, V&gt; checkedMap(Map&lt;K, V&gt; m, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType)</code></li><li><code>public static &lt;K,V&gt; SortedMap&lt;K,V&gt; checkedSortedMap(SortedMap&lt;K, V&gt; m, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType)</code></li><li><code>public static &lt;K,V&gt; NavigableMap&lt;K,V&gt; checkedNavigableMap(NavigableMap&lt;K, V&gt; m, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType)</code></li><li><code>public static &lt;E&gt; Queue&lt;E&gt; checkedQueue(Queue&lt;E&gt; queue, Class&lt;E&gt; type)</code></li></ul><h3>Collections类中的简单工具方法</h3><ol><li><p>列表逆序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(List&lt;?&gt; list)</span></span><br></pre></td></tr></table></figure></li><li><p>列表填充</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; list, T obj)</span></span><br></pre></td></tr></table></figure></li><li><p>列表拷贝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span></span><br></pre></td></tr></table></figure></li><li><p>列表元素交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br></pre></td></tr></table></figure></li><li><p>计算集合中元素出现次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">frequency</span><span class="params">(Collection&lt;?&gt; c, Object o)</span></span><br></pre></td></tr></table></figure></li><li><p>集合元素是否相交</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">disjoint</span><span class="params">(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2)</span></span><br></pre></td></tr></table></figure></li><li><p>集合最大值，最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span> &amp; Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; T <span class="title function_">min</span><span class="params">(Collection&lt;? extends T&gt; coll)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Object</span> &amp; Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; T <span class="title function_">max</span><span class="params">(Collection&lt;? extends T&gt; coll)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">max</span><span class="params">(Collection&lt;? extends T&gt; coll, Comparator&lt;? <span class="built_in">super</span> T&gt; comp)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">min</span><span class="params">(Collection&lt;? extends T&gt; coll, Comparator&lt;? <span class="built_in">super</span> T&gt; comp)</span></span><br></pre></td></tr></table></figure></li><li><p>集合元素替换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">replaceAll</span><span class="params">(List&lt;T&gt; list, T oldVal, T newVal)</span></span><br></pre></td></tr></table></figure></li><li><p>添加若干元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? <span class="built_in">super</span> T&gt; c, T... elements)</span></span><br></pre></td></tr></table></figure></li><li><p>查找子列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexOfSubList</span><span class="params">(List&lt;?&gt; source, List&lt;?&gt; target)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lastIndexOfSubList</span><span class="params">(List&lt;?&gt; source, List&lt;?&gt; target)</span></span><br></pre></td></tr></table></figure></li></ol><h3>Collections类中的算法</h3><h4>排序算法</h4><p>Collections直接调用list.sort方法，该方法底层调用Arrays类中的排序算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br></pre></td></tr></table></figure><blockquote><p>关于排序算法可以先参考<a target="_blank" rel="noopener" href="http://blog.csdn.net/holmofy/article/details/70245895">常见排序算法及Java实现</a>和<a target="_blank" rel="noopener" href="http://blog.csdn.net/holmofy/article/details/71168530">SinglePivotQuickSort与DualPivotQuickSort及其JAVA实现</a>。</p></blockquote><h4>二分查找算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; list, T key)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List&lt;? extends T&gt; list, T key, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br></pre></td></tr></table></figure><h4>洗牌算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list, Random rnd)</span></span><br></pre></td></tr></table></figure><h4>列表旋转算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 列表的旋转可能不好理解，你把list想象成一个环。</span></span><br><span class="line"><span class="comment">// 环的旋转就相当于把list的尾部放到头部，头部放到尾部，注意这和列表的逆序不一样。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> distance)</span></span><br></pre></td></tr></table></figure><h3>Collections中的适配器</h3><p>Collections集合中使用对象的适配器模式实现并提供了两个适配器，分别可以将Map适配成Set，Deque适配成Stack。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title function_">newSetFromMap</span><span class="params">(Map&lt;E, Boolean&gt; map)</span>    <span class="comment">// 将Map适配成Set (SetFromMap)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Queue&lt;T&gt; <span class="title function_">asLifoQueue</span><span class="params">(Deque&lt;T&gt; deque)</span>    <span class="comment">// 将Deque适配成Stack (AsLIFOQueue)</span></span><br></pre></td></tr></table></figure></div><div class="article-copyright"><p>本作品采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a> 进行许可。</p><p>转载时请注明<a href="https://blog.hufeifei.cn/2017/05/Java/JavaCollection/">原文链接</a>：https://blog.hufeifei.cn/2017/05/Java/JavaCollection/</p></div><footer class="article-footer"></footer></div><div id="article-reward"><i class="iconfont ic-money"></i><div>鼓励一下</div><table><thead><tr><th style="text-align:center">支付宝</th><th style="text-align:center">微信</th></tr></thead><tbody><tr><td style="text-align:center"><img width="150" src="https://www.hufeifei.cn/reward-img/alipay.jpg"></td><td style="text-align:center"><img width="135" src="https://www.hufeifei.cn/reward-img/wechat.jpg"></td></tr></tbody></table></div><nav id="article-nav"><a class="article-nav-link-wrap" href="/2017/05/Windows/Windows%E4%B8%8A%E4%BD%BF%E7%94%A8%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%AE%89%E8%A3%85MYSQL/" id="article-nav-newer"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">Windows上使用压缩包安装MYSQL</div></a><a class="article-nav-link-wrap" href="/2017/05/Java/JavaIO%E6%B5%81%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B7%A9%E5%9B%BA/" id="article-nav-older"><strong class="article-nav-caption">Older</strong><div class="article-nav-title">Java I/O流总结与巩固</div></a></nav></article><div id="waline-comments"></div><script type="module">import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js';init({"el":"#waline-comments","pageview":true,"enable":true,"serverURL":"https://api.waline.blog.hufeifei.cn","avatar":"mp","pageSize":10,"lang":"zh-cn","placeholder":"Just go go","visitor":true,"recordIP":true,"requiredFields":["nick"]});</script></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">关注微信公众号</h3><div class="widget wechat"><img src="//www.hufeifei.cn/wechat-public-account.jpg"></div></div><div class="widget-wrap"><h3 class="widget-title">Categories</h3><div class="widget"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C&C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/J2EE/">J2EE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JAVA/">JAVA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux%E8%BF%90%E7%BB%B4/">Linux运维</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ruby/">Ruby</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rust/">Rust</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Windows/">Windows</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%A3%E7%A0%81%E6%97%A5%E5%B8%B8/">代码日常</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%95%86%E4%B8%9A/">商业</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BB%8F%E6%B5%8E%E4%B8%8E%E9%87%91%E8%9E%8D/">经济与金融</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/">计算机组成</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Tag Cloud</h3><div class="widget tagcloud"><a href="/tags/AVL/" style="font-size:11.11px">AVL</a> <a href="/tags/Alibaba/" style="font-size:14.44px">Alibaba</a> <a href="/tags/Android/" style="font-size:18.89px">Android</a> <a href="/tags/B-Tree/" style="font-size:12.22px">B-Tree</a> <a href="/tags/BKD-Tree/" style="font-size:10px">BKD-Tree</a> <a href="/tags/BST/" style="font-size:10px">BST</a> <a href="/tags/BigData/" style="font-size:11.11px">BigData</a> <a href="/tags/C/" style="font-size:14.44px">C</a> <a href="/tags/CGlib/" style="font-size:10px">CGlib</a> <a href="/tags/CS/" style="font-size:11.11px">CS</a> <a href="/tags/Canal/" style="font-size:10px">Canal</a> <a href="/tags/ClassLoader/" style="font-size:10px">ClassLoader</a> <a href="/tags/ClickHouse/" style="font-size:10px">ClickHouse</a> <a href="/tags/Config/" style="font-size:10px">Config</a> <a href="/tags/Cryptography/" style="font-size:10px">Cryptography</a> <a href="/tags/DB/" style="font-size:20px">DB</a> <a href="/tags/Dapper/" style="font-size:10px">Dapper</a> <a href="/tags/DataStructure/" style="font-size:14.44px">DataStructure</a> <a href="/tags/Debezium/" style="font-size:10px">Debezium</a> <a href="/tags/Diamond/" style="font-size:10px">Diamond</a> <a href="/tags/Distributed/" style="font-size:13.33px">Distributed</a> <a href="/tags/ElasticSearch/" style="font-size:10px">ElasticSearch</a> <a href="/tags/Encoding/" style="font-size:10px">Encoding</a> <a href="/tags/FastJson/" style="font-size:10px">FastJson</a> <a href="/tags/File/" style="font-size:10px">File</a> <a href="/tags/FlowMarketing/" style="font-size:10px">FlowMarketing</a> <a href="/tags/Grade/" style="font-size:10px">Grade</a> <a href="/tags/Gson/" style="font-size:10px">Gson</a> <a href="/tags/HTTP/" style="font-size:10px">HTTP</a> <a href="/tags/Handler/" style="font-size:10px">Handler</a> <a href="/tags/Hanlder/" style="font-size:10px">Hanlder</a> <a href="/tags/Hessian/" style="font-size:10px">Hessian</a> <a href="/tags/IO-Multiplex/" style="font-size:10px">IO-Multiplex</a> <a href="/tags/JAVA/" style="font-size:18.89px">JAVA</a> <a href="/tags/JVM/" style="font-size:10px">JVM</a> <a href="/tags/KD-Tree/" style="font-size:10px">KD-Tree</a> <a href="/tags/KDB-Tree/" style="font-size:10px">KDB-Tree</a> <a href="/tags/Kafka/" style="font-size:10px">Kafka</a> <a href="/tags/Kubernetes/" style="font-size:10px">Kubernetes</a> <a href="/tags/LSM-Tree/" style="font-size:11.11px">LSM-Tree</a> <a href="/tags/Linux/" style="font-size:17.78px">Linux</a> <a href="/tags/Lock/" style="font-size:11.11px">Lock</a> <a href="/tags/Lucene/" style="font-size:10px">Lucene</a> <a href="/tags/MQ/" style="font-size:10px">MQ</a> <a href="/tags/Macro/" style="font-size:10px">Macro</a> <a href="/tags/Magisk/" style="font-size:10px">Magisk</a> <a href="/tags/MultiDex/" style="font-size:10px">MultiDex</a> <a href="/tags/MySQL/" style="font-size:17.78px">MySQL</a> <a href="/tags/NIO/" style="font-size:10px">NIO</a> <a href="/tags/Nginx/" style="font-size:11.11px">Nginx</a> <a href="/tags/OGNL/" style="font-size:10px">OGNL</a> <a href="/tags/OpenResty/" style="font-size:10px">OpenResty</a> <a href="/tags/OpenTelemetry/" style="font-size:10px">OpenTelemetry</a> <a href="/tags/Oracle/" style="font-size:10px">Oracle</a> <a href="/tags/PostgreSQL/" style="font-size:10px">PostgreSQL</a> <a href="/tags/RB-Tree/" style="font-size:10px">RB-Tree</a> <a href="/tags/Redis/" style="font-size:10px">Redis</a> <a href="/tags/Rust/" style="font-size:10px">Rust</a> <a href="/tags/Sharding/" style="font-size:10px">Sharding</a> <a href="/tags/SpringBoot/" style="font-size:10px">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size:10px">SpringCloud</a> <a href="/tags/SpringCloudConfig/" style="font-size:10px">SpringCloudConfig</a> <a href="/tags/Sqlite/" style="font-size:10px">Sqlite</a> <a href="/tags/SurfaceView/" style="font-size:10px">SurfaceView</a> <a href="/tags/VSCode/" style="font-size:11.11px">VSCode</a> <a href="/tags/WebFlux/" style="font-size:10px">WebFlux</a> <a href="/tags/WebPush/" style="font-size:10px">WebPush</a> <a href="/tags/Web%E6%8C%96%E6%8E%98/" style="font-size:11.11px">Web挖掘</a> <a href="/tags/awk/" style="font-size:10px">awk</a> <a href="/tags/bit-hack/" style="font-size:10px">bit-hack</a> <a href="/tags/cheat-sheet/" style="font-size:10px">cheat sheet</a> <a href="/tags/curl/" style="font-size:10px">curl</a> <a href="/tags/epoll/" style="font-size:10px">epoll</a> <a href="/tags/gRPC/" style="font-size:10px">gRPC</a> <a href="/tags/grep/" style="font-size:10px">grep</a> <a href="/tags/kqueue/" style="font-size:10px">kqueue</a> <a href="/tags/libev/" style="font-size:10px">libev</a> <a href="/tags/libevent/" style="font-size:10px">libevent</a> <a href="/tags/libuv/" style="font-size:10px">libuv</a> <a href="/tags/metaq/" style="font-size:10px">metaq</a> <a href="/tags/poll/" style="font-size:10px">poll</a> <a href="/tags/sed/" style="font-size:10px">sed</a> <a href="/tags/select/" style="font-size:10px">select</a> <a href="/tags/ssh/" style="font-size:10px">ssh</a> <a href="/tags/%E5%8E%86%E5%8F%B2/" style="font-size:10px">历史</a> <a href="/tags/%E5%95%86%E4%B8%9A/" style="font-size:10px">商业</a> <a href="/tags/%E5%BF%83%E7%90%86%E5%AD%A6/" style="font-size:10px">心理学</a> <a href="/tags/%E7%94%9F%E6%B4%BB/" style="font-size:11.11px">生活</a> <a href="/tags/%E7%A8%8E%E6%94%B6/" style="font-size:10px">税收</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size:14.44px">算法</a> <a href="/tags/%E7%BB%8F%E6%B5%8E/" style="font-size:15.56px">经济</a> <a href="/tags/%E8%90%A5%E9%94%80/" style="font-size:10px">营销</a> <a href="/tags/%E8%B4%A7%E5%B8%81/" style="font-size:10px">货币</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size:16.67px">随笔</a></div></div><div class="widget-wrap"><h3 class="widget-title">Recent Posts</h3><div class="widget"><ul><li><a href="/2024/04/economic/value-added-tax/">增值税与贫富差距</a></li><li><a href="/2024/01/Net/x-forward-for/">“真”的IP真的是真的吗？</a></li><li><a href="/2024/01/paper/MarkupLM-web-extract/">【译】基于MarkupLM的web数据抽取</a></li><li><a href="/2023/09/economic/tax-reform/">直接税改革——王朝周期律的胜负手</a></li><li><a href="/2023/09/Rust/macro-rules-learning/">Rust中的宏</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">网站运营不易</h3><div class="ads-wrapper"><div class="google_ads"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7111912103882824" data-ad-slot="8429272980" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div></div></aside></div><footer id="footer"><div class="outer"><div class="inner" id="footer-info"><p><a href="https://beian.miit.gov.cn/" target="_blank">赣ICP备17009276号</a><i class="far fa-copyright"></i>2016 ~ 2024 胡飞飞</p><p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a><i class="fas fa-angle-right"></i>Theme by <a target="_blank" rel="noopener" href="https://github.com/holmofy/hexo-theme-paper">paper</a></p></div></div></footer></div><nav id="mobile-nav"><a class="mobile-nav-link" href="//www.hufeifei.cn">主页</a><a class="mobile-nav-link" href="/">博客</a><a class="mobile-nav-link" href="/archives">归档</a><a class="mobile-nav-link" target="_blank" rel="noopener" href="//algo.hufeifei.cn">算法</a><a class="mobile-nav-link" href="/book">书籍</a><a class="mobile-nav-link" href="/github">Github</a></nav><script src="//cdnjs.loli.net/ajax/libs/jquery/3.0.0/jquery.min.js"></script><link rel="stylesheet" href="//cdnjs.loli.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="//cdnjs.loli.net/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script><script type="text/javascript" src="/js/script.js"></script></div><script>
  $(document).ready(function() {
    $('figure.codeblock').find('.tab').click(function() {
        var $codeblock = $(this).parent().parent().parent();
        var $tab = $(this);
        // remove "active" css class on all tabs
        $tab.siblings().removeClass('active');
        // add "active" css class on the clicked tab
        $tab.addClass('active');
        // hide all tab contents
        $codeblock.find('.highlight').hide();
        // show only the right one
        $codeblock.find('.highlight.' + $tab.text()).show();
    });
  });
  </script><script>(function (w, d, s, id) {
            if (typeof (w.webpushr) !== 'undefined') return; w.webpushr = w.webpushr || function () { (w.webpushr.q = w.webpushr.q || []).push(arguments) }; var js, fjs = d.getElementsByTagName(s)[0]; js = d.createElement(s); js.id = id; js.async = 1; js.src = "https://cdn.webpushr.com/app.min.js";fjs.parentNode.appendChild(js);}(window, document, 'script', 'webpushr-jssdk'));webpushr('setup', { 'key': 'BPJzNs1QEtbYa3Bn0gMAQHBAzX3Jm71llGUKHTkKEUs3D9xiDYZ0DWJ3S9sfCAAJHxXEoBkUANFyONjeIlgrJUo'' });</script></body></html>