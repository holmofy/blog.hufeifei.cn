---
title: AutoRM
date: 2023-01-26
categories: 算法
tags: 
- 算法
- Web挖掘
---

AutoRM: An effective approach for automatic Web data record mining ———— 论文翻译

## 摘要

一个Web数据库通常通过Web页面回应查询，并使用HTML标签将查询结果编码为半结构化数据对象。我们将这样的数据对象称为Web数据记录或数据记录。挖掘Web数据记录对于许多应用非常重要，例如元搜索、比较购物等。本文提出了一种称为AutoRM的新的有效方法，可以自动从单个Web页面中挖掘数据记录。AutoRM包括三个主要步骤：(1) 构建给定Web页面的DOM树；(2) 从构建的DOM树中挖掘所有相邻相似的C-Records（候选数据记录）集合；(3) 从C-Records中挖掘实际数据记录。在许多Web页面中，相似的数据记录分布在更大和相邻的相似对象中。现有方法通常将这些对象识别为数据记录。相反，AutoRM将这些对象视为C-Records，并从中挖掘实际数据记录。挖掘相似数据记录的一个关键问题是每个数据记录的边界检测。现有方法通常对处理这个问题做出一些脆弱的假设。通过做出更健壮的假设，AutoRM倾向于更准确地检测数据记录边界。实验结果表明，AutoRM具有很高的效果，并且优于最先进的方法。

## 1. 介绍

当Web数据库接收到用户的查询时，通常会将结构化查询结果包装成一个Web页面，然后将其提供给用户。在这里，结构化查询结果通常使用HTML标签将其编码成半结构化数据对象。本文将这样的半结构化数据对象称为Web数据记录或数据记录。从Web页面中挖掘数据记录对于许多有用的应用非常重要，例如元搜索和比较购物等。

在Web页面中，编码的数据记录通常分布在一个或多个数据区域中，每个数据区域包含一系列描述相同类型对象的相似数据记录。在本文中，我们假设数据记录由一组兄弟DOM节点组成。通过调查50个领域中数千个Web页面，我们发现这个假设在99.8%的Web页面中成立。许多典型方法也基于这个假设，例如OMINI [6]、MDR [27]、DEPTA [40]、NET [29]、G-STM [22]、CTVS [36]等。基于这个假设，数据区域被定义为最小的一组相邻DOM节点，可以将其分割成相似的数据记录。因此，对于一个数据区域，其第一个（最后一个）节点就是其第一个（最后一个）数据记录的头部（尾部）节点。

示例：图1(a)显示了一个包含两个相似数据记录的Web页面片段。图1(b)显示了页面片段的DOM树（注意：标签用于表示节点，文本节点的标签包含“#text”）。根据图1(b)，包含两个相似数据记录的数据区域是h#text6, a7, br8, span9, br10, font11, br12, br13, #text14, a15, br16, font17i，可以将其分割成两个相似数据记录：h#text6, a7, span9, font11i（数据记录1）和h#text14, a15, font17i（数据记录2）。在这里，作为分隔符节点（例如br8，br10）不包含实际内容，它们不会放入任何数据记录中。

在本文中，我们提出了一种名为AutoRM（自动数据记录挖掘）的新的有效方法，可以自动从单个Web页面的所有数据区域中挖掘数据记录。这里，一个数据区域包含一系列相似的数据记录。根据[33]，一个Web页面可能还包含辅助区域，其中包括不是数据记录的相似对象。然而，对于基于单页面的自动方法来说，很难确定这些辅助区域中的相似对象是否是数据记录。为了解决这个问题，现有方法通常提出一些启发式方法来确定单个相似数据记录集合。然而，一个Web页面可能包含多个数据区域。对于这样的Web页面，这些方法只能识别一个数据区域中的数据记录。为了避免这个缺点，我们采用了MDR [27]、DEPTA [40]、NET [29]和G-STM [22]采用的策略。具体而言，我们在数据区域和辅助区域都挖掘相似对象，并且不区分辅助区域中的相似对象和数据区域中的相似对象。在我们的实验中，我们忽略了从辅助区域挖掘出的相似对象，并且仅根据从数据区域挖掘出的数据记录来衡量性能。为了公平比较，与只从单个数据区域挖掘数据记录的方法相比，实验数据集只包含每个Web页面中包含单个数据区域的页面。

AutoRM在以下三个主要步骤中挖掘数据记录：
1) 构建给定Web页面的DOM树：目前，DOM树是通过调用Web浏览器的API来构建的。
2) 从构建的DOM树中挖掘每组相邻的类似C-Records（候选数据记录）：
在这里，相似的C-Records是实际相似的数据记录或包含较小实际数据记录的对象。在许多Web页面中，相似的数据记录分布在较大的相邻相似对象中嵌入的多个数据区域中。例如，图2(a)显示了一个页面片段，其中包含四个相似的数据记录：htd11i、htd12i、htd21i和htd22i，其中htd11、td12i和htd21、td22i是包含前两个数据记录和后两个数据记录的两个数据区域；这两个数据区域分别嵌入在两个节点集合htr1i和htr2i中，这些节点集合是更大的相邻相似对象。
3) 从每组相似的C-Records中挖掘实际数据记录：
众所周知，大多数现有方法不会从较大的相邻相似对象中识别出相似的数据记录。例如，对于图2(a)中的页面片段，这些方法只将htr1i和htr2i识别为相似的数据记录。据我们所知，只有DEPTA [40]和MDR [27]尝试从较大的相邻相似对象中进一步挖掘实际的数据记录。然而，当较大的相邻相似对象包含不相关的信息（例如，每个数据区域之前的一些描述）时，DEPTA和MDR将无法从中挖掘实际的数据记录。此外，DEPTA和MDR仅尝试一次从较大的相邻相似对象中挖掘数据记录，而不是递归地进行。因此，当进一步挖掘的相似对象仍然包含较小的实际数据记录时，DEPTA和MDR将无法挖掘实际的数据记录。在这一步中，我们提出了一种新的有效算法，可以在一定程度上容忍不相关信息，并允许递归挖掘相似的数据记录（详见第6节）。

在第二步中，我们通过两个子步骤来挖掘每组相邻的类似C-Records：(1)识别CG-Region（粗粒度数据区域）和(2)将CG-Region分割成相似的C-Records。在这里，CG-Region是一个包含一个或多个相邻类似C-Records和一些不相关信息的Web页面部分。如先前假设的那样，数据记录由一组兄弟节点组成。为了与这个假设保持一致，我们假设一个C-Record也由一组兄弟节点组成。因此，一个CG-Region由一组相邻节点组成，可以被分割成C-Records。在一个CG-Region中，不在C-Records中的节点表示不相关的信息。

通过识别CG-Region，我们可以过滤掉很多不相关的信息。因此，我们可以减轻分割步骤的负担，该步骤需要避免将不相关的信息放入任何C-Record中。第二个子步骤的时间复杂度比第一个子步骤高得多。因此，通过引入第一个子步骤，我们可以大大提高时间效率。

实质上，CG-Region分割是C-Record边界检测，需要解决以下两个基本问题：

* 问题1：如何确定CG-Region中相似C-Records的第一个C-Record的头节点？
* 问题2：如何确定相邻的两个C-Records之间的边界，以及CG-Region中相似C-Records的最后一个C-Record的尾节点？

<img width="956" alt="image" src="https://github.com/holmofy/blog.hufeifei.cn/assets/19494806/ab371007-f3bb-4bb9-9bcb-3136a6c6a6a2">

在本文中，我们提出了一个新的算法来处理问题1。我们知道，大多数现有的方法并没有开发特殊算法来处理问题1。这使得它们容易在数据记录中包含不相关的信息。

为了解决问题2，我们区分了两种基本的C-Record组织形式：
* 形式1：在CG-Region中，类似的C-Records由一组相同的分隔符进行分割。每个分隔符包含一个或多个不包含文本、图像或HTML控件的DOM节点，相同的分隔符具有相同的DOM树结构。例如，图1中显示的两个相似的数据记录属于这种形式，因为它们由分隔符hbr12，br13i进行分割。
* 形式2：在CG-Region中，类似的C-Records不是由相同的分隔符进行分割。例如，图2中tr1（tr2）节点下的两个相似的数据记录属于这种形式。

我们提出了两种算法，基于分隔符的算法和基于头节点顺序的算法，分别处理形式1和形式2。通过这种方式，基于分隔符的（基于头节点顺序的）算法可以充分利用形式1（形式2）的特性。然而，对于包含分隔符的CG-Region，其C-Record组织形式可能不确定（参见第5.3节）。为了处理这种情况，我们结合了两个算法，并且综合算法相对于单独使用基于分隔符的算法或基于头节点顺序的算法可以取得更好的结果。

第8节展示了现有方法通常对记录边界检测进行一些脆弱的假设。相比之下，我们的新算法提出了更加健壮的假设（参见第5节）。因此，我们更有可能检测出数据记录的正确边界。

本文的主要贡献如下：
1) 我们提出了一种用于CG-Region识别的新算法（第4节）。
2) 我们提出了一种处理问题1的新算法（第5.1节）。
3) 我们分别提出了两种新算法，基于分隔符的算法（第5.4节）和基于头节点顺序的算法（第5.5节），用于处理形式1和形式2的问题2。
4) 我们将基于分隔符的算法和基于头节点顺序的算法整合起来，处理C-Record组织形式不确定的情况（第5.3节）。
5) 我们提出了一种用于挖掘嵌入在相邻类似C-Records中的实际数据记录的新算法（第6节）。
6) 我们进行了实验研究，展示了我们的方法AutoRM的高效性，并超过了基于单页面的自动Web数据记录挖掘方法（第7节）。

本文的其余部分组织如下。第2节介绍了一些预备知识，包括树相似度计算和相似树聚类；这些预备知识将用于在数据记录挖掘过程中对相似数据记录进行聚类。第3节介绍了我们从Web页面的DOM树中挖掘所有相似C-Records的算法。第4节介绍了我们用于CG-Region识别的算法。第5节介绍了我们将CG-Region分割成相似C-Records的算法。第6节介绍了我们从C-Records中挖掘实际相似数据记录的算法。第7节给出了我们的实验结果。第8节回顾了相关工作。第9节对论文进行了总结，并概述了未来的工作计划。

<img width="903" alt="image" src="https://github.com/holmofy/blog.hufeifei.cn/assets/19494806/de4238f8-7372-4943-8f64-dc98431e8c5f">

## 2. 预备知识
在Web数据记录挖掘过程中，我们需要对相似的数据记录进行聚类。为此，我们将计算任意两个数据记录之间的相似度，并基于数据记录的相似度对数据记录进行聚类。具体而言，我们将为每个数据记录构建一棵树，通过向数据记录中的节点添加一个人工父节点来实现。通过这种方式，计算数据记录的相似度和聚类相似数据记录将转化为计算树的相似度和聚类相似树。接下来，
第2.1节提出了我们计算任意两棵树之间相似度的方法；第2.2节介绍了我们基于树相似度进行聚类的算法。

### 2.1. 树相似度计算
计算树相似度的传统方法是基于树匹配算法。然而，现有的树匹配算法（例如STM [39]）通常采用结构特征，忽视了一些有用的特征，如视觉特征、内容特征、数据类型等。这使得这些算法很难准确匹配任意两个DOM树之间的相似节点。因此，这些算法无法准确计算DOM树的相似度。在本节中，我们提出了一种新的方法，结合了各种特征，用于计算DOM树的相似度。

新方法包括两个主要步骤。首先，它结合了几个特征来识别给定的两个DOM树中的相似叶节点。然后，它基于识别出的相似叶节点计算树的相似度。具体而言，给定任意两个DOM树T1和T2，我们的方法计算T1和T2之间的相似度如下：

（1）识别T1和T2中的相似叶节点。
设AL为T1和T2中所有叶节点的集合，我们使用[23]中的凝聚聚类算法来聚类AL中的相似叶节点。为了应用聚类算法，我们需要给出计算任意两个叶节点之间相似度的方法。在这里，我们使用[30]中的最先进的数据单元相似度计算方法来计算叶节点的相似度。该方法结合了各种有用的特征，因此倾向于准确计算节点的相似度，从而使聚类算法更准确地识别相似叶节点。在这里，聚类算法中使用的相似度阈值设置为0.6，该值是通过在示例Web页面上进行训练得到的。

（2）基于相似

叶节点计算T1和T2之间的相似度。
通过第一步，生成了相似叶节点的聚类。设clustersi为fl:clusterjl是Tig的一个叶节点的聚类；i = 1，2，其中l:cluster表示包含l的聚类。使用以下公式计算T1和T2之间的相似度：


$$Similarity(T1,T2)=\dfrac{\left | clusters_1 \right | \cap \left | clusters_2 \right |}{max(\left | clusters_1 \right |,\left | clusters_2 \right |)}$$
​
### 2.2. 相似树的聚类

现在，我们准备介绍我们的相似树聚类算法。给定一个树集合 TS 和相似性阈值 h（0 < h ≤ 1），我们再次采用 [23] 中的凝聚聚类算法来对 TS 中的相似树进行聚类。初始时，TS 中的每棵树形成一个单独的组；然后我们反复合并那些具有相似度大于 h 的最高相似度的两个组。（注：任意两个树组 G1 和 G2 之间的相似度定义为 G1 中的每棵树与 G2 中的每棵树之间相似度的平均值。）最终，每个结果组中包含聚类后的相似树。在我们的实验中，h 被设置为 0.5，这是通过在示例网页上进行训练得到的。

示例：为了对图 1(b) 中 div 节点的相似子树进行聚类，首先我们构建初始组集合 S = {{br1}, {hr2}, {#text3}, {br4}, {br5}, {#text6}, {a7}, {br8}, {span9}, {br10}, {font11}, {br12}, {br13}, {#text14}, {a15}, {br16}, {font17}, {hr18}, {br19}}，其中每个组包含 div 节点的一个子树。然后，我们反复合并 S 中具有相似度大于 h 的最高相似度的两个组。最终，S 变为 {{br1, br4, br5, br8, br10, br12, br13, br16, br19}, {hr2, hr18}, {#text3, #text6, #text14}, {a7, a15}, {span9}, {font11, font17}}，其中每个组是相似树的一个聚类。

## 3. 相似 C-Record 挖掘算法

本节介绍我们的相似 C-Record 挖掘算法。从给定网页的 DOM 树的根节点开始，我们以自顶向下的方式从 DOM 树中挖掘所有相似 C-Record 的集合。具体而言，在第一步中，我们尝试从根节点的子节点集合中挖掘所有相似 C-Record 的集合；在第二步中，对于每个未包含在任何已挖掘的 C-Record 中的子节点，我们尝试从以其为根的子树中递归挖掘所有相似 C-Record 的集合。第一步是关键步骤，包括两个子步骤：

(1) 从根节点的子节点中识别所有的 CG-Region。
我们将使用在第 4 节中提出的算法 2 来进行 CG-Region 的识别。

(2) 将每个识别出的 CG-Region 分割成相似 C-Record。
我们将使用在第 5 节中提出的算法 3 来进行 CG-Region 的分割。

算法 1 展示了该算法。算法的输入是给定网页的 DOM 树 T，输出是从 T 中挖掘出的所有相似 C-Record 的集合列表。

<img width="625" alt="image" src="https://github.com/holmofy/blog.hufeifei.cn/assets/19494806/a115383f-bf0f-4c9b-9729-aeadff089712">

根据 DEPTA [40]，在同一个父节点下可能存在多个相似数据记录集合。因此，如果 T:root（T 的根节点）包含子节点，则我们从 T:root:children（T:root 的子节点）中挖掘所有相似 C-Record 的集合（第 3-4 行）。具体而言，首先我们对 T:root:children 中的相似节点进行聚类（注意：我们通过获取以 T:root:children 中的节点为根的树，并使用第 2.2 节中描述的算法对这些树进行相似节点的聚类）（第 3 行）；其次，我们使用 Procedure mineCRecFromNS() 基于 T:root:children 中的相似节点来挖掘相似 C-Record（第 4 行）。在论文的其余部分，对于任何节点 N，N:cluster 表示包含 N 以及与 N 相似的所有兄弟节点的节点聚类。

当我们从 T:root:children 中挖掘出所有相似 C-Record 的集合后，可能会有一些 T:root 的子节点未被任何挖掘的 C-Record 所覆盖。由于以这些未覆盖的子节点为根的树可能包含相似 C-Record，我们需要获取所有这些未覆盖的子节点（第 5 行），并从以这些子节点为根的树中递归挖掘所有相似 C-Record 的集合（第 6 行）。

现在，我们详细解释 Procedure mineCRecFromNS()。给定一组相邻的兄弟节点 NS，Procedure mineCRecFromNS() 从 NS 中挖掘所有相似 C-Record 的集合。如果 NS 包含少于两个节点，则不包含相似子部分，直接返回空集（第 7-8 行）。否则，从 NS 中挖掘相似 C-Record 的集合如下所示：

(1) 使用第 4 节中的算法 idenCGRegion() 从 NS 中识别所有的 CG-Region（第 9 行）。通过识别 CG-Region，我们可以过滤掉许多无关信息，从而减轻 CG-Region 分割的负担。

(2) 将每个 CG-Region 分割成相似 C-Record（第 11-15 行）。具体而言，对于每个 CG-Region CGR，我们使用第 5 节中的算法 segCGRegion() 从 CGR 中识别出具有最高质量的一组相似 C-Record（第 12 行）。设 CRecSet 为结果 C-Record 集合。如果 CRecSet 为空，则 CGR 中没有相似 C-Record，将尝试下一个 CG-Region。否则，设 CGR½i ... j 为覆盖 CRecSet 中 C-Record 的最小区域（第 14 行）。剩余的两个区域 CGR½0 ... i  1 和 CGR½j þ 1 ... jCGRj  1 可能包含其他相似 C-Record。因此，我们通过递归调用 Procedure mineCRecFromNS() 从这两个区域中挖掘相似 C-Record（第 15 行）。

## 4. CG-Region识别

我们观察到数据区域通常满足以下两个属性：

属性 1：数据区域包含一个或多个相似节点集合。例如，在图 1(b) 中的数据区域中，{#text6, #text14}、{a7, a15} 和 {font11, font17} 是三个相似节点集合。

属性 2：如果一个数据区域包含多个相似节点集合，则数据区域中至少有一个相似节点集合的索引区间与另一个相似节点集合的索引区间有交集（注意：设 subNS 为 NS 的子集，索引区间用 subNS:indexInterval 表示，记作 [i, j]）。

到目前为止，除了只包含一个数据记录的数据区域外，我们没有看到任何违反上述两个属性的数据区域。在本文中，我们不处理只包含一个数据记录的情况。现在，我们正式定义 CG-Region 如下：

定义 1：CG-Region 是满足属性 1 和属性 2 的区域。

根据上述定义，数据区域通常包含在一个 CG-Region 中。为了识别 CG-Region，我们区分两种类型的节点：分隔节点和非分隔节点。对于任何节点 N，如果以 N 为根的子树不包含文本、图像或 HTML 控件，则称 N 为分隔节点；否则称 N 为非分隔节点。

算法 2 展示了我们用于识别 CG-Region 的算法。算法的输入是一组兄弟节点 NS，输出是从 NS 中识别出的 CG-Region 的列表。

<img width="766" alt="image" src="https://github.com/holmofy/blog.hufeifei.cn/assets/19494806/4510ceb9-6bfd-4ac3-941e-45daacc0b064">

根据属性 1，我们首先获取 NS 的相似非分隔节点的聚类（第 1 行）。如第 3 节所述，第 1 行中的 N:cluster 表示包含 N 及其所有与 N 相似的兄弟节点的节点聚类。因此，N:cluster \ NS 表示包含 N 及 NS 中与 N 相似的节点的聚类。此外，由于分隔节点不包含实际内容，且通常随机出现，它们不用于 CG-Region 的识别。

根据属性 2，如果两个相似的非分隔节点的索引区间相交，则这两个索引区间的并集包含在一个 CG-Region 的索引区间内。基于这个想法，我们通过三个主要步骤来识别 CG-Region：

（1）将第 1 行中识别到的节点聚类的索引区间作为初始的索引区间集合（第 2 行）。

（2）重复地合并索引区间集合中相交的索引区间，直到任意两个索引区间不相交（第 3-4 行）。

（3）对于每个结果索引区间 I，将其标识为一个 CG-Region，其中 I:left（I:right）表示索引 I 的左（右）边界（第 5 行）。

示例：对于图 1(b) 中 div 节点的子节点集合，相似的非分隔节点的聚类为 {#text3, #text6, #text14}、{a7, a15}、{span9} 和 {font11, font17}。因此，这些聚类的初始索引区间集合为 {[3, 14], [7, 15], [9, 9], [11, 17]}。我们按如下方式重复合并索引区间集合中的相交区间：

（1）由于 [3, 14] 和 [7, 15] 相交，将两个区间合并为 [3, 14] ∪ [7, 15] = [3, 15]。索引区间集合变为 {[3, 15], [9, 9], [11, 17]}。

（2）由于 [3, 15] 和 [9, 9] 相交，将两个区间合并为 [3, 15] ∪ [9, 9] = [3, 15]。索引区间集合变为 {[3, 15], [11, 17]}。

（3）由于 [3, 15] 和 [11, 17] 相交，将两个区间合并为 [3, 15] ∪ [11, 17] = [3, 17]。索引区间集合变为 {[3, 17]}。

现在，我们可以得到结果的 CG-Region 列表为 {#text3, br4, br5, #text6, a7, br8, span9, br

10, font11, br12, br13, #text14, a15, br16, font17}。请注意，我们算法识别出的 CG-Region 可能包含不相关的信息。在上面的示例中，识别出的 CG-Region {#text3, br4, br5, #text6, a7, br8, span9, br10, font11, br12, br13, #text14, a15, br16, font17} 包含了不相关的节点 #text3, br4 和 br5，它们超出了图 1(b) 中数据区域的边界。

## 5.  CG-Region分段

### 5.1. 算法

本节提出了我们的算法，可以将一个 CG-Region 分割成一组具有最高质量的相似 C-Records。该算法解决了第 1 节中提到的问题 1 和问题 2，具体如下：
（1）为了处理问题 1，我们从一个 CG-Region 中挖掘出所有可能的相似 C-Records 集合。每个可能集合中的第一个 C-Record 从一个可能的头节点开始。我们选择质量最高的 C-Record 集合作为结果。我们将在本节介绍比较不同 C-Record 集合质量的方法。
（2）为了处理问题 2，该算法将使用第 5.3 节中的算法 4 来挖掘每个可能的 C-Record 集合。算法 4 通过集成基于分隔符和基于头顺序的算法来解决问题 2，这两种算法将在分别介绍的第 5.4 和 5.5 节中介绍。

算法 3 展示了我们用于 CG-Region 分割的算法。算法的输入是一个 CG-Region CR = {C1, C2, ..., Cn}。输出是从 CR 中挖掘出的一组相似的 C-Records。

<img width="619" alt="image" src="https://github.com/holmofy/blog.hufeifei.cn/assets/19494806/7f9ebb05-261a-449c-b177-5efd4fcda4f5">

为了处理问题 1，我们从左到右扫描 CR 中的节点（第 2 行）。对于每个扫描到的节点 Ci，如果 Ci 是一个分隔符节点，则它不包含真实内容，我们将移动到下一个节点。否则（第 3 行），我们将 Ci 视为第一个 C-Record 的头节点，并尝试使用算法 4 从 hCi; Ci+1; ... ; Cn 中挖掘相似的 C-Record（第 4 行）。如果无法挖掘出相似的 C-Record，则尝试下一个节点。否则（第 5 行），我们检查挖掘到的 C-Record 集合是否是已经挖掘的 C-Record 集合的子集（第 6 行）。如果是，我们假设所有可能的第一个 C-Record 的头节点已经尝试过，并直接终止扫描（第 7 行）。如果不是，挖掘到的 C-Record 集合将被放入列表中（第 8 行）。当扫描最终终止时，我们得到了一系列可能的 C-Record 集合。现在问题是如何确定应选择哪个 C-Record 集合。为了解决这个问题，我们开发了一些用于比较 C-Record 集合质量的度量标准，并选择质量最高的 C-Record 集合。我们的度量标准基于以下观察：高质量的 C-Record 集合满足以下两个属性：
