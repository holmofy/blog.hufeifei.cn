---
title: 微服务的前世今生与未来
date: 2021-04-28 13:57
categories: 微服务
tags: 
- Microservice
---

> 这篇文章源自我在知乎上的一个回答["Kubernetes 可以完全替代 Spring Cloud 吗？"](https://www.zhihu.com/question/451313635/answer/1849701932)，在这里对一些内容做一些补充。

我对Java熟一点可以用Spring Cloud，别人不会Java不能用别的微服务框架吗。不管你换什么微服务框架，但容器的管理还是K8S。

Spring Cloud只是微服务的Java解决方案，Spring Cloud Alibaba也只是因为阿里应用大多是Java写的，所以用Spring Cloud集成了阿里自己的一套中间件。

真正要考虑的是微服务出现的原因，以及使用微服务后会出现什么问题，Spring Cloud这样的微服务框架以及周边的中间件是怎么解决这些问题的：

**微服务出现的原因**

业务简单完全可以用单机部署，搞成微服务拆成那么多应用部署就是给自己找罪受。一个简单的学生管理系统干嘛要搞成微服务呢，是吧。单机服务到顶了，直接多加几台机器就行。

但是业务复杂了之后，有些业务请求量很高，有些业务请求量少。比如电商的商品搜索，这玩意儿访问量这么大，要是我还和其他业务写在一个应用里部署，把能用的几台机器都打挂了，整个网站都瘫痪了，然后明天的新闻头条：某淘网站瘫痪，系程序员服务器挖矿导致，某程序员又要祭天了。

复杂业务单独写到一个应用里，还有一个问题就是重构困难，要换框架甚至换语言，那就是伤筋动骨。那就拆吧，把应用里的功能都拆成一个个服务，服务想用什么框架想用什么语言都无所谓，只要保证服务之间通信协议一致就行，所以就有了SOA的架构。

服务之间怎么通信呢，用什么协议通信呢。最早Java里有RMI，它用ObjectInput/OutputStream把调用的对象通过网络传给远程的服务器，但是因为对象序列化是java专属的而且有注入风险等问题，所以后面有了基于XML的SOAP协议，但是XML冗余信息太多了，于是还有基于JSON的REST协议，Spring Cloud的Feign就是一个REST协议的客户端。

但是SOAP和REST都是基于http协议传输的，头信息有点浪费，拉低了有效信息的荷载率，于是有人拉起直接基于TCP的轻量级的JSON-RPC协议。这些序列化都是人类可识别的字符，还有一类呢为了更高的传输效率直接上二进制，如protobuffer，Kryo...一个RPC框架的优秀并不体现在序列化上，这些序列化协议可以做成插拔的随便替换，重点在于以下几点：

1、要保证请求的高效处理，是不是得上io-multiplex，像Dubbo一样用上Netty吧，不然怎么吹牛逼叫高性能。

2、服务怎么暴露给别人，A也要调用我，B也要调用我，明天来了个C也要调用我，我每次都把自己的ip告诉人家多麻烦。要是某一天我ip换了，我是不是还得发个邮件通知A,B,C，那多麻烦。服务一多，我也记不清到底哪些人在调我接口了，要是换ip少通知了一个人，导致他应用挂了，人家又要甩锅了，真是麻烦。既然这么麻烦，那就搞个注册中心吧，我应用一起来就把自己的ip注册到注册中心，别人要调用就到注册中心去拿我的地址吧。是不是感觉这个注册中心和DNS很像，其实它们的作用差不多，只是DNS运用于互联网，因为缓存以及生效慢等原因，不适合做内网服务的注册中心，那就自己搞吧，于是就有了etcd,euruka,zookeeper这样的东西。

3、我应用部署了好多台机器都注册到注册中心了，你要调用哪一台机器呢。所以有了负载均衡，根据不同的策略有不同的负载均衡算法，有随机有轮询有哈希，这些可以按自己心意配置

4、要是我应用机器里有某几台机器挂了，或者换ip了，怎么办，别人调用不到了，是不是得让注册中心把挂了的机器剔除掉。怎么剔除呢，肯定不能靠我的应用，我都不知道自己啥时候会死让我怎么给你善后。得靠注册中心，大部分注册中心都采用超时续约的方式来保证服务提供方正常提供服务，一旦提供方挂了，超过一定时间没续约，不好意思踢掉，然后告诉消费者这家伙挂了，不要再调了，换台机器调。

5、注册中心挂了怎么办。一般来说注册中心是要保证高可用的，但真的倒霉到打雷把电给断了，网管踩断了网线，发地震把磁盘给震坏了……还是要保证消费者能正常调用提供方的接口。所以客户端最好是在本地备份服务提供方的地址进行容灾。

6、既然注册中心这么重要，要做成高可用的，怎么做呢。“高可用”简简单单三个字，可不是像应用集群一样想多部署一台就部署一台。应用之所以可以方便地横向扩展，主要是因为没有状态，数据都存在数据库里。但是注册中心，和数据库一样是有状态的，有状态的节点要保证高可用难点在于数据复制和数据一致性。消费者向注册中心的机器A获取接口地址，和从注册中心的机器B获取接口地址不一致，就好像你同时被两个领导指挥着，那可不行。你看Paxos、Raft以及zookeeper的ZAB就是解决这个的。

7、要是消费者在调用提供的接口超时了怎么办，是直接失败抛异常返回呢，还是调用其他机器，又或者再多重试几次。如果是重试的话，你也不知道之前超时的调用到底是成功了还是失败了，所以重试策略应该只能用在幂等接口上。

8、要是消费者请求超过我机器能抗的量把这台机器打挂了，你跑去重试其他机器又把其他机器打挂了，导致我整个服务全军覆没了，那可不行。所以我得限流，超过我的承受范围那就排队去吧，不能让你把我给撑爆了。对于消费者，重试了几次还不行那就不要重试了，给我点生路好不好，那就熔断吧，直接告诉上游我不行了。 开源的resilience4j就是实现这个功能的，另外Netflix贡献了自己家的豪猪，阿里贡献了自己的Sentinal。

9、应用那么多台机器，有时候想改个配置，还得重新部署所有的机器才能生效，要是有个中心化的配置中心就好了，把配置都放到配置中心，一改动所有的服务器都生效，做的更好一点呢，甚至连重启都省了。要是有个版本控制就更完美了，谁改了配置导致了什么问题一目了然，想甩锅也甩不掉了。Spring Cloud Config可以访问git或svn上的配置文件来解决这个问题，为了更安全的管理密码等配置，Spring Cloud还整合了Vault。阿里内部有个Diamond专门用来做配置中心，还开源了个Nacos把配置中心和注册中心的功能整合到一起了。

10、我的应用部署了那么多台机器，要看日志难道我还要一台一台的上去看嘛，要是线上有100台，1000台这不是要累死我。我需要一个把日志收集(Logging)起来的工具，让我在统一的地方看日志就行。ELK或者EFK怎么样，ElasticSearch还支持全文搜索呢，就是这套东西太吃内存了，Loki+Grafana好像是个不错的选择哦。

11、我的应用这么多台机器，我再也不好单独上一台机器用top等命令看CPU、内存、IO等性能了，不好用jmap分析java堆内存了，也不好用jconsole远程单独连接某台机器看gc或者JMX透出来的MBean了，还有上下游接口的qps，我要把这些数据收集起来，做个指标聚合(Metrics)。你看prometheus+grafana是目前开源界最流行的组合哦。

12、用户一个请求过来，从A服务到B服务再到C服务……这个调用链可能很长。再也不能像单机版应用一样直接看程序堆栈，直接用火炬图就能分析应用的性能了。我需要把这些调用链也收集起来，整成一个跟程序stack trace类似的东西，最好还能告诉我每个服务调用过程中的耗时，也就是Distributed Tracing。谷歌的Dapper论文就提到了谷歌是怎么实现这个功能的，然后开源届大佬们弄了Zipkin,Jaeger,Spring Cloud也有一个Sleuth，这种组件很多，每种实现可能有所差别，但是大佬们觉得还是得定个规范于是有了OpenTracing，关于Distributed Tracing我的这篇文章里有介绍是怎么实现的。 Logging+Metrics+Tracing，这三个是本质上都是日志，Logging是非结构化日志，Metrics和Tracing是结构化日志，Tracing日志和stack trace类似结构上基本上没多大变化，而Metrics日志按照监控的对象不同以及指标的维度不同结构也有所不同。

还有吗，还有一大堆问题，不到万不得已千万别用微服务，微服务不是万金油，软件工程里没有银弹，微服务的关键不在于微服务本身，而在于微服务的治理。

今天有点晚了先睡了 ，以后有机会再聊。

---

刚下班回来，接着再聊聊k8s。这东西是个docker容器相关的，所以先说说没有docker的时候是怎么弄的吧。

最开始呢，大家要搭网站部署应用是很麻烦的，要自己采购机器布网线，还要养一堆网络工程师，有些小企业觉得这个成本高，所以大多都把网站放到运营商机房里，然后远程连上服务器进行管理，这个时候连上的服务器都是真实的物理机。但是硬件资源配置都是固定的，你想要4核16G的服务器机房里还不一定有，那买个高配的又嫌贵浪费，真是左右为难。

然后有人提出了云计算的概念，刚开始国内谁都不知道云计算是个啥，阿里的马老板被王博士"忽悠"了开始做阿里云。当时国内没几个人知道云计算具体怎么做，看到谷歌发了那三篇著名的论文就以为云计算应该做成分布式存储分布式计算，然后阿里苦熬了几年换掉了玩具版的Hadoop做出了自主研发的分布式计算平台(刚开始叫飞天也就是现在的MaxCompute)，但是这玩意儿小企业根本不需要呀，我只想部署个小网站我要你的分布式有毛用啊。

另一边呢，远在大洋彼岸的另一个电商巨头亚马逊开始"不务正业"，搞了个AWS干起了卖虚拟机的生意，虚拟机的好处是资源可以弹性申请，解决了之前硬件资源配置的问题。虚拟机是依赖CPU的虚拟化技术，将硬件抽象化，在上面虚拟出的多个操作系统可以共享一组通用资源。

阿里云一看，原来云计算的生意是这么做的啊，云计算重点不是"计算"而是"云"，赶紧开始抄作业了。刚好美国有个Rackspace公司开发的虚拟化技术始终干不过AWS和VMware，一气之下开源了，也就是现在的OpenStack。阿里云真是幸运，想抄作业刚好有人把答案公开了，就这样阿里云开始做起了卖弹性云服务器(ECS)的生意。刚开始呢BAT的另外两位对云计算是嗤之以鼻的。

小马哥内心想着，这玩意能赚钱我跟马云姓。

![](https://pic2.zhimg.com/80/v2-c5f20e27c898fc826bc0b0ba91f2cddc_1440w.jpg?source=1940ef5c)

李彦宏心想，我不就不跟你们姓马了，我还是去耕耘我的互联网广告继续收割流量费吧。

![](https://pic1.zhimg.com/80/v2-e8164c43908c62a043663a225227550f_1440w.jpg?source=1940ef5c)


现实就是这么啪啪啪打脸，阿里云靠着卖虚拟机挣得盆满钵满——**一个教英语的老师给学计算机的李彦宏和小马哥上了一门叫《云计算》的商业课**。然后就是众所周知的打脸现场了，百度腾讯华为等一众互联网公司开始抢食云服务市场，很多大企业为了隐私安全也用OpenStack搭起了自己的私有云。

与此同时呢，10年的时候有个小公司基于Linux的容器化技术(LXC)开发了Docker，但是小公司不好混，经济上捉襟见肘，走投无路之际想到了开源。这不开则已，一开惊人，旋即吸引了谷歌微软亚马逊等一众大厂前来围观。这玩意儿就是Linux上的一个运行沙箱，这可比虚拟机省资源呐。


但是你本地起一两个Docker容器玩玩还好说，但是生产环境成千上万个容器可不好管理。Docker官方开发了Docker-compose和Swarm来管理容器，谷歌开发了K8S。最后大浪淘沙之下K8S已经成了容器编排的事实标准了。

容器化和微服务有啥关系吗？这两者起关联主要得益于DevOps这个概念——(开发Development即运维Operations)。以前没有云计算的时候有开发工程师，测试工程师，运维工程师，一整套流程是分工明确的。但是开发写完软件自测完成没问题了，交付给测试或运维发布后，不是这个环境有问题就是那个配置有问题，运维测试对开发说你是不是不行啊，开发心里那个气啊，你们这些不会写代码的麻瓜敢说劳资不行，看我不打掉你们的饭碗。刚好Docker技术出来了，开发工程师直接把软件和运行环境打包成Docker镜像，发布的时候只要把镜像往K8S集群部署就行，从此运维工程师们就失业了。微服务就是因为应用拆分的足够小，从开发到测试到上线基本上可以让一个人完成，一个微服务打包成一个docker镜像，发布的时候只要在k8s里申请相应的资源来运行这个docker镜像就行，开发人员美滋滋。

目前为止已经大致讲清了K8S和微服务的关系。微服务需要弹性计算，弹性扩缩容，而容器化的docker配合k8s就能很好的做到这一点。

但是其实我在想题主问的是不是这个狭义的K8S。因为K8S由谷歌主导开发的，谷歌联合了各大云服务商成立了云原生基金会，这个基金会里已经囊括了[很多云原生组件](https://landscape.cncf.io/)。

![](https://p.pstatp.com/origin/pgc-image/bb47b7f2f4b44f8e9a6c6d329a3693aa)

……

这里面ServiceMesh是号称可取代SpringCloud的下一代微服务技术。我看到阿里云和腾讯云上已经有服务网格的相关产品了，这块可以关注一下。

> 最后引用[知乎上一位亚马逊工程师的话](https://www.zhihu.com/people/ming-zi-zong-shi-hen-nan-qi)
>
> 计算机行业发展迅速，可以说几乎2-3年就有一次"工业革命", 发生在这个行业的各个不同的角落: 
>
> * 从waterfall开发方式到敏捷的开发思想，再到Agile is Dead, DevOps的兴起... 
> * 从过程式的编程思想到OO的兴起，再到FP慢慢渗透到现代语言的各个角落...
> * 从RMI的失败，到WSDL和SOAP的兴起，再到RESTful… 
> * 从3层layer的单机构架，到SOA/ESB，再到SOA is Dead, 微服务兴起...
> * 从实体物理机器，到VM虚拟机，再到docker+Kubernetes这种轻量级容器的兴起..
> * 从SQL和Oracle的霸业，到NoSQL的兴起，再到NoSQL转向NewSQL...
> * 从ActiveMq到SQS, Google pubsub这种完全用consistency换scalability的分布式队列，再到Kafka这种可以保证partition的strong ordering的分布式队列...
> * 从RDFS到OWL，再到现在利用deep learning的知识图谱建造，和knowledge graph embedding… 
> * 从管理大型机5000个cpu的网格计算，到把计算资源当作自来水一样即开即用的云计算从计算最多只能多线程的跑在cpu上，到hyperThread，GPU的大规模并行运算，再到TPU的大杀器…
> * 从雇佣专门的部署和运维管理团队，到现在的infrastructure as code，network as code… 
> * 从认为流系统无法保证consistency的初始storm和2014年才问世的Lambda Architecture，到4种可以一定程度保证end2end consistency的state of art的流系统(仅仅4年后lambda architecture就被Stream System一书的作者按在地上摩擦)，再到提出流和batch/表有本质联系的google Dataflow模型… 
> * 即使是在很多人眼里还是新概念的"大数据", 也已经经历了Hadoop+MapReduce 到Pig/Hive这种高层模型，再到Spark, Flink的无数迭代了;
> 甚至从手调openCL手调cpu优化，到现在的autoTVM… 
> 就更不用说machine Learning特别是deep Learning的大发展, 强化学习, 甚至量子计算机这些前沿领域了... 
>
