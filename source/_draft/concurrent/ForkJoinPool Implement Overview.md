# 实现概要



该类及其内部类控制着一组工作线程并提供了以下主要功能：

从非ForkJoin线程往队列提交任务。工作线程负责处理这些任务，然后工作线程通常将它们拆分成可被其他线程窃取的子任务。首选的规则是优先处理自己队列(LIFO或FIFO取决于工作模式)，然后按FIFO顺序随机地从其他队列窃取任务。该框架最开始使用工作窃取算法为了树形结构的并行。随着时间的推移，它的可扩展性优势使它扩展并修改以更好地支持更多样化的使用场景。因为它的大多数内部方法和内部类是相互关联的，所以它们的主要原理和描述在这里给出；单个的方法和内部类只包含相关细节的简短注释。

> 译者注：Fork/Join框架中工作线程均是ForkJoinWorkerThread类型或子类型，不是ForkJoinWorkerThread类型的线程统称为”非F/J线程“
>
> LIFO与FIFO的工作模式可以通过构造函数中的`asyncMode`参数指定。

## WorkQueues

大多数操作都在工作窃取队列中(WorkQueue内部类)。

WorkQueue是一种特殊形式的Deque，它只支持Deque四种操作中的三种：push, pop, poll(也可称之为steal)，更进一步的限制是push, pop只能被队列的所有者线程调用()，而poll可以被其他线程调用。(如果你对他们不熟悉，在继续之前你可能需要读Herlihy和Shavit的《[The Art of Multiprocessor programming](https://www.e-reading.club/bookreader.php/134637/Herlihy,_Shavit_-_The_art_of_multiprocessor_programming.pdf)》，第16章有更详细地描述了它们。)

工作窃取队列的主要设计与Chase、Lev的《[Dynamic Circular Work-Stealing Deque](http://www.dre.vanderbilt.edu/~schmidt/PDF/work-stealing-dequeue.pdf)》和Michael,、Saraswat、 Vechev的《[Idempotent work stealing](https://dl.acm.org/citation.cfm?doid=1504176.1504186)》论文大致相似。主要差异最终源于GC要求，我们尽可能地 ，即使在生成大量任务的程序中也尽可能地保证更小的占用。为了实现这一点，...

使用经典的数组添加任务的形式push(task)：`q.array[q.top] = task; ++q.top;`

实际代码需要进行对数组"null-check"和"size-check"，正确地阻止访问，然后可能通知等待中的工作线程开始扫描。。

pop操作(总是由所有者线程执行)如下：

```java
if( base != top && q[top] != null && cas(q[top]) != null){
    top++;
    return q[top];
} 
```

poll操作(总是由偷窃线程执行)如下：

```java

```

因为我们依赖于引用的CAS操作，所以我们不需要base或top的标记位。它们是简单的整形值，用于基于数组的循环队列(可以参看ArrayDeque例子)。更新索引保证`top==base`意味着队列是空的，但是当push、pop、poll没有完全提交时，可能会使队列显得非空。（`isEmpty()`方法检查删除最后一个元素部分完成的情况。）因此单独考虑poll操作并不是无等待的。一个偷窃线程直到另一个偷窃线程完成才能继续。但是总的来说，我们保证了大概率的非阻塞性。如果一个线程窃取失败，他总是选择不同的随机受害者作为下一个目标。所以为了让窃取线程能顺利进行，任何一个空队列上进行的poll或push操作都能完成。这就是为什么我们通常使用pollAt方法。

这种方式还支持用户模式，本地任务的处理使用FIFO而不是LIFO顺序，只需简单的使用poll而非pop。这在从不加入任务的消息传递框架中非常有用。然而，这两种模式都不考虑亲和力，负载，缓存本地等，因此很少在给定的机器上提供最佳性能，但通过对这些因素求平均可以提供良好的吞吐量。此外，即使我们确实试图使用这些信息，我们通常也没有开发它的基础。例如，一些任务集从缓存亲和力中获益，但其他任务受到缓存污染影响的伤害。此外，即使需要扫描，长期吞吐量通常最好使用随机选择而不是定向选择策略，因此在适用的情况下使用足够质量的廉价随机化。各种Marsaglia XorShifts在使用的时候都是内联的。

WorkQueues也以类似的方式用于提交到池的任务。我们不能将这些任务混合在工作队列使用队列中。相反，我们使用散列形式随机将提交队列与提交线程相关联。ThreadLocalRandom类生成值用作选择现有队列的哈希码，并且可以在与其他提交者争用时随机重新定位。本质上，提交者的行为类似于工作者，除了他们被限制执行他们提交的本地任务（或者在CountedCompleters的情况下，其他人具有相同的根任务）。在共享模式下插入任务需要锁定（主要是在调整大小的情况下保护），但我们只使用一个简单的自旋锁（使用字段qlock），因为遇到忙队列的提交者继续尝试或创建其他队列。它们仅在创建和注册新队列时阻止。 此外，“qlock”在shutdown时饱和到可解锁的值“-1”。在成功的情况下，解锁仍然可以通过更便宜的“qlock”有序写入来执行，但在不成功的情况下使用CAS。

# Management

工作窃取的主要吞吐量优势源于分散控制——工作线程大多从自己或彼此的队列中取任务，速度可能超过每秒10亿。线程池本身创建，激活（启用扫描和运行任务），停用，阻塞和终止线程，所有这些都只需要最少的中央信息。我们可以全局跟踪或维护一些属性，因此我们将它们打包成少量变量，通常保持原子性而不会阻塞或锁定。几乎所有基本上原子控制状态都保存在两个volatile变量中，这些变量最常被读取（而非写入）作为状态和一致性检查。（此外，“config”字段保持不变的配置状态。）“ctl”字段包含64位，其保存原子地决定添加，停用，入队（在事件队列上），出列和/或重新激活工作者所需的信息。为了实现这种打包，我们将最大并行度限制为（1 << 15）-1（远远超过正常工作范围），以允许id，计数及其否定（用于阈值处理）适合16位子字段。“runState”字段保存可锁定状态位（STARTED，STOP等），同时保护对workQueues数组的更新。当用作锁时，它通常仅用于一些指令（唯一的例外是一次性数组初始化和不常见的大小调整），因此在最多短暂旋转后几乎总是可用。但要谨慎，在旋转之后，方法awaitRunStateLock（仅在初始CAS失败时调用），在内置监视器上使用等待/通知机制阻止何时（很少）需要。对于高度竞争的锁定来说这是一个可怕的想法，但是大多数线程池在旋转限制之后没有锁定的情况下运行，所以这可以作为更保守的替代方案。因为我们没有内部Object用作监视器，所以在可用时使用“stealCounter”（一个AtomicLong）（它也必须被懒惰地初始化;请参阅externalSubmit）。

“runState”与“ctl”的用法仅在一种情况下相互作用：决定添加工作线程（请参阅tryAddWorker），在这种情况下，在保持锁定时执行ctl CAS。

记录WorkQueues。 WorkQueues记录在“workQueues”数组中。 首次使用时会创建该数组（请参阅externalSubmit）并在必要时进行扩容。 在记录新工作程序时更新数组，而未记录的终止工作程序由runState锁相互保护，但该数组可以同时读取和直接访问。 我们还确保数组引用本身的读取永远不会过时。 为了简化基于索引的操作，数组大小始终是2的幂，并且所有读取器必须容忍空槽。 工人队列是奇数指数。 共享（提交）队列在偶数索引处，最多64个插槽，以限制增长，即使阵列需要扩展以添加更多工作者。 以这种方式将它们组合在一起简化并加速了任务扫描。

所有工作线程创建都是按需创建的，由任务提交，替换已终止的工作线程和/或对被阻止的工作人员的补偿触发。 但是，所有其他支持代码都设置为与其他策略一起使用。 为了确保我们不会持有会阻止GC的工作引用，所有对workQueues的访问都是通过索引到workQueues数组（这里是一些凌乱的代码结构的一个来源）。 实质上，workQueues数组用作弱引用机制。 因此，例如，ctl的堆栈顶部子字段存储索引，而不是引用。

排队空闲工作线程。 与HPC工作窃取框架不同，我们不能让工作线程在无法立即找到任何工作时无限期地扫描任务，除非似乎有任务可用，否则我们无法启动/恢复工作线程。 另一方面，我们必须在提交或生成新任务时迅速采取行动。 在许多用途中，激活工作线程的加速时间是整体性能的主要限制因素，在JIT编译和分配的程序启动时更加复杂。 所以我们尽可能地简化了这一点。

“ctl”字段原子地维护活动和总工作者计数以及放置等待线程的队列，以便它们可以被定位用于信令。 活动计数也起到静止指示器的作用，因此当工作线程认为不再执行任务时会减少。 “队列”实际上是Treiber堆栈的一种形式。 堆栈非常适合以最近使用的顺序激活线程。 这改善了性能和位置，超过了容易发生争用和无法释放工作线程的缺点，除非它是最重要的堆栈。 当他们找不到工作时，我们在推动空闲工作堆栈（由ctl的低32位子字段表示）之后停放/取消停放工作。 顶部堆栈状态保存worker的“scanState”字段的值：其索引和状态，以及除计数子字段（也用作版本标记）之外的版本计数器，提供针对Treiber堆栈ABA效果的保护。

工作线程和线程池都使用字段scanState来管理和跟踪工作线程是否处于非活动状态（可能是阻塞等待信号），还是扫描任务（当他们都没有忙于运行任务时）。 当一个worker被停用时，它的scanState字段被设置，并且被阻止执行任务，即使它必须扫描一次以避免排队。 请注意，scanState更新滞后队列CAS版本，因此需要小心使用。 排队时，scanState的低16位必须保持其池索引。 因此我们在初始化时将索引放在那里（参见registerWorker），否则将其保留在那里或在必要时恢复它。



## Joining Tasks

当一个工作线程等待加入另一个被盗（或总是持有）的任务时，可以采取任何一种行动。 因为我们将许多任务复用到工作池上，所以我们不能让它们阻塞（如在Thread.join中）。 我们也不能只是将joiner的运行时堆栈重新分配给另一个并稍后替换它，这将是一种“延续”，即使可能也不一定是个好主意，因为我们可能需要一个未阻塞的任务和它的继续 进展。 相反，我们结合两种策略：

帮助：如果没有发生窃取，安排joiner执行一些将要运行的任务。

补偿：除非已有足够的活动线程，否则方法tryCompensate（）可以创建或重新激活备用线程，以补偿阻塞的加入者，直到它们解除阻塞。

第三种形式（在tryRemoveAndExec中实现）相当于帮助假设的补偿器：如果我们可以很容易地告诉补偿器的可能动作是窃取并执行正在连接的任务，则连接线程可以直接执行，而不需要 补偿线程（虽然以较大的运行时堆栈为代价，但权衡通常是值得的）。

ManagedBlocker扩展API无法使用帮助，因此仅依赖于方法awaitBlocker中的补偿。

helpStealer中的算法需要一种“线性帮助”的形式。每个工作线程（在字段currentSteal中）记录它从其他工作线程（或提交）中窃取的最新任务。它还记录（在现场currentJoin中）它当前正在加入的任务。方法helpStealer使用这些标记来尝试找到一个工作线程来帮助（即，从一个任务中窃取任务并执行它），这可以加速完成主动连接的任务。因此，如果待加入的任务没有被盗，则加入者执行将在其自己的本地deque上的任务。这是Wagner＆Calder所描述的方法的保守变体“Leapfrogging：实现有效期货的便携式技术”SIGPLAN Notices，1993（http://portal.acm.org/citation.cfm?id=155354）。它的不同之处在于：（1）我们只是在窃取时维护线程之间的依赖关系，而不是使用每个任务的簿记。这有时需要对workQueues数组进行线性扫描以找到窃取者，但通常不会因为窃取者留下提示（可能会陈旧/错误）的位置。这只是一个提示，因为一个工人可能有多次抢断，而提示只记录其中一个（通常是最新的）。提示隔离成本到需要时，而不是增加每个任务的开销。 （2）它是“浅的”，忽略了嵌套和潜在的循环相互窃取。 （3）故意racy：field currentJoin仅在积极加入时更新，这意味着我们在长期任务，GC停顿等期间错过了链中的链接（这是正常的，因为在这种情况下阻塞通常是一个好主意） 。 （4）我们限制了使用校验和找工作的次数，然后回退到暂停工作人员，必要时将其替换为另一工作线程。

对CountedCompleters的帮助操作不需要跟踪currentJoins：方法helpComplete接受并执行与等待的任务具有相同根的任何任务（更喜欢本地弹出到非本地轮询）。 但是，这仍然需要遍历完整链，因此效率低于使用没有显式连接的CountedCompleters。

补偿的目的不是准确保持在任何给定时间运行的未阻塞线程的目标并行数。 此类的某些先前版本对任何阻塞的连接使用立即补偿。 但是，在实践中，绝大多数阻塞都是GC和其他JVM或OS活动的短暂副产品，这些活动因更换而变得更糟。 目前，仅在通过检查字段WorkQueue.scanState验证所有声称活动的线程正在处理任务之后才尝试补偿，这消除了大多数误报。 此外，在最常见的情况下，补偿被绕过（容忍更少的线程），在这种情况下它很少有益：当具有空队列（因此没有连续任务）的工作者阻塞连接并且仍然保留足够的线程以确保活跃时。



## CommonPool

这个静态公用池在静态代码块初始化后一直存在。由于它可能不会被用到，所以我们最小化初始构造占用。。。